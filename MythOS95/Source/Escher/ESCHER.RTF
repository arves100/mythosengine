{\rtf1
{\comment
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

                              Escher Help

                     Microsoft Windows 95/98/NT Version

   Copyright (c) 1994-1999 by Dan Higdon, Tim Little, and Chuck Walbourn

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 THE AUTHORS MAKE NO WARRANTIES, EXPRESS OR IMPLIED, AS TO THE CORRECTNESS
 OF THIS CODE OR ANY DERIVATIVE WORKS WHICH INCORPORATE IT.  THE AUTHORS
 PROVIDE THE CODE ON AN "AS-IS" BASIS AND EXPLICITLY DISCLAIMS ANY
 LIABILITY, INCLUDING CONSEQUENTIAL AND INCIDENTAL DAMAGES FOR ERRORS,
 OMISSIONS, AND OTHER PROBLEMS IN THE CODE.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

                        http://www.mythos-engine.org/

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 Escher is a component of the MythOS(tm) collection.

 MythOS is a trademark of Charybdis Enterprises, Inc.

ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
}

{\fonttbl
\f0\fswiss Arial;
\f1\froman Times New Roman;
\f2\fmodern Courier New;
\f3\fswiss MS Sans Serif;
\f4\froman MS Serif;
}
\deff1
\fs21

{\colortbl;
\red128\green128\blue128;
\red0\green0\blue128;
\red0\green128\blue0;
\red128\green0\blue0;
}

{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°

                            Programmer's Guide

°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
Overview                                                                  ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_OVERVIEW}
${\footnote Overview}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 Overview}\par\pard\sb100

{\i Escher} is a 3D draw system for use with the {\i Van Gogh} draw
 system, which also relies on {\i Ivory}, {\i XFile}, and {\i Felix}.  The
 purpose of {\i Escher} is to provide support for rendering of 3D
 objects such as polygonal meshes or collections of 3D points
 using various shading models in real time.
\par

The design of {\i Escher} was driven by several factors.  First, it
 had to be fast in order to be useful for interactive 3D
 environments.  Second, {\i Escher} had to be able to display various
 kinds of objects that require specialized draw algorithms such
 as polygon meshes and height-field terrain.  Finally, {\i Escher} was
 designed to be extensible for application-specific classes and
 lighting systems.
\par

{\i Escher} supports both Z-buffering (as provided by {\i Van Gogh}) and
 element-based sorting (Painter's algorithm), although intersections are
 not resolved in sorting mode.  Also, the current lighting model assumes
 that the output device cannot shade from any arbitrary color to another
 one, so all lights are assumed to be white light with a varying intensity.
 Triangles are assumed as the basic drawing element of polygons, although
 this can be extended by inheriting a new draw class.  Finally, alpha level
 can only be set for a face rather than for a vertex.
\par

This document assumes the reader is familiar with basic 3D
 graphics techniques such as transformation, projection, shading,
 and basic vector and matrix math operations.
\par

The data format for representing numbers was 16.16 using the {\i Felix}
 library for fixed-point support.  This version of {\i Escher} uses
 single-precision floating-point numbers.  Backwards compatability with
 old data files has been maintained, but some code will need updating
 to prevent compile warnings and errors, mostly relating to numeric
 constants which C promotes to double-precision.
\par

\line{\b\fs28 Features}\par

Real-time 3D performance with various shading and lighting
 options.
\par

Highly integrated with {\i Van Gogh} Draw Library for hardware
 independence and performance.
\par

Extensible drawable object, with provided support for various 3D
 objects including particle fields, height-field terrain, and
 polygonal meshes.
\par

Hierarchical modeling supported for relative movement control
 and intersection of polygonal mesh objects.
\par

A wide variety of specialized lights and procedure textures as well
 as a solid framework for extending the library to include custom
 special effects.
\par

Various data-loading methods for bulk loading of lights,
 cameras, and objects to allow fine control over individual item
 importing.
\par

\line{\b\fs28 Definitions}\par

{\b Collision Detection}\par

The phrase collision detection refers to the process of computing which
 objects, if any, have overlapping extents with a specific object in the
 scene.
\par

{\b Context}\par

The current context comprises all informational class objects
 for a render, including the current camera, drawable, and light
 list.
\par

{\b Drawables}\par

These are class objects that understand how to display
 themselves in reference to the current drawing context.
 Examples of drawables include particle systems, terrain systems,
 and polygonal meshes.
\par

{\cf2
Note:  Drawables are sometimes referred to as objects.
}\par

{\b Element}\par

An element is the result of the 3D pipeline after clipping
 and projection and is the final pixel, line, or polygon that is to
 be drawn into the viewport.  To create a correct 3D scene, these
 elements must be sorted in depth.  This occurs automatically when
 using a Z-buffer, but must be done explictly when not using a Z-buffer
 and for translucent alpha-blended faces even with a Z-buffer.
\par

{\b Extents}\par

These are simple bounding volumes completely enclosing a
 geometric object or other drawable which can be tested against
 efficiently for collision or view rejection/acceptance.
\par

{\b Frame-of-reference}\par

A frame-of-reference consists of a transformation matrix and a
 direction vector which points down the positive Z-axis.  A
 frame-of-reference moves from one coordinate system into
 another.  A frame-of-reference also includes the inverse
 transformation matrix.  By definition, the forward
 transformation moves from local coordinates (or eye coordinates
 for the camera) to world coordinates.
\par

{\cf2
Note:  As a result of this definition, points are transformed
 into the eye coordinate system via the inverse transform of the
 camera.  This definition insures that the position and other
 controls for the camera's frame-of-reference work as expected.
}\par

{\b Geometry}\par

These are drawable class objects which include a tree-structure
 hierarchy with local frames-of-reference and extents
 information.  They are generally defined using geometric
 primitives (i.e., polygonal mesh).
\par

{\b Mesh}\par

A mesh is a connected set of geometric primitives.  In this
 document, this refers to a polygonal mesh consisting of triangles.
\par

{\b Object}\par

The word object is used in two ways in this document as either a
 class or geometric object.  A class object is a C++ class
 instance.  A geometric object is a drawable entity (i.e., a geometry).
\par

{\b Partition}\par

A partition refers to a mechanism which maintains seperated lists of
 drawables based on their extents.  A partition can exploit it's knowledge
 of the distribution of drawables in world-space to speed-up drawing,
 collision detection, picking, and other operations.
\par

{\b Picking}\par

The word picking refers to performing ray intersections with objects
 in the scene to determine which object is being 'picked' or selected
 by the user.  This also more generically refers to the process
 of computing the objects hit by a ray.
\par

{\b Scenes}\par

Collections of lights, cameras, and mesh objects may be exported
 together as a scene, then loaded by {\i Escher} using the scene name.
 Scenes can be used to duplicate a 3D setup in the {\i Escher}
 renderer, or can be used as a bulk-loading mechanism only.
 Object hierarchies can only be exported within a scene's
 context, although the developer is free to extend or create
 other management systems.
\par

{\cf2
Note:  The word 'scene' in computer graphics can also refer to
 the view from a given render (i.e., to render a scene).
 Although {\i Escher} scene classes can be used in this way, they
 are also suitable for use as a bulk loading system, then the objects
 may be removed from the lists and inserted elsewhere.
}\par

{\b Textures}\par

These are 2D bitmaps 'mapped' onto the surface of image elements
 to provide 'texture' within the image.  This mapping is
 performed by {\i Van Gogh}'s various texture-mapping output routines.
 Textures are managed by {\i Escher}.
\par

\line{\b\fs28 Organization}\par

The {\i Escher} library consists of a large number of classes and
 structures, but only a few distinct groups which form the basis for
 using the library.  Once the basic classes have been mastered, new
 portions of the functionality can be explored.  The following is a
 list of each group and the class objects belonging to them:
\par

C-style Routines\line
\tab {\uldb Math Functions}{\v PG_ESCH_CSTYMATH}\line
\tab {\uldb Draw Functions}{\v PG_ESCH_CSTYDRAW}\line
\tab {\uldb Clip Support Functions}{\v PG_ESCH_CSTYCLIP}
\par

Control/Collection Classes\line
\tab {\uldb EschSystem}{\v PG_ESCH_SYSTEM}\line
\tab {\uldb EschScene}{\v PG_ESCH_SCENE}
\par

Drawable Classes\line
\tab {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\tab Basic Drawables\line
\tab\tab {\uldb EschPointDraw}{\v PG_ESCH_POINTDRAW}\line
\tab\tab {\uldb EschLineDraw}{\v PG_ESCH_LINEDRAW}\line
\tab\tab {\uldb EschPlaneDraw}{\v PG_ESCH_PLANEDRAW}\line
\tab\tab {\uldb EschSprite}{\v PG_ESCH_SPRITE}
\par

\tab Particle Drawables\line
\tab\tab {\uldb EschParticle}{\v PG_ESCH_PARTICLE}\line
\tab\tab {\uldb EschParticleLine}{\v PG_ESCH_PARTICLELINE}\line
\tab\tab {\uldb EschParticlePyramid}{\v PG_ESCH_PARTICLEPYR}\line
\tab\tab {\uldb EschParticleGeometry}{\v PG_ESCH_PARTICLEGEOM}\line
\tab\tab {\uldb EschParticleSprite}{\v PG_ESCH_PARTICLESPR}\line
\tab\tab {\uldb EschParticleSystem}{\v PG_ESCH_PARTICLESYS}\line
\tab\tab {\uldb EschParticleGenerator}{\v PG_ESCH_PARTICLEGEN}
\par

\tab Geometry Drawables\line
\tab\tab {\uldb EschGeometry}{\v PG_ESCH_GEOMETRY}\line
\tab\tab {\uldb EschMeshDraw}{\v PG_ESCH_MESHDRAW}
\par

\tab Terrain Drawables\line
\tab\tab {\uldb EschTerrain}{\v PG_ESCH_TERRAIN}\line
\tab\tab {\uldb EschTerrainEx}{\v PG_ESCH_TERRAINEX}\line
\tab\tab {\uldb EschTerrainTreeTop}{\v PG_ESCH_TERRAINTREETOP}
\par

\tab Partitioning Drawables\line
\tab\tab {\uldb EschPartition}{\v PG_ESCH_PARTITION}\line
\tab\tab {\uldb EschGridPartition}{\v PG_ESCH_GRIDPARTITION}\line
\tab\tab {\uldb EschQuadTreePartition}{\v PG_ESCH_QUADTREEPARTITION}\line
\tab\tab {\uldb EschOctTreePartition}{\v PG_ESCH_OCTTREEPARTITION}
\par

\tab Misc Drawables\line
\tab\tab {\uldb EschStarfield}{\v PG_ESCH_STARFIELD}\line
\tab\tab {\uldb EschPlosion}{\v PG_ESCH_PLOSION}\line
\tab\tab {\uldb EschMetabox}{\v PG_ESCH_METABOX}\line
\tab\tab {\uldb EschLevelOfDetail}{\v PG_ESCH_LOD}\line
\tab\tab {\uldb EschKeyframeDraw}{\v PG_ESCH_KFDRAW}
\par

Drawable Support Structures\line
\tab {\uldb EschCollision}{\v PG_ESCH_COLLISION}\line
\tab {\uldb EschPicking}{\v PG_ESCH_PICKING}\line
\tab {\uldb EschDrawList}{\v PG_ESCH_DRAWLIST}\line
\tab {\uldb EschPartitionList}{\v PG_ESCH_PARTITIONLIST}\line
\tab {\uldb EschTraverse}{\v PG_ESCH_TRAVERSE}
\par

Drawable Support Classes\line
\tab {\uldb EschSphereExtents}{\v PG_ESCH_SPHERE_EXTS}\line
\tab {\uldb EschBoxExtents}{\v PG_ESCH_BOX_EXTS}\line
\tab {\uldb EschFace}{\v PG_ESCH_FACE}\line
\tab {\uldb EschMesh}{\v PG_ESCH_MESH}
\par

Camera Classes\line
\tab {\uldb EschCamera}{\v PG_ESCH_CAMERA}\line
\tab {\uldb EschCameraEx}{\v PG_ESCH_CAMERAEX}
\par

Light Classes\line
\tab {\uldb EschLight}{\v PG_ESCH_LIGHT}\line
\tab {\uldb EschVectorLight}{\v PG_ESCH_VECTORLIGHT}\line
\tab {\uldb EschFastPointLight}{\v PG_ESCH_FPOINTLIGHT}\line
\tab {\uldb EschFastAttenLight}{\v PG_ESCH_FATTENLIGHT}\line
\tab {\uldb EschFastSpotLight}{\v PG_ESCH_FSPOTLIGHT}\line
\tab {\uldb EschPointLight}{\v PG_ESCH_POINTLIGHT}\line
\tab {\uldb EschAttenLight}{\v PG_ESCH_ATTENLIGHT}\line
\tab {\uldb EschSpotLight}{\v PG_ESCH_SPOTLIGHT}
\par

Texture Classes\line
\tab {\uldb EschTexture}{\v PG_ESCH_TEXTURE}\line
\tab {\uldb EschStaticTexture}{\v PG_ESCH_STATICTEXTURE}\line
\tab {\uldb EschMultiFrameTexture}{\v PG_ESCH_MFRAMETEXTURE}\line
\tab {\uldb EschProceduralTexture}{\v PG_ESCH_PROCTEXTURE}\line
\tab {\uldb EschFireTexture}{\v PG_ESCH_FIRETEXTURE}
\par

Motion Classes\line
\tab {\uldb EschKeyframer}{\v PG_ESCH_KEYFRAMER}\line
\tab {\uldb EschKeyframeDraw}{\v PG_ESCH_KFDRAW}\line
\tab {\uldb EschLimbSegment}{\v PG_ESCH_LIMBSEG}
\par

Render Support Classes\line
\tab {\uldb EschContext}{\v PG_ESCH_CONTEXT}\line
\tab {\uldb EschElement}{\v PG_ESCH_ELEMENT}
\par

Builder Classes\line
\tab {\uldb EschBuildTexture}{\v PG_ESCH_BUILDTEXTURE}\line
\tab {\uldb EschBuildMesh}{\v PG_ESCH_BUILDMESH}
\par

Math Support Classes\line
\tab {\uldb EschPoint}{\v PG_ESCH_POINT}\line
\tab {\uldb EschVector}{\v PG_ESCH_VECTOR}\line
\tab {\uldb EschPlane}{\v PG_ESCH_PLANE}\line
\tab {\uldb EschVertex}{\v PG_ESCH_VERTEX}\line
\tab {\uldb EschMatrix}{\v PG_ESCH_MATRIX}\line
\tab {\uldb EschFrameRef}{\v PG_ESCH_FRAMEREF}
\par

\line{\b\fs28 Future Work}\par

This library will continue to be expanded as time permits.  There are notes
 in each class of likely changes for future releases.  Additional drawables
 and procedural textures will be added to continue to expand the
 functionality of the library, along with refinements to the supporting
 tools.
\par

There are currently no plans to expand {\i Escher} for use in non-real
 time environments (i.e., raytracing or radiocity rendering), but nothing
 precludes {\i Escher} from being extended in that direction.
\par

If you have any specific requests, please direct them to {\uldb Charybdis
 Enterprises, Inc.}{\v NOTICE}
\par

\pard\page



{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°° C-Style Routines °°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
C-style Math Functions                                                    ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_CSTYMATH}
${\footnote C-style Math Functions}
K{\footnote esch_rotatex;
esch_rotatey;
esch_rotatez;
esch_transform;
esch_transform_notran;
esch_cross;
esch_dot;
esch_magnitude;
esch_normalize;
esch_concatmatrix;
esch_detmatrix;
esch_inversematrix}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 C-style Math Functions}\par\pard\sb100

There are a few C-callable functions available in {\i Escher}.  These
 are used internally to implement the EschPoint, EschVector and
 EschMatrix class objects.  They are documented here for use from
 assembly routines as C use of {\i Escher} is extremely limited.
 There are no C headers for these functions or the types they require.
\par

\line{\b\fs28 Synopsis}\par

#include "esmath.hpp"
\par

\line{\b\fs28 Routines}\par

{\b void esch_rotatex(const void *s, const float deg, void *d);}\par

Rotates an EschPoint or EschVector about the X-axis deg degrees.
 A pointer to the input is given as s and a pointer to the
 destination is given as d.  They can both point to same class
 instance.
\par

{\b void esch_rotatey(const void *s, const float deg, void *d);}\par

Rotates an EschPoint or EschVector about the Y-axis deg degrees.
 A pointer to the input is given as s and a pointer to the
 destination is given as d.  They can both point to same class
 instance.
\par

{\b void esch_rotatez(const void *s, const float deg, void *d);}\par

Rotates an EschPoint or EschVector about the Z-axis deg degrees.
 A pointer to the input is given as s and a pointer to the
 destination is given as d.  They can both point to same class
 instance.
\par

{\b void (*esch_transform)(const void *s, const EschMatrix *m, void *d);}\par

Transforms an EschPoint or EschVector by the given matrix m.  A
 pointer to the input is given as s and a pointer to the
 destination is given as d.  They can both point to same class
 instance.
\par

{\b void (*esch_transform_notran)(const void *s, const EschMatrix *m, void *d);}\par

Transforms an EschPoint or EschVector by the given matrix m,
 ignoring any translation in the matrix (needed for vector
 transformation).  A pointer to the input is given as s and a
 pointer to the destination is given as d.  They can both point
 to same class instance.
\par

{\b EschVector *(*esch_cross)(const EschVector *v1, const EschVector *v2,
 EschVector *dest);}\par

Computes the cross-product of the two input EschVector objects.
 The dest pointer may point to the same data as either v1 or v2.
 The dest pointer is returned.
\par

{\b float esch_dot(const EschVector *v1, const EschVector *v2);}\par

Computes the dot-product of the two input EschVector class instances.
\par

{\b float esch_magnitude(const EschVector *vect);}\par

Computes the magnitude of the vector using 64-bit internal math
 to reduce the chance of overflow.
\par

{\b void (*esch_normalize)(EschVector *vect);}\par

This normalizes the vector if the magnitude is greater than 0.0001, otherwise
 the vector is left unchanged.
\par

{\b void (*esch_concatmatrix)(const EschMatrix *s, const EschMatrix *m,
 EschMatrix *d);}\par

Concatenates the two matrices s and m by performing a matrix
 multiply.  The result is placed into d, which can be the same as
 either s or m.
\par

{\b float esch_detmatrix(const EschMatrix *matrix);}\par

Computes the determinant of the matrix.
\par

{\b int esch_inversematrix(const EschMatrix *matrix, EschMatrix *d);}\par

Computes the inverse matrix for the matrix using Cramer's rule.
 The result is placed into d, which can be the same as matrix.
 The return value is 0 on success, or non-zero if the inverse
 does not exist--this occurs when the determinant is zero.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
C-style Draw Functions                                                    ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_CSTYDRAW}
${\footnote C-style Draw Functions}
K{\footnote esch_clipdraw_point;
esch_clipdraw_line;
esch_clipdraw_face;
esch_rotate_check}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 C-style Draw Functions}\par\pard\sb100

The {\i Escher} library uses these C calls to perform the low-level output
 of pixels, lines, and faces.  The majority of the information for the draw
 functions are located in the context data (see
 {\uldb EschContext}{\v PG_ESCH_CONTEXT}).
\par

The esch_clipdraw_face function performs the following steps:
\par
The face information is dereferened from the input index (using the faces
 array of the current context).
\par
If {\i ESCH_CDF_CLIP} is set, then clipping tests using the camera of the
 current context are performed.  If it is fully invisible, the routine
 returns.  First Z is tested, then X and Y.
\par
The points of the face (taken from the vpoints array of the current context)
 are projected if they have not already been marked as such (indicated in
 the vflags array of the current context).
\par
The points are copied into a local work array, setting the color of all
 points to that of the 'a' index (the shade values are also copied from 'a'
 if {\i ESCH_CAM_SMOOTH} is not set in the camera of the current context).
\par
If {\i ESCH_CDF_BFCULL} was set, then a rotation check is performed.  If it
 indicates that the polygon points are counter-clockwise, then the routine
 returns.  This is only valid if the input points are clockwise.
\par
If any clipping flags were set, the polygon is clipped.
\par
The z values of the work points are scaled to fill 32-bits based on the
 hither and yon planes of the camera of the current context.
\par
Finally, based on the camera flags of the current context, the proper
 {\i Van Gogh} polygon routine (or line routine for wireframe) is called to
 draw the (clipped) polygon.  If textures are required, they are locked
 and then unlocked.
\par

Two global variables {\b EschProposedTris} and {\b EschDrawnTris} are
 updated by esch_clipdraw_face for each call to the routine and for each
 triangle that was not rejected by the clipping, respectively.  They
 must be cleared by the application (they are of type ulong).
\par

\line{\b\fs28 Synopsis}\par

#include "eselemnt.hpp"
\par

\line{\b\fs28 Routine}\par

{\b void esch_clipdraw_point(dword ctrlfl=ESCH_CDF_CLIP);}\par

Draws a point with coordinates in the global {\b EschTempVPointF} performing
 3D clipping, projection, and passing parameters to {\i Van Gogh} or placing
 the result into the element buffer for sorted output.  The point MUST be
 transformed into the frame of the eye before calling this routine and the
 proper shade and color values must also be provided.  The ctrlfl parameter
 provides control bits (see {\b Control Flags}).
\par

{\b void esch_clipdraw_line(VngoPointF *vpt2, dword ctrlfl=ESCH_CDF_CLIP);}\par

Draws a line a point with one end-piont in the global {\b EschTempVPointF}
 and the other passed as vpt2 performing 3D clipping, projection,
 and passing the parameters to {\i Van Gogh} or placing the result into
 the element buffer for sorted output.  The endpoints must be transformed
 into the frame of the eye before calling this routine and the proper shade
 and color values must also be provided.  The ctrlfl parameter provides
 control bits (see {\b Control Flags}).
\par

{\b void esch_clipdraw_face(ulong ind, dword ctrlfl=ESCH_CDF_CLIP);}\par

Draws the ind'th face in the current EschContext face array, performing
 3D clipping, rotation check, projection, and passing parameters to {\i Van
 Gogh} or placing the result into the element buffer for sorted outpout.
 The vertices for the face MUST be transformed into the frame of the eye
 before calling this routine, and the proper shade and color values must
 also be provided.  The ctrlfl parameter provides control bits (see
 {\b Control Flags}).
\par

{\b int esch_rotate_check(ulong count,VngoPoint *pts);\line
int esch_rotate_check(ulong count,VngoPoint *pts,EschCamera *cam=0);}\par

This routine is called to check the rotation of the polygon by
 ecsh_clipdraw_face if dobfcul is set.  It returns 1 if the polygon
 is clockwise, 0 otherwise.
\par

{\cf2 Note: The polygon's Z values are not used, so this routine is only
 suitable for post-projection tests.}
\par

\line{\b\fs28 Control Flags}\par

{\i ESCH_CDF_CLIP}\tab Clip against view volume.  If not set, assumed to
 be fully visible.
\par

{\cf4 Note: Calling the clipdraw functions on partially visible or
 invisible draw elements without {\i ESCH_CDF_CLIP} set will result
 in protection faults/memory overwrites.}
\par

{\i ESCH_CDF_BFCULL}\tab Perform post-projeciton rotation check on input
 points (which are assumed to be in clockwise order).  This only applies
 to faces.
\par

{\cf2 Note: Backculling is more efficiently done using the face normal
 instead of {\i ESCH_CDF_BFCULL}, but it is not always available (in
 particular, as used by the {\i Escher} terrain system, face normals
 are not available for the draw operation).}
\par

{\i ESCH_CDF_INFINITEZ}\tab Draws at infinite projected Z to ensure it
 is sorted behind all other elements.
\par

{\i ESCH_CDF_MUSTTXT}\tab\tab Must use texture mapping even if textures are
 not 'active'.  This only applies to faces.
\par

{\i ESCH_CDF_DONTSORT}\tab Do not place into element list, always draw
 immediatly.  This requires that the correct order of draw is already
 enforced.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
C-style Clip Support Functions                                            ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_CSTYCLIP}
${\footnote C-style Clip Support Functions}
K{\footnote esch_clip_to_frustrum;
esch_clip_to_plane}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 C-style Clip Support Functions}\par\pard\sb100

To support the clipping operations, the {\i Escher} library uses
 C calls internally to perform the computation.
\par

{\cf3
These routines are not fully documented as they are generally only needed by
 the internal {\uldb clipdraw}{\v PG_ESCH_CSTYDRAW} routines.  If detailed
 information on using these routines is required, please contact
 {\uldb Charybdis Enterprises, Inc.}{\v NOTICE}
}\par

\line{\b\fs28 Synopsis}\par

#include "eselemnt.hpp"
\par

\line{\b\fs28 Routines}\par

{\b extern "C" int esch_clip_to_frustrum
 (ulong *count, VngoPoint *pts,
 VngoPoint *outpts,
 EschCamera *cam, dword level);}\par

Clips the input line or polygon given the input points, the camera containing
 the clipping planes, and the drawing level bits (to determine if the
 texture and shading data should be clipped as well).
\par

{\b extern "C" int esch_clip_to_plane
 (int *count, VngoPoint *in, VngoPoint *out,
 EschPlane *plane, dword level);}\par

Clips the input line or polygon given the input points, the plane to
 clip against, and the drawing level bits (to determine if the texture
 and shading data should be clipped as well).
\par

\pard\page


{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°° Control/Collection Classes °°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschSystem Class                                                          ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_SYSTEM}
${\footnote EschSystem Class}
K{\footnote EschSystem;
EschSystem, init;
EschSystem, release;
EschSystem, enable_amd3d;
EschSystem, disable_amd3d}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschSystem Class}\par\pard\sb100

In order to use the {\i Escher} library, an instance of the
 EschSystem class object must be created before any {\i Escher} class
 object is used.  This class instance contains diagnostic
 information as well as global library data.  Two {\i Ivory} arenas
 are allocated for use by the drawable objects as workspace and as
 the element sort area.
\par

This class instance must be initialized either by providing a
 parameter to the constructor or explicitly calling the init()
 member function before any other {\i Escher} object is created or
 used.
\par

{\cf3
Additional global information will be added to this class, as needed.
}\par

\line{\b\fs28 Name}\par

EschSystem - Library Control Object
\par

\line{\b\fs28 Synopsis}\par

#include "essystem.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschSystem(ulong arena_size=0, ulong sort_size=0);}\par

Initializes the diagnostic information and calls the init() function
 if the arena_size variable is non-zero.  Otherwise, init() should be called
 before using any other {\i Escher} functions.  {\b EschSysInstance} is set
 to point to this instance for use by the various routines in the library.
\par

{\cf4 Note: Only one instance of EschSystem is allowed.}
\par

\line{\b\fs28 Member Data}\par

{\b dword flags;}\par

State flags for the {\i Escher} library (See {\b Flags} below).
\par

{\b ulong wspace_sbytes;}\par

The initial size of the workspace arena set by the init() function.
\par

{\b ulong wspace_mbytes;}\par

Maximum number of bytes needed out of workspace arena by any {\i Escher}
 class--useful for tuning the arena size.  The drawable objects
 update this number whenever they can determine the amount of
 arena space needed for the draw operation.
\par

{\b IvoryArena *wspace;}\par

This points to an {\i Ivory} arena for use by the various {\i Escher}
 objects as temporary workspace.  For example, the EschMeshDraw
 class uses arena space for transformed/projected vertices and EschTerrain
 uses the arena to store points during the draw routine.  The arena is
 generally cleared at the start of each drawable class' draw() routine.
\par

{\b ulong sspace_sbytes;}\par

The initial size of the sort area set by the init() function.
\par

{\b ulong sspace_mbytes;}\par

Maximum number of bytes needed out of sort area--useful for tuning the
 sort size.  The {\uldb EschElement}{\v PG_ESCH_ELEMENT} flush() routine
 updates this value.
\par

{\b ulong sspace_mdepth;}\par

Maximum depth of tree within sort area.  The
 {\uldb EschElement}{\v PG_ESCH_ELEMENT} insert() routine updates this
 value.
\par

{\b IvoryArena *sspace;}\par

This points to an {\i Ivory} arena for use as the element sort area
 by the {\uldb drawface}{\v PG_ESCH_CSTYDRAW} functions.  This is used
 to create a list of all visible pixels, lines, and faces to output in
 sorted order (needed for alpha-blending if using a Z-buffer or for
 Painter's algorithm if not using a Z-buffer).  This is generally
 cleared once per frame by the camera after flushing all pending
 elements.
\par

{\b EschElement *sroot;}\par

Points to the start the element sort area list if any items are pending.
 This is used by the {\uldb EschElement}{\v PG_ESCH_ELEMENT} insert() and
 flush() routines.
\par

{\b ulong diag_faces;}\par

Diagnostic count for number of faces loaded into EschMesh class
 instances.
\par

{\b ulong diag_verts;}\par

Diagnostic count for number of vertices loaded into EschMesh instances.
\par

{\b ulong diag_ifaces;}\par

Diagnostic count for number of faces attached so the EschMeshDraw
 class instances.  This count will be equal to or greater than the
 diag_faces variable.
\par

{\b ulong diag_iverts;}\par

Diagnostic count for number of vertices attached so the EschMeshDraw
 class instances.  This count will be equal to or greater than the
 diag_verts variable.
\par

{\b ulong diag_ntxts;}\par

Diagnostic count for number of texture instances.
\par

{\b ulong tcache_hi;\line
ulong tcache_max;\line
EschTextureCache *tcache;}\par

Texture cache data used by static EschTexture members.
\par

{\b ulong tfile_hi;\line
ulong tfile_max;\line
EschTextureFile *tfile;}\par

Shared texture file registry data used by static EschTexture members.
\par

\line{\b\fs28 Member Functions}\par

{\b esch_error_codes init(ulong arena_size=ESCH_DEFAULT_ARENA,
 sort_size=ESCH_DEFAULT_SORT);}\par

Initializes the workspace arena and element sort area. Returns
 {\i ESCH_ERR_NONE} or {\i ESCH_ERR_NOMEMORY}.
\par

{\b void release();}\par

Releases all global workspace (including any texture cache).  This
 invalidates parts needed for the {\i Escher} library and should
 be called only after all objects have been destroyed.  This is
 called by the destructor.
\par

{\b  esch_error_codes enable_amd3d();}\par

Enables the AMD-3D(TM) Technology enhancments if available.  An error
 is returned if the processor doesn't support these enhancements.  This
 is accomplished by changing some of the low-level C routines which use
 function pointers so they can be changed at run-time.
\par

{\b void disable_amd3d();}\par

Disbles the AMD-3D(TM) Technology enhancments if active and returns to the
 standard float-point versions.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_SYS_AMD3D}\tab The AMD-3D Technology enhancements are in use.  This
 is set by enable_amd3d() if AMD-3D is detected and cleared by
 disabled_amd3d().
\par

{\i ESCH_SYS_MMX_FOUND}\tab This indicates that init() detected an MMX(TM)
 Technology enhanced processor.
\par

{\i ESCH_SYS_AMD3D_FOUND}\tab This indicates that init() detected an
 AMD-3D(TM) Technology enhanced processor.
\par

\line{\b\fs28 Example}\par

{\f2
EschSystem      EscherLib;
\par
EscherLib.init();
\par
// Various calls and objects in Escher
\par
}
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschScene Class                                                           ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_SCENE}
${\footnote EschScene Class}
K{\footnote EschScene;
EschScene, operator =;
EschScene, release;
EschScene, set_flags;
EschScene, load}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschScene Class}\par\pard\sb100

This class object is used as a container for a 3D scene, which
 is a collection of EschCamera, EschLight, and EschMesh/EschMeshDraw
 class instances.  The scene can be loaded from an exported file as a
 single collection including all cameras, lights, and objects in their
 proper locations and hierarchy, if that information was included in the
 export of the scene, by specifing the scene name to load.  The loaded
 instances may be removed or referenced as needed.
\par

{\cf2 Note: Use of an EschScene class instance is optional and is
 provided as a convience.  The individual load members of the classes
 can be used to load the data instead.}\par

\line{\b\fs28 Name}\par

EschScene - 3D Scene Container Object
\par

\line{\b\fs28 Synopsis}\par

#include "esscene.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschScene(); }\par

Initializes the data members to empty values.
\par

{\b EschScene(const char *fname, const char *sname=0, VngoPal
*pal=0, dword flgs=ESCH_SCENELD_ALL);}\par

Initializes the data members to empty, then performs a load if
 fname is non-zero.
\par

{\b EschScene(const EschScene &s);}\par

Initializes the scene from another scene, clearing the owns bit.
\par

\line{\b\fs28 Member Data}\par

{\b dword flags;}\par

Scene control flags (see Flags).  Should be set with set_flags().
\par

{\b char name[ESCH_MAX_NAME];}\par

The name of the scene.
\par

{\b ulong ncameras;\line
EschCamera *cameras;}\par

Count and pointer to linked-list of cameras, if any defined in the scene.
\par

{\b ulong nlights;\line
EschLight *lights;}\par

Count and pointer to linked-list of lights, if any defined in the scene.
\par

{\b ulong nmeshes;}\par

Count of mesh and meshdraw class instances.
\par

{\b EschMeshDraw *meshes;}\par

Pointer to linked-list tree heads for the mesh drawables in the scene.
\par

\line{\b\fs28 Member Functions}\par

{\b const EschScene &operator = (const EschScene &s);}\par

Copies the data from another scene and clears the owns bits of the
 target.  Any previously owned data is freed.
\par

{\b virtual void release();}\par

Releases all data owned by the scene instance.  This is called by
 the destructor.
\par

{\scaps\cf4 NEW}\line
{\b void set_flags(const dword f);\line
void set_flags(const dword m, const int on);}\par

Sets the scene control flags.
\par

{\b virtual esch_error_codes load(const char *fname, const char
 *sname=0, VngoPal *pal=0, dword flgs=ESCH_SCENELD_ALL);}\par

Loads the scene from the given file, using the load flgs to
 control the load process.  The pal is used as the palette to for
 recoloring the mesh instances (See Load flags).
\par

{\b virtual esch_error_codes load(XFParseIFF *iff, const char
 *sname=0, VngoPal *pal=0, dword flgs=ESCH_SCENELD_ALL);}\par

Will load the scene from the given IFF file if chunk currently
 pointed to is a scene form.  If the sname is given, it is compared
 to the name of the scene in the form header and the load fails if
 the names do not match.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_SCENE_OWNSDATA}\tab Indicates that the buffers should be
 deleted by the release member.
\par

{\i ESCH_SCENE_APP0} -\line
{\i ESCH_SCENE_APP7}\tab Reserved for use by the application.
\par

\line{\b\fs28 Load Flags}\par

{\i ESCH_SCENELD_LIGHTS}\tab Load lights.
\par

{\i ESCH_SCENELD_CAMERAS}\tab Load cameras.
\par

{\i ESCH_SCENELD_MESHES}\tab Load mesh objects.
\par

{\i ESCH_SCENELD_HIERARCHY}\tab Connect mesh draws using hierarchy info.
\par

{\i ESCH_SCENELD_ALL}\tab\tab Load all items in scene.
\par

{\i ESCH_SCENELD_CAMSEX}\tab Create extended camera instances.
\par

{\i ESCH_SCENELD_NOMFTXT}\tab Prevents multi-frame textures from
 being loaded, using only the first frame as a static texture.
\par

{\i ESCH_SCENELD_NOSHARETXT}\tab Prevents loaded textures from
 being shared via the texture cache.
\par

{\i ESCH_SCENELD_NOFILETXT}\tab Prevents textures from being loaded from
 registered texture files.
\par

{\i ESCH_SCENELD_SKELETON}\tab Loads mesh data as instances of
 {\uldb EschKeyframeDraw}{\v PG_ESCH_KFDRAW}.
\par

\line{\b\fs28 Error Codes}\par

{\i ESCH_ERR_NONE}\tab\tab No error
\par

{\i ESCH_ERR_NOMEMORY}\tab Memory allocation failed.
\par

{\i ESCH_ERR_FILEERROR}\tab File error during load.
\par

{\i ESCH_ERR_NOTFOUND}\tab Object not found.
\par

{\i ESCH_ERR_INVALIDDATA}\tab Data for object invalid.
\par

{\i ESCH_ERR_INVALIDVDATA}\tab Vertex data for object invalid.
\par

{\i ESCH_ERR_INVALIDFDATA}\tab Face data for object invalid.
\par

{\i ESCH_ERR_MISSINGITEMS}\tab Items missing from scene.
\par

{\i ESCH_ERR_NOTSUPPORTED}\tab File contains unsupported data.
\par

{\i ESCH_ERR_MISSINGDATA}\tab Data missing from file.
\par

{\i ESCH_ERR_INVALIDHIER}\tab Hierarchy is invalid.
\par

\pard\page


{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°° Drawable Classes °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschDrawable Class                                                        ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_DRAWABLE}
${\footnote EschDrawable Class}
K{\footnote EschDrawable;
EschDrawable, sibling;
EschDrawable, remove;
EschDrawable, get_type;
EschDrawable, operator =;
EschDrawable, next;
EschDrawable, prev;
EschDrawable, find;
EschDrawable, draw;
EschDrawable, get_extents;
EschDrawable, ray;
EschDrawable, hit;
EschDrawable, pick;
EschDrawable, collide;
EschDrawable, animate;
EschDrawable, set_flags;
EschDrawable, set_limits;
EschDrawable, set_partn_data;
EschDrawable, set_app_data}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschDrawable Class}\par\pard\sb100

This class object is the base abstract class which defines the
 standard interface to drawable objects.  Drawables may be linked
 into lists and told to draw relative to the current drawing
 context.  The drawable is free to use any draw or rendering
 method, but should be sensitive to sort order.
\par

The use of the {\uldb clipdraw}{\v PG_ESCH_CSTYDRAW} routines will ensure
 correct behavior to either use the {\i Van Gogh} viewport Z-buffer or
 place the element into the element arena for draw at the end of the
 frame in correct back-to-front depth order.  When using the Z-buffer,
 any draw order is valid for opaque objects althogh front-to-back is
 generally the fastest since it takes maximum advantage of the Z-buffer,
 but alpha-blended faces must be placed into the element buffer to ensure
 correct blending effects.  When not using the Z-buffer, the draw order
 must be in back-to-front order (.ie., Painter's algorithm).
\par

When drawing directly to a 3D view, bypassing the clipdraw routines, be
 sure to use the clipping and projection logic described in the
 {\uldb camera class}{\v PG_ESCH_CAMERA} if the drawable is expected to
 behave as a 3D object.  This includes supporting both perspective and
 orthongonal projection.
\par

\line{\b\fs28 Name}\par

EschDrawable - Base Draw Object
\par

\line{\b\fs28 Synopsis}\par

#include "esdraw.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b protected EschDrawable(word t);}\par

Initializes the data members to empty values and sets the run-time type
 to the value 't'.  The name is set to point to "NoName".
\par

{\b EschDrawable(const EschDrawable &drw);}\par

Initializes the drawable from another drawable, including
 the run-time type identifier, but not the link pointers.
\par

\line{\b\fs28 Member Data}\par

{\b protected EschDrawable *inext;\line
protected EschDrawable *iprev;}\par

Doubley-linked list of EschDrawables.  Use sibling() and
 remove() to affect these members.
\par

{\b protected word dtyp;}\par

Run-time type identifer for the drawable.  Use get_type() to read this value.
\par

{\b word limits;}\par

Shading limits mask for the drawable.  The camera's flags will be masked
 against this value for determining the availability of the following
 options: \par

{\scaps
{\i ESCH_CAM_SHADE_WIRE}, {\i ESCH_CAM_SHADE_SOLID},
{\i ESCH_CAM_SHADE_FLAT}, {\i ESCH_CAM_SHADE_SMOOTH},
{\i ESCH_CAM_SHADE_SPECULAR}, {\i ESCH_CAM_BACKCULL}, {\i ESCH_CAM_TEXTURED},
{\i ESCH_CAM_PERSPECTIVE}, and {\i ESCH_CAM_SHOW_ALL_LINES}.
}\par

{\cf2
Note:  For drawables using the {\uldb EschFace}{\v PG_ESCH_FACE} class,
 the face's flags will used as an additional mask for these options on a
 per-face basis.
}\par

{\b dword flags;}\par

Control flags (see Flags).  Should be set with set_flags().
\par

{\b char *name;}\par

Pointer to name of drawable, if any.
\par

{\b void *partn_data;}\par

Partitioning pointer used by
 {\uldb EschPartition}{\v PG_ESCH_PARTITION}-derived class implementations.
 Should be set with set_partn_data().
\par

{\b void *app_data;}\par

Pointer to application data, if any. This pointer is for use by the
 application for whatever data might need to be associated
 with a drawable.  It defaults to 0.  Should be set with set_app_data().
\par

\line{\b\fs28 Member Functions}\par

{\b word get_type() const;}\par

Returns the run-time type of the drawable (See Drawable Types).
\par

{\b const EschDrawable &operator = (const EschDrawable &drw);}\par

Copies the data from another drawable, but does not copy the linked-list
 pointers or run-time type value and clears the owns bits of the target.
\par

{\b EschDrawable *next() const;\line
EschDrawable *prev() const;}\par

Returns the value in the protected inext/iprev members for
 walking the list of drawable objects.
\par

{\b virtual void sibling(EschDrawable *myprev);}\par

Attaches the object into a linked-list containing myprev.  This
 assumes that the class instance is not currently attached into
 any list.
\par

{\b virtual void remove();}\par

Removes the drawable from the list it is linked into, if any.
\par

{\b virtual EschDrawable *find(const char *name) const;}\par

Searches the linked-list of drawables attached to the object for
 the given name.  Returns a pointer to the found drawable or 0 if
 not found.
\par

{\b virtual void draw();}\par

Abstract member for informing object to draw.  This routine is
 overloaded by the various derived class objects.
\par

{\b virtual int get_extents(EschSphereExtents *sp);}\par

Sets sp to have the drawable's spherical extent and returns 0, or
 returns -1 if not supported for the drawable.  The base member returns -1.
\par

{\b virtual float ray(const EschPoint *pt, const EschVector *v, int coarse=0);}\par

Performs a ray (start at pt, and doing in the direction of v) intersection
 test with the drawable's extents.  If coarse is set, then only a 'coarse'
 or fast test should be performed, if possible.  The distance along the ray
 of the intersection is returned, 0 if not hit, or -1 if not supported.  The
 base member performs a ray/sphere intersection against the results of
 get_extents, or -1 if get_extents is not supported.
\par

{\b virtual int hit(const EschPoint *pt, const float r, int coarse=0);}\par

Performs a sphere (center of pt and radius of r) intersection test with
 the drawable's extents.  It returns 1 if hit, 0 if not hit, or -1 if
 not supported.  The base member returns -1.  If coarse is set, then
 only a 'coarse' test should be performed, if possible.
\par

{\b virtual esch_error_codes pick(EschPicking *data);}\par

Performs a picking operation, testing a list of drawables for a ray
 intersection.  See the {\uldb EschPicking}{\v PG_ESCH_PICKING}
 commmunication interface structure for details and {\b Error Codes}
 for result values.
\par

{\b virtual esch_error_codes collide(EschCollide *data);}\par

Performs a collision detection operation, testing a list of drawables for
 a hit with the current drawable instance (or optionally, an arbitrary
 spherical extent).  See the {\uldb EschCollision}{\v PG_ESCH_COLLISION}
 commmunication interface structure for details and {\b Error Codes}
 for result values.
\par

{\b virtual void animate()}\par

Performs any per-frame changes to the drawable needed for animation.  This
 should be called by the application for each drawable that needs an
 animation callback.  The base implementation does nothing on this call.
\par

{\scaps\cf4 NEW}\line
{\b void set_flags(const dword f);\line
void set_flags(const dword m, const int on);}\par

Sets the control flags.
\par

{\scaps\cf4 NEW}\line
{\b void set_limits(const word f);\line
void set_limits(const word m, const in on);}\par

Sets the shading limits mask.
\par

{\b void set_partn_data(void *p)}\par

This sets the partitioning pointer to the given value.
\par

{\b void set_app_data(void *p)}\par

This sets the application data pointer to the given value.
\par

\line{\b\fs28 Drawable Types}\par

Since drawables are often kept in lists, it is sometimes necessary to
 determine if a given instance can be cast to a derived type.
\par

{\i ESCH_DRWT_BASE}\tab Drawable has no type (should never occurr).
\par

{\i ESCH_DRWT_POINTDRAW}\tab Drawable is an
{\uldb EschPointDraw}{\v PG_ESCH_POINTDRAW}.
\par

{\i ESCH_DRWT_PARTICLE}\tab Drawable is an
 {\uldb EschParticle}{\v PG_ESCH_PARTICLE}.
\par

{\i ESCH_DRWT_PRTPYRAMID}\tab Drawable is an
 {\uldb EschParticlePyramid}{\v PG_ESCH_PARTICLEPYR}.
\par

{\i ESCH_DRWT_PRTGEOMETRY}\tab Drawable is an
 {\uldb EschParticleGeometry}{\v PG_ESCH_PARTICLEGEOM}.
\par

{\i ESCH_DRWT_PRTSPRITE}\tab Drawable is an
 {\uldb EschParticleSprite}{\v PG_ESCH_PARTICLESPR}.
\par

{\i ESCH_DRWT_PRTLIN}\tab Drawable is an
 {\uldb EschParticleLine}{\v PG_ESCH_PARTICLELINE}.
\par

{\i ESCH_DRWT_PSYSTEM}\tab Drawable is an
 {\uldb EschParticleSystem}{\v PG_ESCH_PARTICLESYS}.
\par

{\i ESCH_DRWT_PGENERATOR}\tab Drawable is an
 {\uldb EschParticleGenerator}{\v PG_ESCH_PARTICLEGEN}.
\par

{\i ESCH_DRWT_GEOM}\tab\tab Drawable is an
 {\uldb EschGeometry}{\v PG_ESCH_GEOMETRY}.
\par

{\i ESCH_DRWT_MESH}\tab\tab Drawable is an
 {\uldb EschMeshDraw}{\v PG_ESCH_MESHDRAW}.
\par

{\i ESCH_DRWT_TERRAIN}\tab Drawable is an
 {\uldb EschTerrain}{\v PG_ESCH_TERRAIN}.
\par

{\i ESCH_DRWT_SPRITE}\tab\tab Drawable is an
 {\uldb EschSprite}{\v PG_ESCH_SPRITE}.
\par

{\i ESCH_DRWT_PARTITION}\tab Drawable is an
 {\uldb EschPartition}{\v PG_ESCH_PARTITION}.
\par

{\i ESCH_DRWT_PRTN_GRID}\tab Drawable is an
 {\uldb EschGridPartition}{\v PG_ESCH_GRIDPARTITION}.
\par

{\i ESCH_DRWT_PRTN_QUAD}\tab Drawable is an
 {\uldb EschQuadTreePartition}{\v PG_ESCH_QUADTREEPARTITION}.
\par

{\i ESCH_DRWT_PRTN_OCT}\tab Drawable is an
 {\uldb EschOctTreePartition}{\v PG_ESCH_OCTTREEPARTITION}.
\par

{\i ESCH_DRWT_LINEDRAW}\tab Drawable is an
{\uldb EschLineDraw}{\v PG_ESCH_LINEDRAW}.
\par

{\scaps\cf4 NEW}\line
{\i ESCH_DRWT_PLANEDRAW}\tab Drawable is an
{\uldb EschPlaneDraw}{\v PG_ESCH_PLANEDRAW}.
\par

{\i ESCH_DRWT_STARFIELD}\tab Drawable is an
 {\uldb EschStarfield}{\v PG_ESCH_STARFIELD}.
\par

{\i ESCH_DRWT_EXPLOSION}\tab Drawable is an
 {\uldb EschPlosion}{\v PG_ESCH_PLOSION}.
\par

{\i ESCH_DRWT_METABOX}\tab Drawable is an
 {\uldb EschMetabox}{\v PG_ESCH_METABOX}.
\par

{\i ESCH_DRWT_LOD}\tab\tab Drawable is an
 {\uldb EschLevelOfDetail}{\v PG_ESCH_LOD}.
\par

{\i ESCH_DRWT_SKELETON}\tab Drawable is a
 {\uldb EschKeyframeDraw}{\v PG_ESCH_KFDRAW}.
\par

\line{\b\fs28 Flags}\par

Since the flags variable is shared by derived classes, care must
 be taken to ensure that the bit definitions do not conflict.
 All definitions can be found in esdefs.h/esdefs.inc.
\par

{\i ESCH_DRW_SKIP}\tab If this bit is set, the drawable instance should
 be skipped during any render operation.
\par

{\i ESCH_DRW_SKIPTEST}\tab If this bit is set, the drawable instance should
 be skipped during any picking/collision operations.
\par

{\i ESCH_DRW_OWNSDATA}\tab This indicates that any data buffers pointed
 to by the drawable should be deleted by the destructor.
\par

{\i ESCH_DRW_SKIPANIMATE}\tab If this bit is set, the drawable instance
 should be skipped during any animate operation.
\par

{\i ESCH_DRW_SKIPTRAVERSE}\tab If this bit is set, the drawable instance
 should be skipped during a partition traverse operation.
\par

{\i ESCH_DRW_VISIBILE}\tab Set when a drawable is determined to be
 visible.  It should be cleared by the application before a render pass
 if visible/invisible information is needed.
\par

{\i ESCH_DRW_PARTNSTATIC}\tab If this bit is set,
 {\uldb EschPartition}{\v PG_ESCH_PARTITION}-dervied classes will not
 perform any processing on an update(0) for this drawable.  It should be
 set for drawables that don't move.
\par

{\i ESCH_DRW_APP0} -\line
{\i ESCH_DRW_APP7}\tab Reserved for use by the
application.
\par

\line{\b\fs28 Error Codes}\par

{\i ESCH_ERR_NONE}\tab\tab No error
\par

{\i ESCH_ERR_NOMEMORY}\tab Memory allocation failed.
\par

{\i ESCH_ERR_INVALIDPARMS}\tab Input data was invalid.
\par

{\i ESCH_ERR_NOTSUPPORTED}\tab Operation not supported.
\par

{\i ESCH_ERR_NEEDILIST}\tab Input list was empty.
\par

{\i ESCH_ERR_NEEDARENA}\tab No valid arena given for results.
\par

{\i ESCH_ERR_CAMERA}\tab\tab Picking from a viewport needs a camera.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschPointDraw Class                                                       ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_POINTDRAW}
${\footnote EschPointDraw Class}
K{\footnote EschPointDraw;
EschPointDraw, draw;
EschPointDraw, set_position;
EschPointDraw, set_color}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschPointDraw Class}\par\pard\sb100

A single colored point is the most basic of 3D drawable items.  This
 class provides a drawable for displaying a single point.  Lighting has
 no effect on the point's color.
\par

{\cf3 {\i Van Gogh} does not have a perspective version of pixel, so
 {\i ESCH_CAM_PERSPECTIVE} currently has no effect for points.}\par

\line{\b\fs28 Name}\par

EschPointDraw - 3D Point Drawable
\par

\line{\b\fs28 Synopsis}\par

#include "esbasic.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschPointDraw();}\par

Performs no initialization.
\par

{\b EschPointDraw(float ix, float iy, float iz, dword c);}\par

Initializes the class with the given values.
\par

{\b EschPointDraw(const EschPoint *p, dword c);}\par

Initializes the class with the given point and value.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b EschPoint pos;}\par

Position of the point in 3-space.  Should be set by set_position().
\par

{\b dword color;}\par

Color of the point ({\i Van Gogh} color format).  Should be set
 by set_color().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b virtual void draw();}\par

Draws the point using the current context.
\par

{\b void set_position(float ix, float iy, float iz);\line
void set_position(const EschPoint *pnt);}\par

Sets the position of the point.
\par

{\b void set_color(dword c);}\par

Sets the color of the point.
\par

\line{\b\fs28 Example}\par

The following example demonstrates drawing a single pixel in 3D:
\par

{\f2
EschCamera Camera;
\par
EschPointDraw pnt(10,10,10,2);
\par
// Render using an EschCamera
\par
Camera.render(&pnt);
\par
}\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschLineDraw Class                                                        ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_LINEDRAW}
${\footnote EschLineDraw Class}
K{\footnote EschLineDraw;
EschLineDraw, draw;
EschLineDraw, set_position;
EschLineDraw, set_color}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschLineDraw Class}\par\pard\sb100

A colored line in 3-space is displayed by this class.  Lighting has no
 effect on the color of the line.
\par

{\cf3 {\i Van Gogh} does not have a perspective version of line, so
 {\i ESCH_CAM_PERSPECTIVE} currently has no effect for lines.}\par

\line{\b\fs28 Name}\par

EschLineDraw - 3D Line Drawable
\par

\line{\b\fs28 Synopsis}\par

#include "esbasic.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschLineDraw();}\par

Performs no initialization.
\par

{\b EschLineDraw(float ix1, float iy1, float iz1,
 float ix2, float iy2, float iz2, dword c);}\par

Initializes the class with the given values.
\par

{\b EschLineDraw(const EschLine *p1, const EschLine *p2, dword c);}\par

Initializes the class with the given points and color value.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b EschPoint pos1, pos2;}\par

Position of the end-points  in 3-space.  Should be set by set_position().
\par

{\b dword color;}\par

Color of the point ({\i Van Gogh} color format).  Should be set
 by set_color().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b virtual void draw();}\par

Draws the line using the current context.
\par

{\b void set_position(float ix1, float iy1, float iz1,
 float ix1, float iy1, float iz1);\line
void set_position(const EschPoint *pnt1, const EschPoint *pnt2);}\par

Sets the position of the line's endpoints.
\par

{\b void set_color(dword c);}\par

Sets the color of the point.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschPlaneDraw Class                                                       ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PLANEDRAW}
${\footnote EschPlaneDraw Class}
K{\footnote EschPlaneDraw;
EschPlaneDraw, operator =;
EschPlaneDraw, draw;
EschPlaneDraw, ray;
EschPlaneDraw, hit;
EschPlaneDraw, animate;
EschPlaneDraw, release;
EschPlaneDraw, set_plane;
EschPlaneDraw, set_mapping;
EschPlaneDraw, set_uvstep;
EschPlaneDraw, rotatex;
EschPlaneDraw, rotatey;
EschPlaneDraw, rotatez;
EschPlaneDraw, set_color;
EschPlaneDraw, get_alpha;
EschPlaneDraw, set_alpha;
EschPlaneDraw, set_texture}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschPlaneDraw Class}\par\pard\sb100

{\scaps\cf4 NEW}\line
A colored infinite plane in 3-space with lighting and optional texturing
 is displayed by this class.  By default it is back-culled so it will only
 have one side.  To display this as a two-sided plane, clear the limits
 flag of the {\i ESCH_CAM_BACKCULL} flag.
\par

\line{\b\fs28 Name}\par

EschPlaneDraw - 3D Plane Drawable
\par

\line{\b\fs28 Synopsis}\par

#include "esbasic.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschPlaneDraw();}\par

Initializes the drawable, but not the plane or color values.
\par

{\b EschPlaneDraw(float ia, float ib, float ic, float id, dword c);\line
EschPlaneDraw(float ia, float ib, float ic,
 float ix, float iy, float iz, dword c);\line
EschPlaneDraw(const EschVector &in, float id, dword c);\line
EschPlaneDraw(const EschPlane *pl, dword c);\line
EschPlaneDraw(const EschVector &v1, const EschVector &v2,
 const EschPoint &pos, dword c, float us=100, float vs=100);}\par

Initializes the class with the given data.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b protected long alpha_level;}\par

Alpha value for plane with 0 for transparent and 255 for fully opaque.
\par

{\b EschPlane plane;}\par

Definition of plane to draw.  Should be set with set_plane().
\par

{\b dword color;}\par

Color of the point ({\i Van Gogh} color format).  Should be set
 by set_color().
\par

{\b EschTexture *txt;}\par

Pointer to optional tetxure for plane.  If {\i ESCH_DRW_OWNSDATA} is set, this
 is freed by release().  Should be set with set_texture();
\par

{\b EschVector uvec;\line
EschVector vvec;}\par

These vectors specifiy the mapping coordinates for textures.  The U and
 V parameters of the plane are derived by projecting onto the U and V
 vectors given.  These vectors must be normalized.
\par

{\b EschPoint uvpos;}\par

This point is the anchor point for the U, V tiling and should lie in the
 plane defined by uvec, vvec.
\par

{\b float ustep;\line
float vstep;}\par

These define the number of view coordinates per U, V step (should be
 set with set_mapping() or set_uvstep()).\par

{\cf2
Note:  {\i Van Gogh} can only support a certain range of U, V values for
 tiling so this drawable normalizes the UVs computed to make this range as
 large as possible for the given view.  Unfortunatly, there are combinations
 of viewing volumes and UV step values that will result in invalid UV values.
 If this occurrs, you have too many tiles and must increase u/vstep or
 decrease the size of your view volume.
}\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b const EschPlaneDraw &operator = (const EschPlaneDraw &s);}\par

Copies the data from another plane drawable, but does not copy the linked-list
 pointers or run-time type value and clears the owns bit of the
 target.  Any previously owned data is freed.
\par

{\b virtual void draw();}\par

Draws the line using the current context.
\par

{\b virtual float ray(const EschPoint *pt, const EschVector *v, int coarse=0);}\par

Performs a ray/plane intersection test, returning -1 if it missed or the
 distance along the ray it hit the plane.
\par

{\b virtual int hit(const EschPoint *pt, const float r, int coarse=0);}\par

Performs a sphere/plane interseciton test, returning 1 if it hit, 0 otherwise.
\par

{\b virtual void animate();}\par

Animates the texture if {\i ESCH_TXT_SKIPANIMATE} is not set.
\par

{\b virtual void release();}\par

Frees the texture if {\i ESCH_DRW_OWNSDATA} is set.  Called by the
 destructor.
\par

{\b void set_plane(const EschPlane &pln);\line
void set_plane(float ia, float ib, float ic, float id);\line
void set_plane(float ia, float ib, float ic, float ix, float iy, float iz);}\par

Sets the 'plane' member, but does not update the texture mapping coordinates.
\par

{\b void set_plane(const EschVector &v1, const EschVector &v2, const EschPoint &pos);}\par

Sets the 'plane' member and the texture mapping coordinates based on the UV
 vectors (v1 and v2) and the normal computed by the cross-product of v1 & v2.
 The anchor point is given as pos and provides the point-on-plane definition
 needed to complete the definition of a plane.
\par

{\b void set_mapping(const EschVector &_uvec, const EschVector &_vvec,
 const EschPoint &_uvpos, float us, float vs);}\par

Sets the texture mapping parameters without affecting the plane.
\par

{\b void set_uvstep(float us, float vs);}\par

Sets the texture mapping U/V step parameters which controls the tile-rate
 of the texture.
\par

{\b void rotatex(const float d);\line
void rotatey(const float d);\line
void rotatez(const float d);}\par

Rotates the plane's normal in world X, Y, or Z coordinates and the u/v vectors.
\par

{\cf2
Note:  After many updates to the vectors, they should be re-normalized.
}\par

{\b void normalize();}\par

Normalizes the plane and the u/v vectors.
\par

{\b void set_color(dword c);}\par

Sets the color of the point.
\par

{\b void set_alpha(long alpha);\line
long get_alpha();}\par

Sets/gets the alpha_level value where 0 is transparent and 255 is opaque.
\par

{\b void set_texture(EschTexture *t);}\par

Sets the 'txt' member to the given texture.  If {\i ESCH_DRW_OWNSDATA} is set,
 then this pointer will be freed on the next call to set_texture() or to
 release().
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschSprite Class                                                          ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_SPRITE}
${\footnote EschSprite Class}
K{\footnote EschSprite;
EschSprite, operator =;
EschSprite, draw;
EschSprite, get_extents;
EschSprite, animate;
EschSprite, release;
EschSprite, set_position;
EschSprite, set_size;
EschSprite, set_rotation;
EschSprite, set_scale;
EschSprite, set_alpha;
EschSprite, get_alpha;
EschSprite, attach;
EschSprite, create}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschSprite Class}\par\pard\sb100

A sprite is a 2D bitmap which is represented in 3-space as a single point.
 The bitmap is drawn facing the viewer regardless of the view direction.
 Lighting in the scene will affect the sprite if {\i ESCH_CAM_SHADE_FLAT}
 is set.
\par

{\cf2
Note:  Since the sprite is drawn using {\i Van Gogh}'s texture routines,
 the sprite bitmap must conform the the limitations for textures (the
 create() routine will do bit-depth conversions using VngoTexture's
 convert() routine, but the image must have dimensions that are powers
 of 2 between 16 and 256).
}\par

Optionally, the sprite may be treated as an 'infinite' object.  It will
 be drawn as normal, but will not be clipped by the yon plane and will
 always be drawn at maximum Z-buffer distance.  In addition, an 'infinite'
 sprite is never affected by lighting.
\par

{\cf2
Note:  This is similiar to the {\uldb starfield}{\v PG_ESCH_STARFIELD}
 drawable and is useful for 'fixed' objects in the universe like planets,
 the sun, and the moon.
}\par

\line{\b\fs28 Name}\par

EschSprite - 2D Bitmap Sprite
\par

\line{\b\fs28 Synopsis}\par

#include "esbasic.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschSprite();}\par

Intializes the drawable, but not the position or size of the sprite.
\par

{\b EschSprite(float ix, float iy, float iz, float w, float h,
 float r=0, float s=1);\line
EschSprite(const EschPoint *p, float w, float h,
 float r=0, float s=1);}\par

Initializes the position and size of the sprite and optionally the rotation
 and scale factor.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b protected EschTexture *txt;}\par

Internal pointer to sprite texture.
\par

{\b protected long alpha_level;}\par

Alpha value for sprite with 0 for transparent and 255 for fully opaque.
\par

{\b EschPoint pos;}\par

Center position of the sprite in 3-space.  Should be set by set_position().
\par

{\b float width, height;}\par

Size of sprite in world coordinates.  Should be set by set_size().
\par

{\b float rotation;}\par

Rotation of the sprite in degrees.  Should be set by set_rotation().
\par

{\b float scale;}\par

Scale factor for the sprite.  Should be set by set_scale().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b const EschSprite &operator = (const EschSprite &s);}\par

Copies the data from another sprite, but does not copy the linked-list
 pointers or run-time type value and clears the owns bit of the
 target.  Any previously owned data is freed.
\par

{\b virtual void draw();}\par

Draws the sprite using the current context.
\par

{\b virtual int get_extents(EschSphereExtents *sp) const;}\par

Returns a spherical extent for the sprite.  Therefore, sprites can
 tested against using the base 'ray' and 'hit' members of EschDrawable.
\par

{\b virtual void animate();}\par

This implementation calls animate() for the texture pointed to by 'txt'.
 This should be called by the application.
\par

{\b virtual void release();}\par

Deletes the assocaited texture if {\t ESCH_DRW_OWNSDATA} is set.
\par

{\b void set_position(float ix, float iy, float iz);\line
void set_position(const EschPoint *pnt);}\par

Sets the center position of the sprite.
\par

{\b void set_rotation(float r);}\par

Sets the rotation for sprite.
\par

{\b void set_scale(float s);}\par

Sets the scale factor for the sprite.
\par

{\b void set_size(float w, float h);}\par

Sets the width and height of the sprite in world coordinates.
\par

{\b void set_alpha(long alpha);\line
long get_alpha();}\par

Sets/gets the alpha_level value where 0 is transparent and 255 is opaque.
\par

{\b void attach(EschTexture *t);}\par

This releases the current 'txt' pointer and then points to the new
 texture.
\par

{\b esch_error_codes create(XFBitmap *bm, float w, float h,
 int trans=1, VngoPal *pal=0);}\par

This creates a static texture (owned by the drawable) from a
 bitmap and sets the world width and height values.  The bm, trans, and
 pal data is passed onto the texture's create member.
\par

\line{\b\fs28 Example}\par

{\i ESCH_SPRITE_INFINITE}  Sprite is drawn as if it was infinitly far
 from the viewer.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschParticle Class                                                        ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PARTICLE}
${\footnote EschParticle Class}
K{\footnote EschParticle;
EschParticle, draw;
EschParticle, animate;
EschParticle, set_interval;
EschParticle, set_position;
EschParticle, set_color;
EschParticle, set_lifetime;
EschParticle, set_velocity;
EschParticle, set_acceleration}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschParticle Class}\par\pard\sb100

{\scaps\cf4 CHANGED}\line
A particle is a dynamic 3D object which moves through 3-space by the
 application of an acceleration and a velocity.  This class is used to
 implement particle systems, which are useful for a number of
 special effects.
\par

{\cf3 {\i Van Gogh} does not have a perspective version of pixel, so
 {\i ESCH_CAM_PERSPECTIVE} currently has no effect for particles.}\par

\line{\b\fs28 Name}\par

EschParticle - Dynamic 3D Point
\par

\line{\b\fs28 Synopsis}\par

#include "espartik.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschParticle();}\par

Performs no initialization.
\par

{\b EschParticle(float ix, float iy, float iz,
 float ii, float ij, float ik, dword c, float l=0);}\par

Initializes the particle with the given values for position,
 color, and lifetime.  Acceleration and velocity are set to 0,0,0.
\par

{\b EschParticle(float ix, float iy, float iz,
 float ii, float ij, float ik, dword c, float l=0);}\par

Initializes the particle with the given values for position,
 velocity, color, and lifetime.  Acceleration is set to 0,0,0.
\par

{\b EschParticle(const EschPoint *p, const EschVector *v,
 dword c, float l=0);}\par

Initializes the particle with the given values for position,
 velocity, color, and lifetime.  Acceleration is set to 0,0,0.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b protected float interval;}\par

Time interval to apply to the physics model on the animate() call.
 This is set by the set_interval() routine.
\par

{\b EschPoint pos;}\par

Position of the particle in 3-space.  Should be set by set_position().
\par

{\b dword color;}\par

Color of the particle ({\i Van Gogh} color format).  Should be set
 by set_color().
\par

{\b float life;}\par

Lifetime left for the particle (in frames by default, but in time based
 on the interval if {\i ESCH_PRT_TIMEBASED} is set).  0 indicates unlimited
 lifetime.  Should be set by set_lifetime().
\par

{\b EschVector velocity;}\par

Current velocity of the particle.  Should be set by set_velocity().
\par

{\b EschVector acceleration;}\par

Accleration of the particle.  Should be set by set_acceleration().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b virtual void draw();}\par

Draws the particle at its current position.  The base implementation
 draws a single colored point.
\par

{\b virtual void animate();}\par

Performs any computations needed to get the next frame.  The
 standard action is to decrease the lifetime (setting the
 {\i ESCH_DRW_SKIP} flag when the lifetime reaches zero) and
 to apply the current acceleration and velocity to the particle.
 A valid interval should be provided for this to operate correctly.
\par

{\b void set_interval(float i); }\par

Sets the time interval for the animate() routine.  The application
 can set this once for a fixed-interval between frames, or it can
 set it each frame to handle variable-interval times.
\par

{\b void set_position(float ix, float iy, float iz);\line
void set_position(const EschPoint *pnt);}\par

Sets the position of the particle.
\par

{\b void set_color();}\par

Sets the color of the particle.
\par

{\b void set_velocity(float ii, float ij, float ik);\line
void set_velocity(const EschVector *v);}\par

Sets the velocity of the particle.
\par

{\b void set_lifetime(float l);}\par

Sets the lifetime of the particle.
\par

{\b void set_acceleration(float ii, float ij, float ik);\line
void set_acceleration(const EschVector *v);}\par

Sets the acceleration of the particle.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_PRT_TIMEBASED}\tab Indicates lifetime is based on interval, not
 frame count.
\par

{\scaps\cf4 NEW}\line
{\i ESCH_PRT_CULLIFOUTOFVIEW}\tab Indicates that the particle should be
 killed if it goes into view and then becomes invisible--useful for when
 the particle is a purely visual effect and consitency from camera to
 camera is not required.
\par

{\scaps\cf4 NEW}\line
{\i ESCH_PRT_WASVISIBLE}\tab Used to implement the above culling.  This is
 set to true if the particle had ESCH_DRW_VISIBLE set at some point during
 it's lifetime.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschParticleLine Class                                                    ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PARTICLELINE}
${\footnote EschParticleLine Class}
K{\footnote EschParticleLine;
EschParticle, draw;
EschParticle, animate;
EschParticle, set_position}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschParticleLine Class}\par\pard\sb100

This particle draws a 3D line between the last position and the new position
 of the particle in 3-space which creates colored streaks.
\par

\line{\b\fs28 Name}\par

EschParticleLine - Dynamic 3D Line
\par

\line{\b\fs28 Synopsis}\par

#include "espartik.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschParticle}{\v PG_ESCH_PARTICLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschParticleLine();}\par

Performs no initialization.
\par

{\b EschParticleLine(float ix, float iy, float iz,
 float ii, float ij, float ik, dword c, float l=0);}\par

Initializes the particle with the given values for position,
 color, and lifetime.  Acceleration and velocity are set to 0,0,0.
\par

{\b EschParticleLine(float ix, float iy, float iz,
 float ii, float ij, float ik, dword c, float l=0);}\par

Initializes the particle with the given values for position,
 velocity, color, and lifetime.  Acceleration is set to 0,0,0.
\par

{\b EschParticleLine(const EschPoint *p, const EschVector *v,
 dword c, float l=0);}\par

Initializes the particle with the given values for position,
 velocity, color, and lifetime.  Acceleration is set to 0,0,0.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschParticle}{\v PG_ESCH_PARTICLE} plus :-
\par

{\b EschPoint pos2;}\par

Last position of the particle in 3-space.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschParticle}{\v PG_ESCH_PARTICLE}, plus :-
\par

{\b void set_position(float ix, float iy, float iz);\line
void set_position(const EschPoint *pnt);}\par

Sets the position of the particle.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschParticlePyramid Class                                                 ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PARTICLEPYR}
${\footnote EschParticlePyramid Class}
K{\footnote EschParticlePyramid;
EschParticlePyramid, draw;
EschParticlePyramid, animate;
EschParticlePyramid, set_position;
EschParticlePryamid, set_lifetime;
EschParticlePyramid, set_size;
EschParticlePyramid, set_rotate_i;
EschParticlePyramid, set_rotate_j;
EschParticlePyramid, set_rotate_k;
EschParticlePyramid, set_alpha;
EschParticlePyramid, reset}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschParticlePyramid Class}\par\pard\sb100

This is an extended particle that draws itself as a 4-sided pyramid polygonal
 mesh.  The size of the pyramid may be set to any desired value.  The pyramid
 may be set to rotate about its local I, J, and/or K axis, in addition
 to the standard particle motion.  It will also decay its alpha value if
 the drawable limits include {\i ESCH_FACE_ALPHA}.
\par

\line{\b\fs28 Name}\par

EschParticlePyramid - Dynamic 3D Pyramid
\par

\line{\b\fs28 Synopsis}\par

#include "espartik.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschParticle}{\v PG_ESCH_PARTICLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschParticlePyramid();}\par

Performs no initialization.
\par

{\b EschParticlePyramid(float s, float ix, float iy, float iz,
 dword c, float l=0);}\par

Initializes the particle with the given values for size, position,
 color, and lifetime.  Acceleration and velocity are set to 0,0,0.
\par

{\b EschParticlePyramid(float s, float ix, float iy, float iz,
 float ii, float ij, float ik, dword c, float l=0);}\par

Initializes the particle with the given values for size, position,
 velocity, color, and lifetime.  Acceleration is set to 0,0,0.
\par

{\b EschParticlePyramid(float s, const EschPoint *p, const EschVector
 *v, dword c, float l=0);}\par

Initializes the particle with the given values for size, position,
 velocity, color, and lifetime.  Acceleration is set to 0,0,0.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschParticle}{\v PG_ESCH_PARTICLE} plus :-
\par

{\b EschFrameRef world;}\par

Frame-of-reference for controlling the orientation of the pyramid
 which is defined internally in local coordinates.
\par

{\b float size;}\par

Size of the pyramid.  The points of the pyramid are half of this size
 from the center of the coordinate system.  Should be set with set_size().
\par

{\b float rotate_i;\line
float rotate_j;\line
float rotate_k;}\par

Rotation rates for the pyramid in degrees per interval.  Should be set
 with the set_rotate_() calls.
\par

{\b float alpha;}\par

Alpha-level for pyramid.  Should be set by set_alpha().
\par

{\b float alpha_rate;}\par

Decay rate for the alpha value.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschParticle}{\v PG_ESCH_PARTICLE} plus :-
\par

{\b virtual void draw();}\par

Draws the particle at its current position.
\par

{\b virtual void animate();}\par

Performs the standard particle animation processing, plus updating the
 frame of reference for the position changes and the rotation changes.
\par

{\b void set_position(float ix, float iy, float iz);\line
void set_position(const EschPoint *pnt);}\par

Sets the position of the particle, updating the frame-of-reference.
\par

{\b void set_lifetime(float l);}\par

Sets the lifetime of the particle and sets the alpha rate to decay from
 opaque (255) to transparent (0) over the lifetime.  Set the limits of
 the particle drawable to not include {\i ESCH_FACE_ALPHA} if this effect is
 not desired.
\par

{\b void set_size(float s);}\par

Sets the size of the pyramid.
\par

{\b void set_rotate_i(float r);\line
void set_rotate_j(float r);\line
void set_rotate_k(float r);}\par

Sets the rate of rotation.  The rate may be either postive or negative
 to control rotation direction.
\par

{\b void set_alpha(byte a);}\par

Sets the alpha level of the pyramid (255 for opaque, 0 for transparent).
\par

{\b reset();}\par

Resets the frame-of-reference to the default orientation.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschParticleGeometry Class                                                ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PARTICLEGEOM}
${\footnote EschParticleGeometry Class}
K{\footnote EschParticleGeometry;
EschParticleGeometry, operator =;
EschParticleGeometry, draw;
EschParticleGeometry, animate;
EschParticleGeometry, set_position;
EschParticleGeometry, set_rotate_i;
EschParticleGeometry, set_rotate_j;
EschParticleGeometry, set_rotate_k;
EschParticleGeometry, reset}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschParticleGeometry Class}\par\pard\sb100

This is an extended particle that draws an
 {\uldb EschGeometry}{\v PG_ESCH_GEOMETRY} instance as the particle.  The
 geometry may be set to rotate about its local I, J, and/or K axis, in
 addition to the standard particle motion.
\par

\line{\b\fs28 Name}\par

EschParticleGeometry - Dynamic 3D Geometry
\par

\line{\b\fs28 Synopsis}\par

#include "espartik.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschParticle}{\v PG_ESCH_PARTICLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschParticleGeometry();}\par

Clears the geometry pointer.
\par

{\b EschParticleGeometry(EschGeometry *g, float l=0);}\par

Initializes the particle with the given geometry instance, using the
 geometry's location as the initial position, and uses the given
 value for lifetime.  Acceleration and velocity are set to 0,0,0.
\par

{\b EschParticleGeometry(EschGeometry *g, float ii, float ij,
 float ik, float l=0);}\par

Initializes the particle with the given geometry instance, using
 the geometry's location as the initial position, and uses the
 given values for velocity and lifetime.  Acceleration is set to 0,0,0.
\par

{\b EschParticleGeometry(EschGeometry *g, const EschVector
 *v, float l=0);}\par

Initializes the particle with the given geometry instance, using
 the geometry's location as the initial position, and uses the
 given values for velocity and lifetime.  Acceleration is set to 0,0,0.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschParticle}{\v PG_ESCH_PARTICLE} plus :-
\par

{\b protected EschGeometry *geom;}\par

Pointer to geometry instance.
\par

{\b float rotate_i;\line
float rotate_j;\line
float rotate_k;}\par

Rotation rates for the geometry in degrees per interval.  Should be set
 with the set_rotate_() calls.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschParticle}{\v PG_ESCH_PARTICLE} plus :-
\par

{\b const EschParticleGeometry &operator = (const EschParticleGeometry &pg);}\par

Copies the data from another particle geometry, but does not copy the
 linked-list pointers or run-time type value and clears the owns bits of
 the target.  Any previously owned data is freed.
\par

{\b virtual void draw();}\par

Draws the particle at its current position.
\par

{\b virtual void animate();}\par

Performs the standard particle animation processing, plus updating the
 geometry's frame of reference for the position changes and the rotation
 changes.
\par

{\b void set_position(float ix, float iy, float iz);\line
void set_position(const EschPoint *pnt);}\par

Sets the position of the particle, updating the geometry's frame-of-reference.
\par

{\b void set_rotate_i(float r);\line
void set_rotate_j(float r);\line
void set_rotate_k(float r);}\par

Sets the rate of rotation.  The rate may be either postive or negative
 to control rotation direction.
\par

{\b reset();}\par

Resets the geometry's frame-of-reference to the default orientation.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschParticleSprite Class                                                  ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PARTICLESPR}
${\footnote EschParticleSprite Class}
K{\footnote EschParticleSprite;
EschParticleSprite, operator =;
EschParticleSprite, draw;
EschParticleSprite, animate;
EschParticleSprite, release;
EschParticleSprite, set_position;
EschParticleSprite, set_lifetime;
EschParticleSprite, set_rot_rate;
EschParticleSprite, set_rotation;
EschParticleSprite, set_scale_rate;
EschParticleSprite, set_scale}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschParticleSprite Class}\par\pard\sb100

This is an extended particle that draws an
 {\uldb EschSprite}{\v PG_ESCH_SPRITE} instance as the particle.  The alpha
 level of the sprite may be changed with the lifetime of the particle as
 well as the rotation and scale factor.
\par

\line{\b\fs28 Name}\par

EschParticleSprite - Dynamic sprite
\par

\line{\b\fs28 Synopsis}\par

#include "espartik.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschParticle}{\v PG_ESCH_PARTICLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschParticleSprite();}\par

Clears the sprite pointer.
\par

{\b EschParticleSprite(EschSprite *s, float l=0);}\par

Initializes the particle with the given sprite instance, using the
 sprite's location as the initial position, and uses the given
 value for lifetime.  Acceleration and velocity are set to 0,0,0.
\par

{\b EschParticleSprite(EschSprite *s, float ii, float ij,
 float ik, float l=0);}\par

Initializes the particle with the given sprite instance, using
 the sprite's location as the initial position, and uses the
 given values for velocity and lifetime.  Acceleration is set to 0,0,0.
\par

{\b EschParticleSprite(EschSprite *s, const EschVector
 *v, float l=0);}\par

Initializes the particle with the given sprite instance, using
 the sprite's location as the initial position, and uses the
 given values for velocity and lifetime.  Acceleration is set to 0,0,0.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschParticle}{\v PG_ESCH_PARTICLE} plus :-
\par

{\b protected EschSprite *sprite;}\par

Pointer to sprite instance.
\par

{\b float alpha;\line
float alpha_rate;}\par

Current alpha level and alpha rate for dynamic adjustment of alpha level
 during the particle lifetime.
\par

{\b float rot_rate;}\par

Rotation rate for dynamic adjustment of sprite's rotation as degrees per
 unit interval.  Should be set by set_rot_rate().
\par

{\b float scale_rate;}\par

Scale rate for dynamic adjustment of sprite's scale factor as unit scale per
 unit interval.  Should be set by set_scale_rate().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschParticle}{\v PG_ESCH_PARTICLE} plus :-
\par

{\b const EschParticleSprite &operator = (const EschParticleSprite &ps);}\par

Copies the data from another particle sprite, but does not copy the
 linked-list pointers or run-time type value and clears the owns bits of
 the target.  Any previously owned data is freed.
\par

{\b virtual void draw();}\par

Draws the particle at its current position.
\par

{\b virtual void animate();}\par

Performs the standard particle animation processing, plus updating the
 sprite's position for changes and the alpha value based on the alpha-rate.
\par

{\b void set_position(float ix, float iy, float iz);\line
void set_position(const EschPoint *pnt);}\par

Sets the position of the particle, updating the sprite instance.
\par

{\b void set_lifetime(float l);}\par

Sets the lifetime of the particle and sets the alpha rate to decay from
 the current alpha setting of the sprite (or 255 if no sprite has
 been attached) to transparent (0) over the lifetime.  Set the limits of
 the particle drawable to not include {\i ESCH_FACE_ALPHA} if this effect is
 not desired.
\par

{\b void set_rot_rate(float r);}\par

Sets rotation rate.
\par

{\b void set_rotation(float r);}\par

Accessor for sprite's rotation function.
\par

{\b void set_scale_rate(float s);}\par

Sets scale-adjument rate.
\par

{\b void set_scale(float s);}\par

Accessor for sprite's scale function.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschParticleSystem Class                                                  ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PARTICLESYS}
${\footnote EschParticleSystem Class}
K{\footnote EschParticleSystem;
EschParticleSystem, operator =;
EschParticleSystem, draw;
EschParticleSystem, animate;
EschParticleSystem, init;
EschParticleSystem, release;
EschParticleSystem, set_interval;
EschParticleSystem, set_acceleration}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschParticleSystem Class}\par\pard\sb100

This is a collective drawable which handles the dynamic management of
 EschParticle class instances.  New particle instances must be added
 manually to this class and the new particles are owned by this management
 class.  A global acceleration value is provided to simulate wind
 or gravity affecting the particles uniformly.
\par

\line{\b\fs28 Name}\par

EschParticleSystem - A Dynamic Particle Management Class
\par

\line{\b\fs28 Synopsis}\par

#include "espartik.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschParticleSystem();}\par

Performs no initialization.
\par

{\b EschParticleSystem(ulong mc);}\par

Calls init with the given max particle count.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b protected float interval;}\par

Interval for animation step.
\par

{\b ulong maxcount;}\par

Sets maximum particle count for system.
\par

{\b EschParticle **particles;}\par

Array of particle instances of size maxcount.  Empty (0)
 entries are skipped during processing.
\par

{\b EschVector acceleration;}\par

Global acceleration for all particles in system.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b const EschParticleSystem &operator = (const EschParticleSystem &ps);}\par

Copies the data from another particle system, but does not copy the
 linked-list pointers or run-time type value and clears the owns bits of
 the target.  Any previously owned data is freed.
\par

{\b virtual void draw();}\par

Draws all particles instances in array.
\par

{\b virtual void animate();}\par

This animates each particle in the system.
\par

{\b virtual void init(ulong mc);}\par

Initializes the system by releasing any current data and allocating
 mc particle slots.
\par

{\b virtual void release();}\par

Releases all particles and the particle slot array.
\par

{\b void add(EschParticle *p);}\par

Adds a new particle instance into the system, setting the current interval
 and acceleration into the particle.  The system class instance assumes
 ownership of the particle and will release it when the particle 'dies'.  If
 there are no more slots available, the particle is immediately freed.
\par

{\cf2
Note:  The limits of the particle system instance are pushed into all
 added particles.
}\par

{\b void set_interval(float i);}\par

Sets an interval for all particles in the system for animate() calls.
\par

{\b void set_acceleration(float ii, float ij, float ik);\line
void set_acceleration(const EschVector *v);}\par

Sets the global acceleration for the system.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschParticleGenerator Class                                               ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PARTICLEGEN}
${\footnote EschParticleGenerator Class}
K{\footnote EschParticleGenerator;
EschParticleGenerator, init;
EschParticleGenerator, animate;
EschParticleGenerator, generate;
EschParticleGenerator, get_position;
EschParticleGenerator, set_position;
EschParticleGenerator, set_top;
EschParticleGenerator, set_direction;
EschParticleGenerator, rotatex;
EschParticleGenerator, rotatey;
EschParticleGenerator, rotatez;
EschParticleGenerator, rotate;
EschParticleGenerator, pitch;
EschParticleGenerator, roll;
EschParticleGenerator, yaw;
EschParticleGenerator, translate;
EschParticleGenerator, move;
EschParticleGenerator, scale;
EschParticleGenerator, orthogonalize;
EschParticleGenerator, orthogonalize_top;
EschParticleGenerator, orthogonalize_right;
EschParticleGenerator, reset;
EschParticleGenerator, set_sphere;
EschParticleGenerator, set_circle;
EschParticleGenerator, set_rectangle;
EschParticleGenerator, set_parts;
EschParticleGenerator, set_speed;
EschParticleGenerator, set_size;
EschParticleGenerator, set_lifetime;
EschParticleGenerator, set_color;
EschParticleGenerator, set_alpha
EschParticleGenerator, set_callback}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschParticleGenerator Class}\par\pard\sb100

{\scaps\cf4 CHANGED}\line
This class extends the basic particle system class to include generation
 areas where new particles are created with stochasitically computed
 parameters.  The distributions for the number of particles generated,
 speed, size, lifetime, color, and alpha-level are given as a mean (average)
 value and a variance.  If the variance is 0, then the mean value is always
 used.  The initial location and direction of the particles are based on
 the choice of generation area which can be a sphere of radius r, a circle
 of radius r in the x/z plane in local coordinates, or a rectangle of
 length l and width w in the x/z plane in local coordinates.  In the case
 of both circles and rectangles, the maximum ejection angle controls the
 direction while spheres generate particles that move away from the
 local coordinate origin.  The initial direction combined with the
 stochastic speed determine the initial velocity.
\par

For maximum flexibility, new particle creation is handled by a callback
 routine which is expected to take the values in an {\b EschParticleGenParams}
 structure and create a new instance of an EschParticle-derived class.  The
 default callback routine creates {\uldb EschParticle}{\v PG_ESCH_PARTICLE}
 instances and therefore ignores size and alpha level.  The values in an
 {\b EschParticleGenParams} structure are as follows:
\par

\tab {\b EschParticleGenerator *generator;}\line
\tab\tab Pointer to generator instance calling the routine.
\par

\tab {\b void *data;}\line
\tab\tab Pointer to callback data (if any).
\par

\tab {\b EschPoint pos;}\line
\tab\tab Position of new particle.
\par

\tab {\b EschVector velocity;}\line
\tab\tab Velocity of new particle.
\par

\tab {\b float size;}\line
\tab\tab Size of new particle.
\par

\tab {\b dword color;}\line
\tab\tab Color index of new particle.
\par

\tab {\b float lifetime;}\line
\tab\tab Lifetime of new particle (which is per unit interval\line
\tab\tab unless {\i ESCH_PRTG_FRAMEBASED} is set which indicates\line
\tab\tab this is in frames).
\par

\tab {\b byte alpha;}\line
\tab\tab Alpha level of new particle.
\par

\tab {\b float rot_rate;}\line
\tab\tab Rotate rate of new particle.
\par

{\cf2
Note:  The maximum number of particles passed to init() determines the
 maximum displayed reguardless of the generation rate.  If more particles
 are generated than can fit into the system, the newer particles are thrown
 out.  This means that you must be careful to choose a large enough maximum
 count to allow correct generation based on both generation and lifetime
 distributions.
}\par

\line{\b\fs28 Name}\par

EschParticleGenerator - Dynamic Particle Generator Class
\par

\line{\b\fs28 Synopsis}\par

#include "espartik.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschParticleSystem}{\v PG_ESCH_PARTICLESYS}
\par

\line{\b\fs28 Constructors}\par

{\b EschParticleGenerator();}\par

Sets default internal values.
\par

{\b EschParticleGenerator(ulong mc);}\par

Sets default internal values and calls init() with given max particle
 count.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschParticleSystem}{\v PG_ESCH_PARTICLESYS} plus :-
\par

{\b EschFrameRef world;}\par

Frame-of-reference which maps the local coordinates of the generation
 area into world coordinates.  Appending transforms or adjusting the
 frame-of-reference only affects newly generated particles.
\par

{\b float gsize1;\line
float gsize2;}\par

Generation area size.  For a sphere or a circle, 'gsize1' specifies the
 radius.  For a rectangle, 'gsize1' specifies the length and 'gsize2'
 specifies the width.  Should be set with set_sphere(), set_circle(),
 or set_rectangle().
\par

{\b float maxangle;}\par

For circle or rectangle generation areas, this specifies the maximum
 ejection angle.  Should be set with set_sphere(), set_circle(),
 or set_rectangle().
\par

{\b float mean_parts;\line
float var_parts;};\par

Distribution for number of particles (by default this is per unit interval,
 but this is per frame if {\i ESCH_PRTG_FRAMEBASED} is set).  Should be set
 with set_parts().
\par

{\b float mean_speed;\line
float var_speed;}\par

Distribution for speed of the particles per unit interval.  Should be
 set with set_speed().
\par

{\b float mean_size;\line
float var_size;}\par

Distribution for size of the particles.  Should be set with
 set_size().
\par

{\b float mean_life;\line
float var_life;}\par

Distribution for lifetime of the particles (by default this is in interval
 time units but this is in frames if {\i ESCH_PRTG_FRAMEBASED} is set).  A
 zero mean_life and var_life indicates that all particles are unlimited in
 lifetime.  Should be set with set_lifetime().
\par

{\b byte mean_color_r;\line
byte mean_color_g;\line
byte mean_color_b;\line
byte var_color_r;\line
byte var_color_g;\line
byte var_color_b;}\par

Distribution of the Red, Green, and Blue components of the particles.  Should
 be set with set_color().
\par

{\b byte mean_alpha;\line
byte var_alpha;}\par

Distribution of the alpha levels of the particles.  Should be set with
 set_alpha().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschParticleSystem}{\v PG_ESCH_PARTICLESYS} plus :-
\par

{\b virtual esch_error_codes init(ulong mc);}\par

Initializes the particle generator, setting default values for the various
 parameters.  Must be called before being operated on.
\par

{\b virtual void animate();}\par

Calls generate() if {\i ESCH_PRTG_NOAUTOANIMATE} is not set and then
 calls the base animate().
\par

{\b virtual ulong generate();}\par

Creates new particles based on the distribution and generation area
 parameters combined with the current interval.  This could create 0
 or more particles.  The number of particles created is returned.
\par

{\b void get_position(EschPoint *p) const;}\par

Gets the origin of the particle generator.
\par

{\b set_position(float ix, float iy, float iz, dword update=ESCH_UPD_ALL);\line
void set_position(const EschPoint *pnt, dword update=ESCH_UPD_ALL);}\par

Sets the origin of the particle generator.
\par

{\b void set_top(const EschVector *v, dword update=ESCH_UPD_ALL);\line
void set_top(float ii, float ij, float ik, dword update=ESCH_UPD_ALL);}\par

Sets the 'up' vector for the generation area.
\par

{\b void set_direction(const EschVector *v, dword update=ESCH_UPD_ALL);\line
void set_direction(float ii, float ij, float ik, dword update=ESCH_UPD_ALL);}\par

Sets the 'forward' vector for the generation area.
\par

{\b void rotatex(const float degrees, dword update=ESCH_UPD_ALL);\line
void rotatey(const float degrees, dword update=ESCH_UPD_ALL);\line
void rotatez(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends an X/Y/Z-axis rotation to the world frame-of-reference.
\par

{\b void rotate(const EschVector *v, const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about an arbitrary axis to the orientation
 matrix and updates the direction vector and inverse information.
\par

{\b void pitch(const float degrees, dword update=ESCH_UPD_ALL);\line
void roll(const float degrees, dword update=ESCH_UPD_ALL);\line
void yaw(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about the frame's current X/Z/Y axis and
 updates the direction vector and inverse information.
\par

{\b void translate(const float idx, const float idy, const float idz, dword update=ESCH_UPD_ALL);\line
void translate(const EschVector *v, dword update=ESCH_UPD_ALL);}\par

Appends a translation to the world frame-of-reference.
\par

{\b void move(const float idx, const float idy, const float idz, dword update=ESCH_UPD_ALL);\line
void move(const EschVector *v, dword update=ESCH_UPD_ALL);}\par

Appends a translation to the world frame-of-reference defined in
 the local coordinates along the local I, J, and K axis.
\par

{\b void scale(float is, dword update=ESCH_UPD_ALL);}\par

Appends a scale to the world frame-of-reference of the object.
\par

{\b void orthogonalize(dword update=ESCH_UPD_ALL);\line
void orthogonalize_top(dword update=ESCH_UPD_ALL);\line
void orthogonalize_right(dword update=ESCH_UPD_ALL);}\par

Forces the orientation components of the frame-of-reference into
 an orthonormal basis to remove accumulated errors from rotations.  It
 will then update the inverse.  The standard version uses the direction
 vector as the first basis (the first basis is only normalized by the
 process), then the 'top' vector, and finally the 'right'.  The _top
 version uses the 'top' vector as the first basis, then the direction
 vector, and finally the 'right' vector.  The _right version uses the
 'right' vector as the first basis, then the direction vector, and
 finally the 'top' vector.
\par

{\b void reset();}\par

Resets the world frame-of-reference.
\par

{\b void set_sphere(float r);\line
void set_circle(float r, float ma);\line
void set_rectangle(float l, float w, float ma);}\par

Sets the generation area type and parameters (radius, length, width,
 and/or maximum ejection angle).
\par

{\b void set_parts(float mean, float var=0);\line
void set_speed(float mean, float var=0);\line
void set_size(float mean, float var=0);\line
void set_lifetime(float mean, float var=0);}\par

Sets the distribution mean and variance (which if 0 results in a constant
 value of the mean) for the number of particles generated per unit interval,
 speed per unit interval, size, and lifetime in frames respectively.
\par

{\scaps\cf4 CHANGED}\line
{\b void set_color(dword c);\line
void set_color(VngoPal *p, VngoColor24bit mean, VngoColor24bit var=0);}\par

Either sets a color index for use as the constant color value or sets
 the RGB mean and variance and provides the palette needed for RGB to
 index conversion.  If the palette given is a 15- or 16-bit palette,
 the colors are sent down in {\i VNGO_COLOR_24BIT} format.
\par

{\b void set_alpha(byte mean, byte var=0);}\par

Sets the distribution mean and variance (which if 0 results in a constant
 value of the mean) for the alpha level where 255 is opaque and 0 is
 transparent.
\par

{\cf2
Note:  This is the starting alpha level since the particles classes that
 take alpha usually ramp it linearly to 0 during the lifetime of the
 particle.
}\par

{\b void set_callback(EschParticleGenCallback f, void *d=0);}\par

This sets the callback routine and the optional data pointer.  If f is
 0 then the default particle generator routine which creates EschParticle
 instances is set ({\b esch_generate_particle}).  Routines for the
 other standard particles are included in this library as
 {\b esch_generate_line} which creates EschParticle Line instances,
 {\b esch_generate_pyramid} which creates EschParticlePyramid instances
 and {\b esch_generate_sprite} which takes the EschSprite instance to use
 as the source for new particles as the 'data' pointer.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_PRTG_CIRCLE}\tab\tab\tab Generation area is a circle (normally a sphere).
\par

{\i ESCH_PRTG_RECTANGLE}\tab\tab Generation area is a rectangle (normally a
 sphere).
\par

{\i ESCH_PRTG_NOAUTOGENERATE}\tab If set, then generate() is not called
 as part of the animate() processing.
\par

{\i ESCH_PRTG_FRAMEBASED}\tab If set, then the number of particles generated
 and lifetime are given as 'per frame' rather than 'per unit interval'.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschGeometry Class                                                        ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_GEOMETRY}
${\footnote EschGeometry Class}
K{\footnote EschGeometry;
EschGeometry, operator =;
EschGeometry, draw;
EschGeometry, sibling;
EschGeometry, adopt;
EschGeometry, next;
EschGeometry, prev;
EschGeometry, parent;
EschGeometry, child;
EschGeometry, find;
EschGeometry, get_extents;
EschGeometry, ray;
EschGeometry, hit;
EschGeometry, pick;
EschGeometry, collide;
EschGeometry, animate;
EschGeometry, draw_extents;
EschGeometry, get_position;
EschGeometry, set_position;
EschGeometry, set_top;
EschGeometry, set_direction;
EschGeometry, rotatex;
EschGeometry, rotatey;
EschGeometry, rotatez;
EschGeometry, rotate;
EschGeometry, pitch;
EschGeometry, roll;
EschGeometry, yaw;
EschGeometry, translate;
EschGeometry, move;
EschGeometry, scale;
EschGeometry, orthogonalize;
EschGeometry, orthogonalize_top;
EschGeometry, orthogonalize_right;
EschGeometry, reset;
EschGeometry, compute_world;
EschGeometry, compute_extents}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschGeometry Class}\par\pard\sb100

Most 3D geometric objects are more complicated than a single
 point.   These more complex objects exist over a volume of
 3-space and can have transforms applied individually for
 position and orientation adjustment.  This class extends the
 concept of a drawable to a 3D geometry drawable that includes
 local transformation, tree organization, and spherical extent
 information.
\par

All data contained within the EschGeometry class should be in
 local coordinates, which are transformed to world coordinates
 via the world frame-of-reference, which is derived from the
 local frame-of-reference and the parent's world frame-of-reference.
\par

Some operations require that the frame-of-references be updated to
 maintain consistency in the data structure.  The update flags
 control this behavior, which by default indicates all required changes
 should be made (see {\b Update Flags}).
\par

\line{\b\fs28 Name}\par

EschGeometry - Base Geometry Drawable
\par

\line{\b\fs28 Synopsis}\par

#include "esgeom.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschGeometry();}\par

Initializes the parent and child links to zero and invokes the
 constructors for the local frames-of-reference.
\par

{\b EschGeometry(const EschGeometry &geom);}\par

Initializes the geometry from another geometry, including
 the run-time type identifier, but not the link pointers.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b protected EschGeometry *iparent;\line
protected EschGeometry *ichild;}\par

Tree pointers for hierarchies of  EschGeometry instances.
\par

{\b EschFrameRef  local;}\par

Frame-of-reference to move from local coordinates of the object
 instance to the local coordinates of the parent.  If there is no
 parent, this moves from local to world coordinates.
\par

{\b EschFrameRef  world;}\par

Frame-of-reference to move from local coordinates of the object
 to world coordinates.  This is derived from the local
 frame-of-reference and the parent's world frame-of-reference.
\par

{\b EschSphereExtents *sphere;\line
EschSphereExtents exts;}\par

Spherical extents of the object defined in local coordinates.  The 'sphere'
 pointer should point to the 'original' spherical extents of the geometry
 object, as 'exts' will be kept updated to include all children of
 the instance (done by compute_extents).
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b const EschGeometry &operator = (const EschGeometry &geom);}\par

Copies the data from another geometry, but does not copy the linked-list
 pointers or run-time type value and clears the owns bits of the target.
 compute_world() is called during this operation.
\par

{\b virtual void draw();}\par

The default handler for this routine simply informs any children
 to draw if they do not have the {\i ESCH_DRW_SKIP} bit set.
\par

{\b EschGeometry *next() const;\line
EschGeometry *prev() const;\line
EschGeometry *parent() const;\line
EschGeometry *child() const;}\par

Returns the inext/iprev/iparent/ichild members for walking the
 tree structure of instances.
\par

{\cf2
Note: next()/prev() return the same value as EschDrawable's next()/prev()
 functions, but it has been cast to an EschGeometry pointer.
}\par

{\b virtual void sibling(EschGeometry *myprev, dword update=ESCH_UPD_ALL);\line
virtual void adopt(EschGeometry *myparent, dword update=ESCH_UPD_ALL);}\par

These routines are used to build the tree structures.  These
 routines assume the class instance is not already attached to
 anything as a sibling/child.
\par

{\b virtual void remove(int delchild=0, dword update=ESCH_UPD_ALL);}\par

Removes the instance from the tree structure it resides in, if
 any.  Any children are removed from the structure along with the
 instance, but remain attached to the removed parent instance if
 delchild is zero.  If delchild is non-zero, then the children
 are destroyed with the delete operator.
\par

{\cf2
Note: The destructor calls remove(0).
}\par

{\b virtual EschDrawable *find(const char *name) const;}\par

Searches the tree of drawables attached to the class instance
 for the given name.  Returns a pointer to the found object or
 0 if not found.
\par

{\b virtual int get_extents(EschSphereExtents *sp);}\par

Sets sp to have the spherical extent pointed to by 'sphere' and returns 0.
\par

{\b virtual float ray(const EschPoint *pt, const EschVector *v, int coarse=0);}\par

Performs a ray (start at pt, and doing in the direction of v) intersection
 test with the drawable's extents.  It performs a ray/sphere intersection
 test with the spherical extent in 'sphere'.  It returns 0 if not hit, or
 the distance along the ray of the intersection.
\par

{\b virtual int hit(const EschPoint *pt, const float r, int coarse=0);}\par

Performs a sphere (center of pt and radius of r) intersection test with
the extent pointed to by 'sphere'.  It returns 1 if hit or 0 if not hit.
\par

{\b virtual esch_error_codes pick(EschPicking *data);}\par

Performs a picking operation, testing a list of drawables for a ray
 intersection.  See the {\uldb EschPicking}{\v PG_ESCH_PICKING}
 commmunication interface structure for details.  If testing a geometry,
 then any children of the geometry are also tested.
\par

{\b virtual esch_error_codes collide(EschCollide *data);}\par

Performs a collision detection operation, testing a list of drawables for
 a hit with the current drawable instance (or optionally, an arbitrary
 spherical extent).  See the {\uldb EschCollision}{\v PG_ESCH_COLLISION}
 commmunication interface structure for details.  If testing a geometry,
 then any children of the geometry are also tested.
\par

{\b virtual void animate()}\par

This implementation calls animate() for each child object that does
 not have {\i ESCH_DRW_SKIPANIMATE} set.
\par

{\b void draw_extents(dword clr) const;}\par

Draws the radial extents using the current drawing context with the
 given color clr.
\par

{\b void get_position(EschPoint *pt) const;}\par

Retrieves the position of the geometric object in the parent's
 local coordinates, which are world coordinates if there is no
 parent.
\par

{\b void set_position(const EschPoint *pt, dword update=ESCH_UPD_ALL);\line
void set_position(const float ix, const float iy, const float iz, dword update=ESCH_UPD_ALL);}\par

Sets the position of the geometric object in the parent's local
 coordinates, which are world coordinates if there is no parent,
 and updates the world frame-of-reference.
\par

{\b void set_top(const EschVector *v, dword update=ESCH_UPD_ALL);\line
void set_top(float ii, float ij, float ik, dword update=ESCH_UPD_ALL);}\par

Sets the top vector of the geometric object in the parent's local
 coordinates, which are world coordinates if there is no parent,
 and updates the world frame-of-reference.
\par

{\b void set_direction(const EschVector *v, dword update=ESCH_UPD_ALL);\line
void set_direction(float ii, float ij, float ik, dword update=ESCH_UPD_ALL);}\par

Sets the direction vector of the geometric object in the parent's local
 coordinates, which are world coordinates if there is no parent,
 and updates the world frame-of-reference.
\par

{\b void rotatex(const float degrees, dword update=ESCH_UPD_ALL);\line
void rotatey(const float degrees, dword update=ESCH_UPD_ALL);\line
void rotatez(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends an X/Y/Z-axis rotation to the local frame-of-reference
 of the object and updates the world frame-of-reference.
\par

{\b void rotate(const EschVector *v, const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about an arbitrary axis to the orientation
 matrix and updates the direction vector and inverse information.
\par

{\b void pitch(const float degrees, dword update=ESCH_UPD_ALL);\line
void roll(const float degrees, dword update=ESCH_UPD_ALL);\line
void yaw(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about the frame's current X/Z/Y axis and
 updates the direction vector and inverse information.
\par

{\b void translate(const float idx, const float idy, const float idz, dword update=ESCH_UPD_ALL);\line
void translate(const EschVector *v, dword update=ESCH_UPD_ALL);}\par

Appends a translation to the local frame-of-reference of the
 object and updates the world frame-of-reference.
\par

{\b void move(const float idx, const float idy, const float idz, dword update=ESCH_UPD_ALL);\line
void move(const EschVector *v, dword update=ESCH_UPD_ALL);}\par

Appends a translation to the local frame-of-reference defined in
 the local coordinates along the local I, J, and K axis.
\par

{\b void scale(float is, dword update=ESCH_UPD_ALL);}\par

Appends a scale to the local frame-of-reference of the object
and updates the world frame-of-reference.
\par

{\b void orthogonalize(dword update=ESCH_UPD_ALL);\line
void orthogonalize_top(dword update=ESCH_UPD_ALL);\line
void orthogonalize_right(dword update=ESCH_UPD_ALL);}\par

Forces the orientation components of the frame-of-reference into
 an orthonormal basis to remove accumulated errors from rotations.  It
 will then update the inverse and the world frame-of-reference.
 The standard version uses the direction vector as the first basis
 (the first basis is only normalized by the process), then the 'top'
 vector, and finally the 'right'.  The _top version uses the 'top'
 vector as the first basis, then the direction vector, and finally
 the 'right' vector.  The _right version uses the 'right' vector as
 the first basis, then the direction vector, and finally the 'top'
 vector.
\par

{\b void reset(dword update=ESCH_UPD_ALL);}\par

Resets the local frame-of-reference to the identity and updates
 the world frame-of-reference.
\par

{\b void compute_world(dword update=ESCH_UPD_ALL);}\par

This should be used if the local frame-of-reference is updated
 directly using EschFrameRef members.  This updates the world
 frame-of-reference, which requires all children are updated.
 This is the routine called by the various members of this object
 to update world frames-of-reference.
\par

{\b void compute_extents(int partialfix=0, int doparent=1);}\par

This is called to ensure that the spherical extents include the
 children of geometry objects (this allows rejection of a sub-tree of
 geometries by checking the parent's spherical extents).  If 'partialfix'
 is non-zero, then only the current instance's spherical extents are
 recomputed from the original data and its immediate children.  If
 'partialfix' is zero, then the spherical extents of all children of
 the current instance will be recomputed as well.  If 'doparent' is
 non-zero, then the parent will be called with a non-zero partialfix once
 the current instance's extents are recomputed.
\par

\line{\b\fs28 Update Flags}\par

{\i ESCH_UPD_INVERSE}\tab Indicates the transform routine should recompute
 the inverse matrix.
\par

{\i ESCH_UPD_ORTHO}\tab Indicates the rotate transform routine should
 call orthonormalize() if the ortho_count exceeds {\i ESCH_MAX_ORTHOCOUNT}.
\par

{\i ESCH_UPD_WORLD}\tab Indicates the transform routine should recompute
 the local-to-world frame-of-reference.
\par

{\i ESCH_UPD_EXTENTS}\tab Indicates the transform routine should
 recompute the spherical extents as needed.
\par

{\i ESCH_UPD_ALL}\tab Indicates all required updating should be performed.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschMeshDraw Class                                                        ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_MESHDRAW}
${\footnote EschMeshDraw Class}
K{\footnote EschMeshDraw;
EschMeshDraw, operator =;
EschMeshDraw, draw;
EschMeshDraw, ray;
EschMeshDraw, hit;
EschMeshDraw, animate;
EschMeshDraw, attach;
EschMeshDraw, detach;
EschMeshDraw, draw_extents;
EschMeshDraw, clone;
EschMeshDraw, load}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschMeshDraw Class}\par\pard\sb100

The most common 3D object in most real-time display systems is a
 polygon mesh.  Polygons are a powerful modeling primitive, and
 this class supports the drawing of collections of connected
 triangles.  In order to facilitate reuse of the mesh data
 without extensive memory overhead, the vertex and face mesh data
 is held in supporting instances of {\uldb EschMesh}{\v PG_ESCH_MESH},
 which may be attached to a number of EschMeshDraw instances.
\par

\line{\b\fs28 Name}\par

EschMeshDraw - Triangle Polygonal Mesh Drawable
\par

\line{\b\fs28 Synopsis}\par

#include "esgeom.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschGeometry}{\v PG_ESCH_GEOMETRY}
\par

\line{\b\fs28 Constructors}\par

{\b EschMeshDraw(EschMesh *mdata=0);}\par

Attaches the mesh, if any given.
\par

{\b EschMeshDraw(const char *fname, const char oname=0, VngoPal
 *pal=0, EschMesh *msh=0, char *pn, dword ctrlfl=ESCH_MSHLD_ALL);}\par

Loads data into a mesh object and attaches it to the drawable.
 If msh is zero, then a mesh class instance is created by load.
\par

{\b EschMeshDraw(const EschMeshDraw &mshd);}\par

Initializes the mesh draw from another mesh draw, including
 the run-time type identifier, but not the link pointers.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschGeometry}{\v PG_ESCH_GEOMETRY}, plus :-
\par

{\b EschMesh *mesh;}\par

This points to any attached EschMesh class instance.
\par

{\b ulong tmax;\line
EschTexture **txt;}\par

Instance texture data array and count.  This is set by attach to
 the values contained in the EschMesh object, but may then be
 overridden.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschGeometry}{\v PG_ESCH_GEOMETRY}, plus :-
\par

{\b const EschMeshDraw &operator = (const EschMeshDraw &mshd);}\par

Copies the data from another mesh draw, but does not copy the linked-list
 pointers or run-time type value and clears the owns bits of the target.
 compute_world() is called during this operation.  A detach is preformed
 before the new data is copied.
\par

{\b virtual void draw();}\par

This draws the associated mesh relative to the current context.
\par

{\b virtual float ray(const EschPoint *pt, const EschVector *v, int coarse=0);}\par

Performs a ray (start at pt, and doing in the direction of v) intersection
 test with the extents.  It performs a ray/sphere intersection first,
 returning 0 if it missed.  If coarse is set, then it returns the result of
 the ray/sphere intersection.  If coarse is not set, then a ray/box
 test is performed and the results returned with 0 indiciating a miss.
\par

{\b virtual int hit(const EschPoint *pt, const float r, int coarse=0);}\par

Performs a sphere (center of pt and radius of r) intersection test with
 the extents.  It performs a sphere/sphere intersection test first,
 returning 0 if it missed.  If coarse is set, then it returns the result
 of the sphere/sphere intersection test.  If coarse is not set, then a
 sphere/box intersection test is performed and the results returned
 with 0 indicating a miss and 1 a hit.
\par

{\b virtual void animate()}\par

This implementation calls animate() for each texture in the 'txt' array.
 This should be called by the application.
\par

{\b esch_error_codes attach(EschMesh *mdata, dword update=ESCH_UPD_ALL);\line
void detach();}\par

These routines attach and detach EschMesh instances to/from the
 geometry instance.  These routines should be used to ensure safe
 usage of these classes.  If the {\i ESCH_DRW_OWNSDATA} bit is set,
 then the mesh instance is deleted on a detach.  If
 {\i ESCH_MSHD_OWNSTEXTURE} bit is set, then the txt data is deleted
 on detach (subject to the OWNSNO bits).  Detach is called by the
 destructor.
\par

{\b void draw_extents(dword clr, int box=0) const;}\par

Draws the radial extents (or mesh's box extents if box is non-zero)
 using the current drawing context with the given color clr.
\par

{\b EschMeshDraw *clone(int dupmf=1) const;}\par

This routine will 'clone' a EschMeshDraw instance, returning a new
 EschMeshDraw instance (or tree of instances) which shares the same
 {\uldb EschMesh}{\v PG_ESCH_MESH} instance(s).  If 'dupmf' is set to 1,
 then any multi-frame textures in the clone are new instances of
 {\uldb EschMultiFrameTexture}{\v PG_ESCH_MFRAMETEXTURE} which reference
 the same texture data.  This is needed to prevent animating of one
 instance causing all instances of the mesh to have their animated
 textures advance in lock-step.  All the children of the
 EschMeshDraw instance are similiarly cloned.
\par

{\cf2
Note:  All cloned instances should be deleted BEFORE the original since
 the clones reference data owned by the original.  Failure to do this
 will result in dangling pointers.
}\par

{\b virtual esch_error_codes load(const char *fname, const char
 *oname=0, VngoPal *pal=0, EschMesh *msh=0, char *pn,
 dword ctrlfl=ESCH_MSHLD_ALL);}\par

Loads the mesh from the given file, including the orientation
 and position information, if any exported with the mesh.  If msh
 is zero, then an instance of EschMesh is created for the load.
 The EschMesh instance is attached to the EschMeshDraw instance
 during the load process.  The pal is used as the palette for
 recoloring the mesh's base face colors and for texture loading.
 The ctrlfl flags are passed along to EschMesh::load().
\par

{\b virtual esch_error_codes load(XFParseIFF *iff, const char
 *oname=0, VngoPal *pal=0, EschMesh *msh=0, char *pn,
 dword ctrlfl=ESCH_MSHLD_ALL);}\par

Will load the mesh from the given IFF file if chunk currently
 pointed to is a scene form.  If oname is given, it is compared with
 the object name in the file and an error is returned if it doesn't
 match.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_DRW_OWNSDATA}\tab Drawable owns the associated mesh instance
 and should freed by detach.
\par

{\i ESCH_MSHD_OWNSTEXTURE}\tab Drawable owns the block pointed to by txt
 and should be freed by detach.
\par

{\i ESCH_MSHD_NOEXTENTSCHK}\tab Radial extents check should not be
 performed during a draw.
\par

{\i ESCH_MSHD_OWNSNOSTCTXT}\tab When freeing textures, don't delete any
 texture instances of type {\i ESCH_TXTT_STATIC}.
\par

{\i ESCH_MSHD_OWNSNOMFTXT}\tab When freeing textures, don't delete any
 texture instances of type {\i ESCH_TXTT_MFRAME}.
\par

{\i ESCH_MSHD_OWNSNOPRCTXT}\tab When freeing textures, don't delete any
 texture instances of type {\i ESCH_TXTT_PRC}.
\par

\line{\b\fs28 Error codes}\par

{\i ESCH_ERR_NONE}\tab\tab No error
\par

{\i ESCH_ERR_NOMEMORY}\tab Memory allocation failed
\par

{\i ESCH_ERR_FILEERROR}\tab File error during load.
\par

{\i ESCH_ERR_NOTFOUND}\tab Object not found.
\par

{\i ESCH_ERR_INVALIDDATA}\tab Data for object invalid.
\par

{\i ESCH_ERR_INVALIDVDATA}\tab Vertex data for object invalid.
\par

{\i ESCH_ERR_INVALIDFDATA}\tab Face data for object invalid.
\par

\line{\b\fs28 Example}\par

This example loads a mesh instance of 'Object01' from the
 'OBJECT.IFF' export file and then draws it rotating about the Y
 axis 1 degree per frame:
\par

{\f2
EschCamera Camera;
\par
// Needed to recolor properly
\par
VngoPal Palette;
\par
EschMeshDraw  mdraw;
\par
esch_error_codes  err;
\par
if ((err = mdraw.load("OBJECT.IFF","Object01",Palette)) != 0)\line
\{
\par
    // Error, as returned by function into err.
\par
\}
\par
while (!kbhit())\line
\{
\par
    // Render object to camera
\par
    Camera.render(&mdraw);\line
    mdraw->rotatey(1);\line
\}
}
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschTerrain Class                                                         ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_TERRAIN}
${\footnote EschTerrain Class}
K{\footnote EschTerrain;
EschTerrain, operator =;
EschTerrain, draw;
EschTerrain, animate;
EschTerrain, compute_shades;
EschTerrain, release;
EschTerrain, get_height;
EschTerrain, get_surface_flags;
EschTerrain, get_surface_color;
EschTerrain, check_LOS;
EschTerrain, set_origin;
EschTerrain, set_scale;
EschTerrain, set_lod;
EschTerrain, load}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschTerrain Class}\par\pard\sb100

Polygonal terrain may be represented as a collection of heights
 along a 2D grid (i.e. a Digital Elevation Model).  This is a
 standard elevation model and is the same model as is used by
 Virtual Reality Lab's VistaPro product, as well as a number of
 other terrain related applications.
\par

This class implements this kind of terrain system.  The 2D grid
 is defined to lie on the XZ plane with a given origin and
 controllable scaling for the width/depth and height
 dimensions.  Surface information, including color and lighting
 normals, may be less dense than height information to reduce
 memory requirements.
\par

{\cf2
Note: The reason that the height and surface data is held in
 static memory rather than handle memory is due to performance
 requirements. The terrain is generally drawn every frame, and
 the data set is too large to be swapped quickly.
}\par

The terrain system must be lit with an explicit call to
 compute_shades().  This is needed because lighting the terrain
 every frame would cause poor performance.
\par

\line{\b\fs28 Name}\par

EschTerrain - Polygonal Height-field Terrain Drawable
\par

\line{\b\fs28 Synopsis}\par

#include "esterran.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschTerrain(const char *fname=0, const char *tname=0, VngoPal *pal=0);}\par

Initializes the terrain instance, and optionally loads a terrain
 set if fname is non-zero.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b protected char iname[ESCH_MAX_NAME];}\par

Internal space for string, pointed to by 'name' member.
\par

{\b ushort width;}\par

Width of height field.
\par

{\b ushort depth;}\par

Depth of height field.
\par

{\b ulong surfratio;\line
ulong surfshift;}\par

Ratio of height field entries to surface entries and shift value
 associated with it.
\par

{\cf2 Note: surfratio must be a power of 2 so that surfshift is correct.}\par

{\b float scale;\line
ulong scaleshift;}\par

World space per unit in width and depth and associated shift value.
\par

{\cf2 Note: scale must be a power of 2 so that scaleshift is correct.}\par

{\b float lodmedium, lodlow;}\par

View or eye coordinate distance for level of detail adjuments
 from High to Medium and Medium to Low.  These are only used if
 the {\i ESCH_TRN_LOD} flag is set (See Flags for more details).
\par

{\b EschPoint origin;}\par

Origin of height field.
\par

{\b byte *hfield;}\par

2D array of height indexes into the height table.
\par

{\b float *htable;}\par

256 entry array of height values indexed by the height-field values.
\par

{\b esch_surf_type *surfinfo;}\par

2D array of surface information.  Each surface information entry has the
 following structure:
\par

\tab struct esch_surf_type\line
\tab \{\line
\tab\tab ushort flags;\line
\tab\tab byte shd;\line
\tab\tab byte cind;\line
\tab \}
\par

The cind entry is either a color to use when drawing the associated faces,
 or if flags contains the {\i ESCH_SURF_CINDISTXT} bit, it is an index+1 into
 the txt texture array.
\par

{\b IvoryHandle hsurfnorml;}\par

Handle to 2D array of surface normals.
\par

{\cf2
Note: The dimensions of the surfinfo and hsurfnorml arrays are
 (width >> surfshift) by (height >> surfshift).
}\par

{\b ulong tmax}\par

Number of textures loaded into the txt and txtcolor arrays.
\par

{\b byte *txtcolor}\par

Array of colors to use for texture entries when in non-textured display
 modes.
\par

{\b EschTexture **txt}\par

Array of textures to use for texture entries.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b const EschTerrain &operator = (const EschTerrain &t);}\par

Copies the data from another terrain, but does not copy the linked-list
 pointers or run-time type value and clears the owns bit of the
 target.  Any previously owned data is freed.
\par

{\b virtual void draw();}\par

This draws the terrain relative to the current context.
\par

{\b virtual void animate()}\par

This implementation calls animate() for each texture in the 'txt' array.
 This should be called by the application.
\par

{\b virtual void compute_shades(EschCamera *cam, EschLights *lgts,
 float exagerate=1.0f);}\par

This member computes the shade values for the terrain surface
 based on the surface information, normals, and the passed in
 camera'a flags and palette, and the given light list.  This will
 need to be called anytime the lights or camera shade flags/palette are
 altered.  The exagerate value will cause the effect of the normal
 to be more severe resulting in less realistic--but more dramatic--lighting.
\par

{\b virtual void release();}\par

Releases the data associated with the instance if the
{\i ESCH_DRW_OWNSDATA} flag is set.
\par

{\b virtual float get_height(float x, float z) const;\line
float get_height(const EschPoint *pt) const;}\par

Returns the world-coordinate point on the terrain for the given input
 world x and z position.
\par

{\b virtual ushort get_surface_flags(float x, float z) const;\line
ushort get_surface_flags(const EschPoint *pt) const;}\par

Returns the surface flags at the given point in world-space.
\par

{\b virtual dword get_surface_color(float x, float z) const;\line
dword get_surface_color(const EschPoint *pt) const;}\par

Returns the base color of the surface at the given point in world-space,
 which could be a texture's base color.
\par

{\b virtual int check_LOS(EschPoint *pt1, EschPoint *pt2, int precision=-1,
 float *dist=0, EschPoint *npos=0) const}\par

Performs a line-of-sight check between two points.  If a precision value
 is given, the check is done as 'precision' steps along the vector,
 otherwise, checks are done every 'scale' units.  Returns 1 if the vector
 remains clear of the terrain, or 0 if the vector is below the terrain.  If
 dist/npos are non-null, then the approx. distance along the vector where it
 hits the terrain and the approx. point of intersection are set if 0 is returned.
\par

{\cf2
Note:  This routine currently uses get_height() for each check.
}\par

{\b void set_origin(const EschPoint *pt);\line
void set_origin(const float ix, const float iy, const float iz);}\par

Sets the origin of the terrain grid.
\par

{\b void set_scale(const float i);}\par

Sets the scaling factor {\b scale}.
\par

{\b void set_lod(const float lodm, const float lodl)}\par

Sets the level of detail distances, and sets the {\i ESCH_TRN_LOD} flag.
\par

{\b virtual esch_error_codes load(const char *fname, const char *tname=0,
 ushort *hclr=0, VngoPal *pal=0, dword ctrlfl=ESCH_TRNLD_ALL);}\par

Loads the terrain data and scaling factors from the given file.  'hclr'
 is a ushort array of 11 items which gives world coordinate height to
 color mappings as used by the terrain editor application.  The 'pal'
 entry is used for texture loading.  The ctrlfl flags parameter
 controls additional behavior (see {\b Control Flags}).
\par

{\b virtual esch_error_codes load(XFParseIFF *iff, const char *tname=0,
 ushort *hclr=0, VngoPal *pal=0, dword ctrlfl=ESCH_TRNLD_ALL);}\par

Will load the terrain from the given IFF file if chunk currently
 pointed to is a terrain form.  'hclr' is a ushort array of 11 items which
 gives world coordinate height to color mappings as used by the
 terrain editor application.  The 'pal' entry is used for texture loading.
 The ctrlfl flags parameter controls additional behavior (see
 {\b Control Flags}).
\par

\line{\b\fs28 Flags}\par

{\i ESCH_DRW_OWNSDATA}\tab Drawable owns the various arrays and they should
 be freed by the destructor.
\par

{\i ESCH_TRN_DOTS}\tab The terrain should be drawn as a field of colored
 points rather than triangles.  This is useful for previews or
 special effects.
\par

{\i ESCH_TRN_LOD}\tab The terrain should be drawn using the Level Of
 Detail adjustments.  From the camera's position to the lodmedium
 distance in view or eye coordinates, the highest level of detail
 is used.  From lodmedium to lodlow, the medium level of detail
 is used (skips every odd row/column).  And past lodlow, the low
 level of detail is used (uses every 4th row/column).
\par

\line{\b\fs28 Control Flags}\par

{\i ESCH_TRNLD_USEMFTXT}\tab Should load animated textures as multi-frame
 textures.  Otherwise, the first frame is loaded as a static texture.
\par

{\i ESCH_TRNLD_SHARETXT}\tab Should use textures stored in cache and
 share any loaded textures.
\par

{\i ESCH_TRNLD_FILETXT}\tab Should try to find textures in registered
 texture files.
\par

{\i ESCH_TRNLD_ALL}\tab All of the above.
\par

\line{\b\fs28 Surface Flags}\par

{\i ESCH_SURF_FLIPU\line
ESCH_SURF_FLIPV}\tab Causes the U,V parameters for the terrain texture
 to be flipped.
\par

{\i ESCH_SURF_CINDISTXT}\tab Indicates that the cind entry is a texture
index.
\par

{\i ESCH_SURF_TILE1 - ESCH_SURF_TILE3}\tab Tile factor for terrain textures.
\par

{\i ESCH_SURF_NOTILE}\tab Texture cannot be tiled.
\par

{\i ESCH_SURF_HIDDEN}\tab Triangles on this part of the terrain are hidden
 and should not be drawn.
\par

{\i ESCH_SURF_HIGHONLY\line
ESCH_SURF_CBIT4\line
ESCH_SURF_CBIT11\line
ESCH_SURF_CIBT12}\tab Reserved for future use.
\par

{\i ESCH_SURF_APP0} -\line
{\i ESCH_SURF_APP3}\tab Reserved for use by the application.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschTerrainEx Class                                                       ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_TERRAINEX}
${\footnote EschTerrainEx Class}
K{\footnote EschTerrainEx;
EschTerrainEx, set_lod;
EschTerrainEx, set_texture_lod;
EschTerrainEx, set_perspective_lod;
EschTerrainEx, set_smooth_lod;
EschTerrainEx, set_start_lod;
EschTerrainEx, get_num_lod;
EschTerrainEx, get_texture_lod;
EschTerrainEx, get_perspective_lod;
EschTerrainEx, get_smooth_lod;
EschTerrainEx, get_start_lod;
EschTerrainEx, get_dlevels;
EschTerrainEx, hide_rect}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschTerrainEx Class}\par\pard\sb100

This extends the polygonal terrain system with a more complex level-of-detail
 model.
\par

\line{\b\fs28 Name}\par

EschTerrainEx - Extended Polygonal Height-field Terrain Drawable
\par

\line{\b\fs28 Synopsis}\par

#include "esterran.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschTerrain}{\v PG_ESCH_TERRAIN}
\par

\line{\b\fs28 Constructors}\par

{\b EschTerrainEx (const char *fname=0, const char *tname=0, VngoPal *pal=0);}\par

Clears pointers and calls the load() routine if fname is non-zero.
\par

{\b EschTerrainEx (const EschTerrainEx &_t);}\par

Creates an instance from data contained within an EschTerrain instance.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschTerrain}{\v PG_ESCH_TERRAIN}.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschTerrain}{\v PG_ESCH_TERRAIN} plus :-
\par

{\b virtual void set_lod (int count,...);}\par

Sets the levels of detail (must be called before other lod calls).
 The first parameter indicates number of levels, followed count-1 parmeters
 for the distance cut-offs in world space.
\par

{\b virtual void set_texture_lod(int lod);}\par

Sets the level of detail number which is the last one which is textured.  All
 further levels-of-detail are not textured.
\par

{\b virtual void set_perspective_lod(int lod);}\par

Sets the level of detail number which is the last one which uses perspective
 correction for the textures.
\par

{\b virtual void set_smooth_lod(int lod);}\par

Sets the level of detail which is the last one which has smoothing applied.
\par

{\b virtual void set_start_lod(int lod);}\par

Sets the starting level of detail for the draw (could be lower than the
 the highest-detail level 0).
\par

{\b int get_num_lod() const;\line
int get_texture_lod() const;\line
int get_perspective_lod() const;\line
int get_smooth_lod() const;\line
int get_start_lod() const;}\par

Gets the current settings for the level of detail variables.
\par

{\b float *get_dlevels() const;}\par

Returns the internal array of detail-level cut-offs.
\par

{\b void hide_rect(VngoRect &hrect);}\par

Sets the {\i ESCH_SURF_HIDDEN} flag for all surfaces within the rectangle
 (expressed as grid locations, not world-space coordinates).
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschTerrainTreeTop Class                                                  ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_TERRAINTREETOP}
${\footnote EschTerrainTreeTop Class}
K{\footnote EschTerrainTreeTop;
EschTerrainTreeTop, update_lods;
EschTerrainTreeTop, get_left;
EschTerrainTreeTop, get_right;
EschTerrainTreeTop, get_top;
EschTerrainTreeTop, get_bottom;
EschTerrainTreeTop, get_exterior_rect;
EschTerrainTreeTop, get_exterior_rect_world;
EschTerrainTreeTop, get_interior_rect;
EschTerrainTreeTop, get_interior_rect_world}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschTerrainTreeTop Class}\par\pard\sb100

This drawable is for use with the {\uldb EschTerrainEx}{\v PG_ESCH_TERRAINEX}
 class and provides a textured 'skirt' above the terrain.  The Tree Top
 echos the contour of the terrain beneath it.  It is generally used for
 creating forests or large areas of impassable objects.  The drawable
 has both an interior and and exterior skirt to represent the 'thin'
 surrounding of a forest and the impassable interior.
\par

\line{\b\fs28 Name}\par

EschTerrainTreeTop - Tree Skirt Drawable for Extended Polygonal Terrains
\par

\line{\b\fs28 Synopsis}\par

#include "esterran.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschTerrainEx}{\v PG_ESCH_TERRAINEX}
\par

\line{\b\fs28 Constructors}\par

{\b EschTerrainTreeTop(EschTerrainEx* terr, int _left, int _right,
 int _top, int _bottom, float _hgt);}\par

Creates the tree top with reference to an existing terrain instance
 given the grid locations on the terrain and a height parameter
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschTerrainEx}{\v PG_ESCH_TERRAINEX}.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschTerrainEx}{\v PG_ESCH_TERRAINEX} plus :-
\par

{\b void update_lods();}\par

Updates the levels of detail for the Tree Top to match those of the
 underlying terrain drawable.
\par

{\b long get_left() const;\line
long get_right() const;\line
long get_top() const;\line
long get_bottom() const;}\par

Returns the grid location with reference to the underlying terrain.
\par

{\b void get_exterior_rect (VngoRect *rect);\line
void get_exterior_rect_world (float *x, float *z, float *dx, float *dz);}\par

Gets the exterior skirt of the tree top drawable.
\par

{\b void get_interior_rect (VngoRect *rect);\line
void get_interior_rect_world (float *x, float *z, float *dx, float *dz);}\par

Gets the interior skirt of the tree top drawable.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschPartition Class                                                       ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PARTITION}
${\footnote EschPartition Class}
K{\footnote EschPartition;
EschPartition, operator =;
EschPartition, release;
EschPartition, insert;
EschPartition, remove;
EschPartition, traverse;
EschPartition, update}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschPartition Class}\par\pard\sb100

This class defines a generic interface for partitioning schemes, which
 classify drawables by their physical location to increase performance of
 spatial operations such as rendering, picking, collision detection, and
 other processes.  Partitions can be linked with other drawables, including
 other partitions.  Since the choice of partitioning scheme relies heavily
 on the specific application needs, this class is pure virtual.
\par

A partitioning scheme must support the following drawable operations: find(),
 draw(), pick(), collide(), and animate().  In addition, the new partitioning
 specific interface described by this class should be implemented.  The
 {\i ESCH_PARTN_OFF} bit should be checked, and if set, all operations
 should perform dumb walks of all drawables within the partitioning.
\par

Some partitioning mechanisms (such as Binary Space Partitioning trees) are
 not suitable for real-time insertion/deletion operations and as such should
 return {\i ESCH_NOT_SUPPORTED} for the insert(), remove(), and update()
 members.  Another interface mechanism will be required to create and/or
 load the paritition in these cases.
\par

{\cf2
Note:  Drawables inserted into the partitioning should not be placed into
 the drawlist as they are implicitly included by being inserted into the
 partitioning.  Also, to prevent possibly duplicated drawing or results
 from pick/collision operations, a given drawable should not be inserted
 into multiple partitionings unless care is taken to ensure that only
 one such partitioning drawable is actually used for such operations (i.e.,
 you can put a given drawable into multiple partitions, just be sure
 not to use a drawable list which contains more than none of these partition
 drawables).  Some implementations cannot support the same drawable in
 more than one partitioning (they will return {\i ESCH_ERR_REFERENCED}
 as the error for an insert() if this is the case).
}\par

\line{\b\fs28 Name}\par

EschPartition - Base partitioning interface class.
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschPartition();}\par

Performs no initialization.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b const EschPartition &operator = (const EschPartition &prtn);}\par

Copies the data from another partition and clears the owns bits of the
 target.  Any previously owned data is freed.
\par

{\b virtual void release()=0;}\par

Releases all data owned by the partitioning.  If {\i ESCH_DRW_OWNSDATA}
 is set, then all management memory should be released.  If
 {\i ESCH_PARTN_OWNSDRAWS} is set, then all drawables inserted into the
 paritioning should be freed.
\par

{\b virtual esch_error_codes insert(EschDrawable *drw)=0;}\par

Inserts a drawable into the partitioning.  If {\i ESCH_DRW_OWNSDATA} is
 not set, the instances must be freed by some other mechanism.  If
 the drawable cannot be inserted into the partitioning (for example, if it
 doesn't have a spherical extent to provide spatial information) or
 another error occurs, an error code will be returned (see Error Codes).
\par

{\b virtual void remove(EschDrawable *drw)=0;}\par

Removes a drawable from the partitioning.
\par

{\b virtual esch_error_codes traverse(EschTraverse *data) const=0;}\par

This is a generic call-back walk function that can be used for
 application-specific processing of drawables.  The
 {\uldb EschTravere}{\v PG_ESCH_TRAVERSE} structure controls this process.
 If the callback function returns non-zero, then {\i ESCH_ERR_STOPPED}
 is returned.  Otherwise, unless an error occurrs, it will return
 {\i ESCH_ERR_NONE}.
\par

{\b virtual esch_error_codes update(EschDrawable *drw=0)=0;}\par

Indicates that a drawable (or drawables) has moved and the partitioning
 should update its data structures appropriately.  If drw is 0, then all
 drawables should be updated.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_PARTN_OWNSDRAWS}\tab On release() drawables in partitioning should
 be deleted.
 \par

{\i ESCH_PARTN_OFF}\tab If set, then draw(), pick(), and collide() should use
 dumb logic to run through all drawables in the partitioning.
\par

{\cf2
Note:  This bit is useful for determining the performance benefits of
 the partitioning scheme or locating bugs with the partitioning
 implementation.
}\par

\line{\b\fs28 Error Codes}\par

{\i ESCH_ERR_NONE}\tab\tab No error
\par

{\i ESCH_ERR_INVALIDPARMS}\tab Invalid input parameters.
\par

{\i ESCH_ERR_NOMEMORY}\tab Memory allocation failed.
\par

{\i ESCH_ERR_NOTSUPPORTED}\tab Operation not supported.
\par

{\i ESCH_ERR_NOTFOUND}\tab Drawable not found in partition.
\par

{\i ESCH_ERR_STOPPED}\tab\tab Traverse callback function returned a non-zero
 value.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschGridPartition Class                                                   ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_GRIDPARTITION}
${\footnote EschGridPartition Class}
K{\footnote EschGridPartition;
EschGridPartition, init;
EschGridPartition, draw_grid}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschGridPartition Class}\par\pard\sb100

This is an implementation of a simple partitioning scheme.  This scheme
 breaks 3-space into a 2D grid of cells, with a fixed size and number.  Any
 drawables that are either located outside of all cells or across a
 cell border are located in a special 'global' list.  The cells have
 infinite 'height'.
\par

Grid partitioning works well for dynamic objects that must be updated
 frequently due to the low processing overhead of insert/remove/update,
 but no balancing requirements are enforced and a long global list forces
 a constant overhead on all processing which can quickly lose the
 performance benefit for using the partitioning.
\par

The choice of grid width, height, and size is extremely important.  Too
 few cells or too large a size will result in large drawlists within each
 cell which requires many drawables to be checked.  Too many cells
 or too small a size can result in many empty cells which are wasted
 space and processing time as well as a large number of drawables that
 must be placed in the global list.  This is something that must be balanced
 for the specific application and run-time environment.
\par

{\cf2
Note: pick() and traverse() won't operate with a start position outside
 of the grid.
}\par

\line{\b\fs28 Name}\par

EschGridPartition - 2D grid partitioning scheme.
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschPartition}{\v PG_ESCH_PARTITION}
\par

\line{\b\fs28 Constructors}\par

{\b EschGridPartition();}\par

Clears internal pointers.
\par

{\b EschGridPartition(ushort w, ushort d, float s, const EschPoint *o);}\par

Performs init().
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b ushort width, depth;}\par

Width and depth of the 2D grid in number of cells.
\par

{\b float size;\line
ulong sizeshift}\par

World size of each cell (in X and Z--they are infinite in Y).  Must
 be a power of two.
\par

{\b EschPoint origin;}\par

Origin point of grid (Y ignored).
\par

{\b ulong nregions;}\par

Number of regions (computed from width * depth).
\par

{\b EschPartitionList **regions;}\par

Points to 2D array of pointers to drawlists for each cell.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschPartition}{\v PG_ESCH_PARTITION} plus :-
\par

{\b virtual esch_error_codes init(ushort w, ushort d, float s,
 const EschPoint *o);}\par

Initializes the partitioning with the given width 'w', depth 'd', size 's',
 and origin 'o'.  Returns an error code if the setup fails.
\par

{\b void draw_grid(dword clr);}\par

This draws the grid cell outlines using the current drawing context with
 the given color clr.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschQuadTreePartition Class                                               ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_QUADTREEPARTITION}
${\footnote EschQuadTreePartition Class}
K{\footnote EschQuadTreePartition;
EschQuadTreePartition, init;
EschQuadTreePartition, draw_quadtree;
EschQuadTreePartition, compute_stats;
EschQuadTreePartition, set_maxdepth;
EschQuadTreePartition, set_maxcount}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschQuadTreePartition Class}\par\pard\sb100

This is an implementation of a 2D adaptive partitioning scheme that uses
 quadtrees to hierarchically partition space with more subdivision for
 complex areas and fewer subdivisions for empty regions.
\par

The partition starts with a single region in the XZ plane which defines
 the entire area that the quadtree can contain.  Any drawable which crosses
 the boundary or lies outside this "root" region is placed into a global
 list which must be checked by all operations.  As items are inserted,
 the partitioning divides the region into 4 quadrants and places objects
 within the new quadrants.  Drawables which lie on the boundary lines
 of the new quadrants cannot be placed within them and remains at the
 current level.  The level of subdivision is controlled by two parameters:
 {\b maxdepth} controls the maximum tree depth and is always strictly
 enforced and {\b maxcount} controls the desired maximum drawable count
 at any node, but cannot be strictly enforced due to possible violators
 on a quadrant boundary.
\par

The performance of the partitioning is based primarily on how much seperation
 of objects is achieved based on the partition root size, maxdepth,
 maxcount, and relative distribution of drawable objects.  The depth of
 the tree also governs how much overhead is incurred during operations
 on the partition (for example, pick() incurs a ray/box intersection per
 node processed although children of a missed quadrant are skipped).  The
 statistics computation routine may be helpful in deriving the needed
 parameters and initial root size.  Also, be aware that items in the global
 list and objects that violate the quadrant boundaries at high levels in
 the tree are a constant overhead in all processing.
\par

{\cf2
Note: In general, the number of global and high-level violator objects
 will be much smaller for tighter subdivision in a quadtree than in the
 case of the 2D uniform grid partitioning.
}\par

\line{\b\fs28 Name}\par

EschQuadTreePartition - 2D adaptive partitioning scheme.
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschPartition}{\v PG_ESCH_PARTITION}
\par

\line{\b\fs28 Constructors}\par

{\b EschQuadTreePartition();}\par

Clears internal pointers.
\par

{\b EschQuadTreePartition(const EschPoint *o, float w, float d=0);}\par

Performs init().
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b EschQuadTreeNode *root;}\par

This points to the root node of the quadtree.  It is created by init()
 and removed by release().  The structure of the nodes in a quadtree
 is as follows:
\par

\tab{\b float x1, z1, x2, z2;}\line
\tab\tab World-space location of node (x1,z1) - (x2,z2).
\par

\tab{\b ushort depth;}\line
\tab\tab Depth of node in tree (0 is root depth).
\par

\tab{\b ushort count;}\line
\tab\tab Number of drawables in local nodes drawlist.
\par

\tab{\b EschPartitionList *draws;}\line
\tab\tab Linked-list of drawables within node.
\par

\tab{\b EschQuadTreeNode *parent;}\line
\tab\tab Pointer to parent node (NULL if root node).
\par

\tab{\b EschQuadTreeNode *q[4];}\par
\tab\tab Pointer to children quadrants, if any.\line
\tab\tab The coordinates are derived from the current node's\line
\tab\tab coordinates as follows (xm = midpoint in x and zm is\line
\tab\tab midpoint in z): [0] = (x1,z1)-(xm,zm), [1] = (xm,z1)-(x2,zm),\line
\tab\tab [2] = (xm,zm)-(x2,z2), and [3] = (x1,zm)-(xm,z2).
\par

{\b EschPartitionList *global;}\par

Global drawable list for drawables which cross the root node or lie
 outside the quadtree's region.
\par

{\b ushort maxdepth;}\par

Maximum tree depth allowable.  Should be set with set_maxdepth().
\par

{\b ushort maxcount;}\par

Maximum number of drawables in a given node (this cannot be strictly
 enforced, but determines when a subdivision is attempted).  Should be
  set with set_maxcount().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschPartition}{\v PG_ESCH_PARTITION} plus :-
\par

{\b virtual esch_error_codes init(const EschPoint *o, float w, float d=0);}\par

Initializes the quadtree, creating the root node starting at point 'o' and
 of size 'w' units in x and 'd' units in z.  If 'd' is zero, then 'w'
 is used for the units in x and z (square region).
\par

{\b void draw_quadtree(dword clr);}\par

This draws the quadtree node outlines using the current drawing context with
 the given color clr.
\par

{\b void compute_stats(EschQuadTreeStats *stats) const;}\par

Gathers statistics about the current state of the quadtree.  The statistics
 gathered are as follows:
\par

\tab{\b ushort hidepth;}\line
\tab\tab Depth of deepest node in quadtree.
\par

\tab{\b ushort hicount;}\line
\tab\tab Highest count in any node.
\par

\tab{\b ulong nodes;}\par
\tab\tab Number of nodes in tree.
\par

\tab{\b ulong leaves;}\par
\tab\tab Number of leaf nodes in tree (nodes without children).
\par

\tab{\b ulong items;}\par
\tab\tab Sum of all node counts in tree.
\par

\tab{\b ulong items_nonleaf;}\par
\tab\tab Sum of all nonleaf node counts in tree (nodes with children).
\par

\tab{\b ulong items_global;}\par
\tab\tab Number of items in global list.
\par

{\b void set_maxdepth(ushort m);}\par

Sets the value of maxdepth.
\par

{\b void set_maxcount(ushort m);}\par

Sets the value of maxcount.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschOctTreePartition Class                                                ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_OCTTREEPARTITION}
${\footnote EschOctTreePartition Class}
K{\footnote EschOctTreePartition;
EschOctTreePartition, init;
EschOctTreePartition, draw_octtree;
EschOctTreePartition, compute_stats;
EschOctTreePartition, set_maxdepth;
EschOctTreePartition, set_maxcount}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschOctTreePartition Class}\par\pard\sb100

This is an implementation of a 3D adaptive partitioning scheme that uses
 octtrees to hierarchically partition space with more subdivision for
 complex areas and fewer subdivisions for empty volumes.
\par

The operation of an octtree is similiar to the quadtree as implemented
 in {\uldb EschQuadTreePartition}{\v PG_ESCH_QUADTREEPARTITION} except
 that octants are used instead of quadrants and nodes are volumes
 rather than regions.  The controls and behavior are the same except
 with respect to the processing of the extra (Y) dimension.
\par

\line{\b\fs28 Name}\par

EschOctTreePartition - 3D adaptive partitioning scheme.
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschPartition}{\v PG_ESCH_PARTITION}
\par

\line{\b\fs28 Constructors}\par

{\b EschOctTreePartition();}\par

Clears internal pointers.
\par

{\b EschOctTreePartition(const EschPoint *o, float w, float h=0, float d=0);}\par

Performs init().
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b EschOctTreeNode *root;}\par

This points to the root node of the octtree.  It is created by init()
 and removed by release().  The structure of the nodes in a octtree
 is as follows:
\par

\tab{\b float x1, y1, z1, x2, y2, z2;}\line
\tab\tab World-space location of node (x1,y2,z1) - (x2,y2,z2).
\par

\tab{\b ushort depth;}\line
\tab\tab Depth of node in tree (0 is root depth).
\par

\tab{\b ushort count;}\line
\tab\tab Number of drawables in local nodes drawlist.
\par

\tab{\b EschPartitionList *draws;}\line
\tab\tab Linked-list of drawables within node.
\par

\tab{\b EschOctTreeNode *parent;}\line
\tab\tab Pointer to parent node (NULL if root node).
\par

\tab{\b EschOctTreeNode *q[8];}\par
\tab\tab Pointer to children octants, if any.\line
\tab\tab The coordinates are derived from the current node's\line
\tab\tab coordinates as follows (xm = midpoint in x, ym is the\line
\tab\tab midpoint in y and zm is midpoint in z):\line
\tab\tab [0] = (x1,y1,z1)-(xm,ym,zm), [1] = (xm,y1,z1)-(x2,ym,zm),\line
\tab\tab [2] = (xm,y1,zm)-(x2,ym,z2), [3] = (x1,y1,zm)-(xm,ym,z2),\line
\tab\tab [4] = (x1,ym,z1)-(xm,y2,zm), [5] = (xm,ym,z1)-(x2,y2,zm),\line
\tab\tab [6] = (xm,ym,zm)-(x2,y2,z2), and [7] = (x1,ym,zm)-(xm,y2,z2).
\par

{\b EschPartitionList *global;}\par

Global drawable list for drawables which cross the root node or lie
 outside the octtree's volume.
\par

{\b ushort maxdepth;}\par

Maximum tree depth allowable.  Should be set with set_maxdepth().
\par

{\b ushort maxcount;}\par

Maximum number of drawables in a given node (this cannot be strictly
 enforced, but determines when a subdivision is attempted).  Should be
  set with set_maxcount().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschPartition}{\v PG_ESCH_PARTITION} plus :-
\par

{\b virtual esch_error_codes init(const EschPoint *o, float w, float h=0,
 float d=0);}\par

Initializes the octtree, creating the root node starting at point 'o' and
 of size 'w' units in x, 'h' units in y, and 'd' units in z.  If 'h' or 'd'
 is zero, then 'w' is used for the value (a cube is formed if only w is
 non-zero).
\par

{\b void draw_octtree(dword clr);}\par

This draws the octtree node outlines using the current drawing context with
 the given color clr.
\par

{\b void compute_stats(EschOctTreeStats *stats) const;}\par

Gathers statistics about the current state of the octtree.  The statistics
 gathered are as follows:
\par

\tab{\b ushort hidepth;}\line
\tab\tab Depth of deepest node in octtree.
\par

\tab{\b ushort hicount;}\line
\tab\tab Highest count in any node.
\par

\tab{\b ulong nodes;}\par
\tab\tab Number of nodes in tree.
\par

\tab{\b ulong leaves;}\par
\tab\tab Number of leaf nodes in tree (nodes without children).
\par

\tab{\b ulong items;}\par
\tab\tab Sum of all node counts in tree.
\par

\tab{\b ulong items_nonleaf;}\par
\tab\tab Sum of all nonleaf node counts in tree (nodes with children).
\par

\tab{\b ulong items_global;}\par
\tab\tab Number of items in global list.
\par

{\b void set_maxdepth(ushort m);}\par

Sets the value of maxdepth.
\par

{\b void set_maxcount(ushort m);}\par

Sets the value of maxcount.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschStarfield Class                                                       ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_STARFIELD}
${\footnote EschStarfield Class}
K{\footnote EschStarfield;
EschStarfield, operator =;
EschStarfield, draw;
EschStarfield, release;
EschStarfield, set_color;
EschStarfield, create_stars}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschStarfield Class}\par\pard\sb100

Draws a space 'starfield' as a collection of colored points.  This drawable
 can simulate movement at 'sublight' speeds, where translation of the
 camera has no effect on the stars' position, and at 'faster-than-light'
 speeds where translation changes the apparent location of the stars'
 position.  The stars may also have varying brightness levels.
\par

Star are drawn as points at their given world coordinates, but they are not
 clipped by the yon plane.  Stars are always drawn with the furthest
 Z-buffer value possible.
\par

{\cf3 {\i Van Gogh} does not have a perspective version of pixel, so
 {\i ESCH_CAM_PERSPECTIVE} currently has no effect.}\par

\line{\b\fs28 Name}\par

EschStarfield - Space 'starfield' drawable
\par

\line{\b\fs28 Synopsis}\par

#include "esmisc.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschStarfield();}\par

Sets the data array pointers to null.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschParticle}{\v PG_ESCH_PARTICLE} plus :-
\par

{\b ulong count;}\par

Number of values in stars/brightness array.
\par

{\b EschPoint *stars;}\par

Data array of star locations.
\par

{\b dword *brightness;}\par

Optional data array of star brightnesses (shade-level).  If null, then
 all stars are drawn at full brightness.
\par

{\b dword color;}\par

Color of the stars ({\i Van Gogh} color format).  Should be set
 by set_color().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b const EschStarfield &operator = (const EschStarfield &sf);}\par

Copies the data from another starfield, but does not copy the linked-list
 pointers or run-time type value and clears the owns bit of the
 target.  Any previously owned data is freed.
\par

{\b virtual void draw();}\par

Draws the starfield.  If {\i ESCH_SFLD_FTL} is set, then translation of
 the camera will change the apparent location of the points.  Otherwise,
 only rotation changes the apparent locations.
\par

{\b virtual void release();}\par

Frees the data array(s), if any, if the {\i ESCH_DRW_OWNSDATA} bit is set.
\par

{\b void set_color();}\par

Sets the color of the stars.
\par

{\b esch_error_codes create_stars(ulong c, int dobrights=1);}\par

Creates a random database of stars, releasing any previous data.  If
 dobrights is set, then a random brightness value is chosen for
 each star.  {\i ESCH_DRW_OWNSDATA} is set by this routine if successful.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschPlosion Class                                                         ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PLOSION}
${\footnote EschPlosion Class}
K{\footnote EschPlosion;
EschPlosion, draw;
EschPlosion, animate;
EschPlosion, get_position;
EschPlosion, set_position;
EschPlosion, set_top;
EschPlosion, set_direction;
EschPlosion, rotatex;
EschPlosion, rotatey;
EschPlosion, rotatez;
EschPlosion, rotate;
EschPlosion, pitch;
EschPlosion, roll;
EschPlosion, yaw;
EschPlosion, translate;
EschPlosion, move;
EschPlosion, scale;
EschPlosion, orthogonalize;
EschPlosion, orthogonalize_top;
EschPlosion, orthogonalize_right;
EschPlosion, set_size;
EschPlosion, set_fire;
EschPlosion, set_step;
EschPlosion, reset;
EschPlosion, set_alpha;
EschPlosion, get_alpha}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschPlosion Class}\par\pard\sb100

This draws an animated explosion effect using the
 {\uldb EschFireTexture}{\v PG_ESCH_FIRETEXTURE} texture.  The animation
 of the fire texture is both through the dynamic nature of the procedural
 texture and by dynamic adjustment of the texturing parameters.  The
 standard form draws as two intersecting trapezoids, although variations
 on this polygon 'tree' are also available.
\par

{\cf2
Note:  For performance reasons, you will probably want all {\b EschPlosion}
 instances to share the same instance of {\b EschFireTexture}.  Because
 of the differences in the texturing parameters over time, it is unlikely
 that two explosions started at different times will appear exactly
 the same.
}\par

\line{\b\fs28 Name}\par

EschPlosion - Explosion drawable
\par

\line{\b\fs28 Synopsis}\par

#include "esmisc.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschPlosion();}\par

Initializes the internal data.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschParticle}{\v PG_ESCH_PARTICLE} plus :-
\par

{\b EschFrameRef world;}\par

This provides the frame-of-reference for drawing the explosion polygons
 which are created interally in local coordinates.
\par

{\b float width, height;}\par

Determines the size of the explosion.  Should be set by set_size().
\par

{\b long alpha_level;}\par

This is the alpha-level used on the polygonal faces of the explosion
 (255 is opaque, 0 is transparent).
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b virtual void draw();}\par

Draws the explosion as intersecting trapezoids.
\par

{\b virtual void animate();}\par

This animates the associated fire texture (if the {\i ESCH_TXT_SKIPANIMATE}
 bit is not set) and then adjusts the texture parameter by the 'step'
 value to reduce the explosion size.
\par

{\b void get_position(EschPoint *p) const;}\par

Gets the position of the base of the explosion.
\par

{\b set_position(float ix, float iy, float iz, dword update=ESCH_UPD_ALL);\line
void set_position(const EschPoint *pnt, dword update=ESCH_UPD_ALL);}\par

Sets the position of the base of the explosion.
\par

{\b void set_top(const EschVector *v, dword update=ESCH_UPD_ALL);\line
void set_top(float ii, float ij, float ik, dword update=ESCH_UPD_ALL);}\par

Sets the 'up' vector for the explosion.
\par

{\b void set_direction(const EschVector *v, dword update=ESCH_UPD_ALL);\line
void set_direction(float ii, float ij, float ik, dword update=ESCH_UPD_ALL);}\par

Sets the 'forward' vector for the explosion.
\par

{\b void rotatex(const float degrees, dword update=ESCH_UPD_ALL);\line
void rotatey(const float degrees, dword update=ESCH_UPD_ALL);\line
void rotatez(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends an X/Y/Z-axis rotation to the world frame-of-reference.
\par

{\b void rotate(const EschVector *v, const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about an arbitrary axis to the orientation
 matrix and updates the direction vector and inverse information.
\par

{\b void pitch(const float degrees, dword update=ESCH_UPD_ALL);\line
void roll(const float degrees, dword update=ESCH_UPD_ALL);\line
void yaw(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about the frame's current X/Z/Y axis and
 updates the direction vector and inverse information.
\par

{\b void translate(const float idx, const float idy, const float idz, dword update=ESCH_UPD_ALL);\line
void translate(const EschVector *v, dword update=ESCH_UPD_ALL);}\par

Appends a translation to the world frame-of-reference.
\par

{\b void move(const float idx, const float idy, const float idz, dword update=ESCH_UPD_ALL);\line
void move(const EschVector *v, dword update=ESCH_UPD_ALL);}\par

Appends a translation to the world frame-of-reference defined in
 the local coordinates along the local I, J, and K axis.
\par

{\b void scale(float is, dword update=ESCH_UPD_ALL);}\par

Appends a scale to the world frame-of-reference of the object.
\par

{\b void orthogonalize(dword update=ESCH_UPD_ALL);\line
void orthogonalize_top(dword update=ESCH_UPD_ALL);\line
void orthogonalize_right(dword update=ESCH_UPD_ALL);}\par

Forces the orientation components of the frame-of-reference into
 an orthonormal basis to remove accumulated errors from rotations.  It
 will then update the inverse.  The standard version uses the direction
 vector as the first basis (the first basis is only normalized by the
 process), then the 'top' vector, and finally the 'right'.  The _top
 version uses the 'top' vector as the first basis, then the direction
 vector, and finally the 'right' vector.  The _right version uses the
 'right' vector as the first basis, then the direction vector, and
 finally the 'top' vector.
\par

{\b void set_size(float w, float h);}\par

Sets the size of the explosion.
\par

{\b void set_fire(EschFireTexture *f);}\par

This provides a pointer to the required fire texture.  It is not owned
 by the drawable.
\par

{\b void set_step(float i);}\par

This sets the step by which to adjust the explosion texture parameters
 on each call to animate().  The parameter ranges from 1 (full size) to
 0.2 (minimum size).
\par

{\b void reset();}\par

This resets the texture parameter to 1 (full).
\par

{\b void set_alpha(long alpha);\line
long get_alpha();}\par

Sets/gets the alpha_level value where 0 is transparent and 255 is opaque.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_PLSN_CIRCULAR}\tab If this bit is set, then the explosion is
 drawn as a 'circular' explosion instead of being directed 'upwards'.
\par

{\i ESCH_PLSN_TRIANGULAR}\tab If this bit is set, then the explosion is
 drawn with a pointed bottom, instead of the default trapizoidal shape.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschMetabox Class                                                         ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_METABOX}
${\footnote EschMetabox Class}
K{\footnote EschMetabox;
EschMetabox, draw;
EschMetabox, animate;
EschMetabox, release;
EschMetabox, get_position;
EschMetabox, set_position;
EschMetabox, set_top;
EschMetabox, set_direction;
EschMetabox, rotatex;
EschMetabox, rotatey;
EschMetabox, rotatez;
EschMetabox, rotate;
EschMetabox, pitch;
EschMetabox, roll;
EschMetabox, yaw;
EschMetabox, translate;
EschMetabox, move;
EschMetabox, scale;
EschMetabox, orthogonalize;
EschMetabox, orthogonalize_top;
EschMetabox, orthogonalize_right;
EschMetabox, reset;
EschMetabox, set_color;
EschMetabox, set_texture;
EschMetabox, set_texture_uv;
EschMetabox, create_cube;
EschMetabox, set_alpha;
EschMetabox, get_alpha}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschMetabox Class}\par\pard\sb100

This is a parameterized version of a cube drawable where the 8 connected
 points can be adjusted to create a variety of shapes (truncated pyramids,
 cubes, boxes, etc.).
\par

The corners of the metacube are provided in local coordinates and the
 flags {\i ESCH_MBOX_} control which faces of the cube are drawn.  The
 corner order is: [0] = (-x,+y,-z), [1] = (+x,+y,-z), [2] = (+x,+y,+z),
 [3] = (-x,+y,+z), [4] = (-x,-y,-z), [5] = (+x,-y,-z), [6] = (+x,-y,+z),
 [7] = (-x,-y,+z).
\par

\line{\b\fs28 Name}\par

EschMetabox - Parameterized cube drawable
\par

\line{\b\fs28 Synopsis}\par

#include "esmisc.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschMetabox();}\par

Clears the texture pointers.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b protected long alpha_level;}\par

The alpha level for the cube (255 is opaque, 0 is transparent).
\par

{\b EschFrameRef world;}\par

Frame-of-referenced for converting local coordinates of the cube into
 world coordinates.
\par

{\b EschPoint corner[8];}\par

Local coordinates of the corners of the cube.
\par

{\b dword color[6];}\par

Color of the six faces of the cube (indexed by {\i ESCH_MBOX_FACE_TOP,
 ESCH_MBOX_FACE_BOTTOM, ESCH_MBOX_FACE_FRONT, ESCH_MBOX_FACE_BACK,
 ESCH_MBOX_FACE_LEFT, and ESCH_MBOX_FACE_RIGHT}).  Should be set
 by set_color().
\par

{\b EschTexture *txt[6];}\par

Texture (if any) for the six faces of the cube (indexed by
 {\i ESCH_MBOX_FACE_TOP, ESCH_MBOX_FACE_BOTTOM, ESCH_MBOX_FACE_FRONT,
 ESCH_MBOX_FACE_BACK, ESCH_MBOX_FACE_LEFT, and ESCH_MBOX_FACE_RIGHT}).
 Should be set by set_texture().
\par

{\b float u[4];\line
float v[4];}\par

The U,V texture mapping coordinates for the 4 corners of each face.
 Should be set by set_texture_uv().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b const EschMetabox &operator = (const EschMetabox &that);}\par

Copy constructor that ensures that old data is released, if needed.
\par

{\b virtual void draw();}\par

Draws the cube using the current context.
\par

{\b virtual void animate();}\par

Animates any associated textures.
\par

w{\b virtual void release();}\par

Releases any associated textures that are owned by the instance.
\par

{\b void get_position(EschPoint *p) const;}\par

Gets the position of the center of the cube.
\par

{\b set_position(float ix, float iy, float iz, dword update=ESCH_UPD_ALL);\line
void set_position(const EschPoint *pnt, dword update=ESCH_UPD_ALL);}\par

Sets the position of the center of the cube.
\par

{\b void set_top(const EschVector *v, dword update=ESCH_UPD_ALL);\line
void set_top(float ii, float ij, float ik, dword update=ESCH_UPD_ALL);}\par

Sets the 'up' vector for the cube.
\par

{\b void set_direction(const EschVector *v, dword update=ESCH_UPD_ALL);\line
void set_direction(float ii, float ij, float ik, dword update=ESCH_UPD_ALL);}\par

Sets the 'forward' vector for the cube.
\par

{\b void rotatex(const float degrees, dword update=ESCH_UPD_ALL);\line
void rotatey(const float degrees, dword update=ESCH_UPD_ALL);\line
void rotatez(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends an X/Y/Z-axis rotation to the world frame-of-reference.
\par

{\b void rotate(const EschVector *v, const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about an arbitrary axis to the orientation
 matrix and updates the direction vector and inverse information.
\par

{\b void pitch(const float degrees, dword update=ESCH_UPD_ALL);\line
void roll(const float degrees, dword update=ESCH_UPD_ALL);\line
void yaw(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about the frame's current X/Z/Y axis and
 updates the direction vector and inverse information.
\par

{\b void translate(const float idx, const float idy, const float idz, dword update=ESCH_UPD_ALL);\line
void translate(const EschVector *v, dword update=ESCH_UPD_ALL);}\par

Appends a translation to the world frame-of-reference.
\par

{\b void move(const float idx, const float idy, const float idz, dword update=ESCH_UPD_ALL);\line
void move(const EschVector *v, dword update=ESCH_UPD_ALL);}\par

Appends a translation to the world frame-of-reference defined in
 the local coordinates along the local I, J, and K axis.
\par

{\b void scale(float is, dword update=ESCH_UPD_ALL);}\par

Appends a scale to the world frame-of-reference of the object.
\par

{\b void orthogonalize(dword update=ESCH_UPD_ALL);\line
void orthogonalize_top(dword update=ESCH_UPD_ALL);\line
void orthogonalize_right(dword update=ESCH_UPD_ALL);}\par

Forces the orientation components of the frame-of-reference into
 an orthonormal basis to remove accumulated errors from rotations.  It
 will then update the inverse.  The standard version uses the direction
 vector as the first basis (the first basis is only normalized by the
 process), then the 'top' vector, and finally the 'right'.  The _top
 version uses the 'top' vector as the first basis, then the direction
 vector, and finally the 'right' vector.  The _right version uses the
 'right' vector as the first basis, then the direction vector, and
 finally the 'top' vector.
\par

{\b void reset();}\par

Resets the world frame-of-reference.
\par

{\b void set_color(dword clr, int face = -1);}\par

Sets the color for a particular face or all faces if no specific
 {\i ESCH_MBOX_FACE_} value is passed in the 'face' parameter.
\par

{\b void set_texture(EschTexture *t, int face = -1);}\par

Sets the texture for a particular face or all faces if no specific
 {\i ESCH_MBOX_FACE_} value is passed in the 'face' parameter.
\par

{\b void set_texture_uv(float u1, float v1, float u2, float v2,
 float u3, float v3, float u4, float v4);}\par

Sets the U, V texture-mapping parameters used for all faces.
\par

{\b void create_cube(float size);}\par

Sets the corner values such that they create a cube of the given size that
 is axis-aligned in local coordinates.
\par

{\b void set_alpha(long alpha);\line
long get_alpha();}\par

Sets/gets the alpha_level value where 0 is transparent and 255 is opaque.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_MBOX_TOP\line
ESCH_MBOX_BOTTOM\line
ESCH_MBOX_FRONT\line
ESCH_MBOX_BACK\line
ESCH_MBOX_LEFT\line
ESCH_MBOX_RIGHT}\tab If set, the given face is drawn.  If clear, that face
 is skipped.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschLevelOfDetail Class                                                   ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_LOD}
${\footnote EschLevelOfDetail Class}
K{\footnote EschLevelOfDetail;
EschLevelOfDetail, operator =;
EschLevelOfDetail, release;
EschLevelOfDetail, add;
EschLevelOfDetail, set_nlevels;
EschLevelOfDetail, set_current;
EschLevelOfDetail, set_color;
EschLevelOfDetail, set_dist}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschLevelOfDetail Class}\par\pard\sb100

This is a helper class for managing a set of
 {\uldb EschGeometry}{\v PG_ESCH_GEOMETRY} class instances that respresent
 multiple levels of detail for a single object.  An instance of this
 class is given ownership of the geometry instances in order of highest
 to lowest detail with a color given for drawing a single colored point
 beyond the maximum level of detail.  This class is then inserted
 into the drawlist or partitioning.
\par

The application is responsible for keeping the geometry instances updated
 for their proper position and keep any children objects oriented correctly.
 To help with this, the class does not change levels of detail automatically,
 which allows the application to detect a change of detail level, switch
 the current level and update the geometry instance correctly.  An automatic
 switch mode is included for completeness.
\par

The level of detail is chosen based on the Z distance in view coordinates
 of the current geometry instance and the cut-off values in the 'dist'
 static array.  All level-of-detail instances in the system must share
 cut-off values, so the number of detail levels should be kept identical.
 If the level of detail cut-off results in a higher level of detail
 than the number in 'nlevels', a color pixel is drawn at the location of
 the current instance.
\par

\line{\b\fs28 Name}\par

EschLevelOfDetail - Helper class for multiple levels of detail.
\par

\line{\b\fs28 Synopsis}\par

#include "esmisc.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

{\b EschLevelOfDetail();}\par

Clears pointers.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b ushort nlevels;}\par

Number of levels of detail in the current instance.  Should
 be set by set_nlevels().
\par

{\b ushort current;}\par

Current level of detail.  Should be set by set_current().
\par

{\b ushort change;}\par

If {\i ESCH_LOD_AUTOSWITCH} is not set, this is set to the level of detail
 desired as of the last call to draw().
\par

{\b ushort na;}\par

Reserved for padding.
\par

{\b dword color;}\par

Color in {\i Van Gogh}'s standard color format for drawing the pixel
 representation if beyond the highest level of detail.  Should be
 set by set_color().
\par

{\b EschGeometry *geom[ESCH_LOD_MAX_LEVELS];}\par

Points to the geometry instances for each level of detail.
\par

{\b static float dist[ESCH_LOD_MAX_LEVELS];}\par

Contains the cut-off values for each level of detail (with dist[i] being
the cut-off value after which level i+1 is used).  Should be set by
set_dist().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

{\b const EschLevelOfDetail &operator = (const EschLevelOfDetail &that);}\par

Copy constructor that ensures that old data is released, if needed.
\par

{\b virtual void release();}\par

Releases geometry instances if {\i ESCH_DRW_OWNSDATA} is set.
\par

{\b int add(EschGeometry *g);}\par

Adds a geometry instance as the next lower level of detail.  Returns 0
 if successful and non-zero otherwise.
\par

{\b void set_nlevels(ushort n);}\par

Sets the number of levels.
\par

{\b void set_current(ushort n);}\par

Sets the current level of detail.
\par

{\b void set_color(dword c);}\par

Sets the color for the pixel representation at greater than maximum
 detail level.
\par

{\b static void set_dist(ushort lvl, float d);}\par

Sets the z value for the given level of detail cut-off.
\par

\pard\page



{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°° Drawable Support Structures °°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschCollision Structure                                                   ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_COLLISION}
${\footnote EschCollision Structure}
K{\footnote EschCollision}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschCollision Structure}\par\pard\sb100

This structure is used for communicating with the
 {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} collide member.  All input
 parameters and output data is conveyed via this structure.
\par

\line{\b\fs28 Name}\par

EschCollision - Collision detection interface communication structure.
\par

\line{\b\fs28 Synopsis}\par

#include "esdraw.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschCollision();}\par

Clears the 'flags' member.
\par

{\b EschCollision(EschDrawable *i, ulong mcount=1);}\par

Sets flags to have {\i ESCH_CLSN_ILIST} and {\i ESCH_CLSN_MAXCOUNT} set,
 and sets 'ilist' equal to i and 'maxcount' equal to mcount.
\par

\line{\b\fs28 Data}\par

{\b dword flags;}\par

Control flags for the collision operation (see {\b Flags} below).
\par

{\b ulong count;}\par

This is the number of result items in the 'result' draw list.
\par

{\b EschDrawList *result;}\par

This is the linked-list of result items found during the collision
 detection.  They are allocated out of the arena specified on input
 (see {\uldb EschDrawList}{\v PG_ESCH_DRAWLIST}).
\par

{\b EschDrawable *ilist;}\par

This is the input list of drawables to test against.  If the
 {\i ESCH_CLSN_ILIST} bit is not set in 'flags', then this member is ignored
 and the drawable list from the current context is used (see
 {\uldb EschContext}{\v PG_ESCH_CONTEXT}).
\par

{\b IvoryArena *arena;}\par

This is the arena to use for allocating the result draw list structures.
 If the {\i ESCH_CLSN_ARENA} bit is not set in 'flags', then the system
 arena is cleared then used for the allocating the results (see
 {\uldb EschSystem}{\v PG_ESCH_SYSTEM}).  Otherwise, the user is
 responsible for clearing the arena when the result list is no longer
 needed.
\par

{\cf2
Note:  If the system arena is used, then the result list is only valid
 until the next {\i Escher} collide(), pick(), or draw() call is made since
 these routines will clear the system arena for their own use.
}\par

{\b ulong maxcount;}\par

This is the maximum number of items to place into the result list.  If
 the {\i ESCH_CLSN_MAXCOUNT} bit is not set in 'flags', this is set to
 1.
\par

{\b EschSphereExtents sphere;}\par

This is the world coordinate spherical extent against which the collision
 is tested.  This is overwritten with the extents of the drawable which
 is first called (i.e., doesn't have NOSETUP set), if {\i ESCH_CLSN_SPHERE}
 is not set.
\par

{\b EschDrawable *orig;}\par

This is a pointer to the 'this' pointer of the original drawable whose
 collide member was called.  This drawable should not be collided with
 since the result would be itself.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_CLSN_NOSETUP}\tab Indicates that the routine should not check
 the control flags and setup the structure (internal use only).
\par

{\i ESCH_CLSN_NOWALK}\tab\tab Indicates the routine should not walk the
 input list of drawables, calling collide for each (internal use only).
\par

{\i ESCH_CLSN_TESTSELF}\tab Indicates the routine should test the
 current drawable for collision (internal use only).
\par

{\i ESCH_CLSN_ILIST}\tab\tab Set if 'ilist' is pointing to a valid list on
 input.  Otherwise the current context list is set into 'ilist'.
\par

{\i ESCH_CLSN_ARENA}\tab\tab Set if 'arena' is pointing to a valid arena on
 input.  Otherwise the system arena is set into 'arena'.
\par

{\i ESCH_CLSN_MAXCOUNT}\tab Set if 'maxcount' is valid.  Otherwise 1 is
 set into 'maxcount'.
\par

{\i ESCH_CLSN_COARSE}\tab\tab Set if only 'coarse' hit tests should be used.
\par

{\i ESCH_CLSN_SPHERE}\tab\tab Set if 'sphere' is already valid and used
 as the collision target.  Otherwise, the extents of the drawable first
 called will be used.
\par

{\i ESCH_CLSN_APP0} -\line
{\i ESCH_CLSN_APP7}\tab Reserved for use by the application.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschPicking Structure                                                     ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PICKING}
${\footnote EschPicking Structure}
K{\footnote EschPicking}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschPicking Structure}\par\pard\sb100

This structure is used for communicating with the
 {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} pick member.  All input
 parameters and output data is conveyed via this structure.
\par

\line{\b\fs28 Name}\par

EschPicking - Picking interface communication structure.
\par

\line{\b\fs28 Synopsis}\par

#include "esdraw.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschPicking();}\par

Clears the 'flags' member.
\par

{\b EschPicking(EschCamera *cam, long x, long y, EschDrawble *i,
 ulong mcount=1);}\par

Sets flags to have {\i ESCH_PICK_ILIST}, {\i ESCH_PICK_MAXCOUNT},
 {\i ESCH_PICK_CAMERA}, and {\i ESCH_PICK_VPORT} set.  It also sets 'sx'
 equal to x, 'sy 'equal to y, 'ilist' equal to i, and 'maxcount' equal to
 mcount.
\par

{\b EschPicking(EschCamera *cam, long x, long y, EschDrawble *i,
 float maxd, ulong mcount);}\par

Sets flags to have {\i ESCH_PICK_ILIST}, {\i ESCH_PICK_MAXCOUNT},
 {\i ESCH_PICK_CAMERA}, {\i ESCH_PICK_VPORT}, and {\i ESCH_PICK_MAXDIST} set.
 It also sets 'sx' equal to x, 'sy 'equal to y, 'ilist' equal to i,
 'maxdist' equal to maxd, and 'maxcount' equal to mcount.
\par

{\b EschPicking(EschPoint &s, EschVector &dir, EschDrawble *i, ulong mcount=1);}\par

Sets flags to have {\i ESCH_PICK_ILIST}, {\i ESCH_PICK_MAXCOUNT},
 and {\i ESCH_PICK_WORLD} set.  It also sets 'start' equal to s,
 'direction' equal to dir, 'ilist' equal to i, and 'maxcount'
 equal to mcount.
\par

{\b EschPicking(EschPoint &s, EschVector &dir, EschDrawble *i,
 float maxd, ulong mcount);}\par

Sets flags to have {\i ESCH_PICK_ILIST}, {\i ESCH_PICK_MAXCOUNT},
 {\i ESCH_PICK_WORLD}, and {\i ESCH_PICK_MAXDIST} set.  It also sets
 'start' equal to s, 'direction' equal to dir, 'ilist' equal to i,
 'maxdist' equal to maxd, and 'maxcount' equal to mcount.
\par

\line{\b\fs28 Data}\par

{\b dword flags;}\par

Control flags for the picking operation (see {\b Flags} below).
\par

{\b ulong count;}\par

This is the number of result items in the 'result' draw list.
\par

{\b EschDrawList *result;}\par

This is the linked-list of result items found during the picking
 detection.  They are allocated out of the arena specified on input
 (see {\uldb EschDrawList}{\v PG_ESCH_DRAWLIST}).
\par

{\b EschDrawable *ilist;}\par

This is the input list of drawables to test against.  If the
 {\i ESCH_PICK_ILIST} bit is not set in 'flags', then this member is ignored
 and the drawable list from the current context is used (see
 {\uldb EschContext}{\v PG_ESCH_CONTEXT}).
\par

{\b IvoryArena *arena;}\par

This is the arena to use for allocating the result draw list structures.
 If the {\i ESCH_PICK_ARENA} bit is not set in 'flags', then the system
 arena is cleared then used for the allocating the results (see
 {\uldb EschSystem}{\v PG_ESCH_SYSTEM}).  Otherwise, the user is
 responsible for clearing the arena when the result list is no longer
 needed.
\par

{\cf2
Note:  If the system arena is used, then the result list is only valid
 until the next {\i Escher} collide(), pick(), or draw() call is made since
 these routines will clear the system arena for their own use.
}\par

{\b ulong maxcount;}\par

This is the maximum number of items to place into the result list.  If
 the {\i ESCH_PICK_MAXCOUNT} bit is not set in 'flags', this is set to
 1.
\par

{\b ulong sx, sy;}\par

Camera viewport screen coordinates to use for picking if {\i ESCH_PICK_VPORT}
 is set.
\par

{\b EschCamera *camera;}\par

Camera is use for computing pick ray if {\i ESCH_PICK_VPORT} is set.  If
 {\i ESCH_PICK_CAMERA} bit is not set in 'flags', then this member is ignored
 and the camera from the current context is used (see
 {\uldb EschContext}{\v PG_ESCH_CONTEXT}).
\par

{\b EschPoint point;}\par

Picking ray starting point.  This is overwritten if {\i ESCH_PICK_VPORT}
 is set.  Otherwise, {\i ESCH_PICK_WORLD} must be set and the 'direction'
 member is also assumed to be valid on input.
\par

{\b EschVector direction;}\par

Picking ray direction.  This is overwritten if {\i ESCH_PICK_VPORT}
 is set.  Otherwise, {\i ESCH_PICK_WORLD} must be set and the 'point'
 member is also assumed to be valid on input.
\par

{\b float maxdist;}\par

This is the maximum distance desired for picking distance along the ray.
 This is ignored if {\i ESCH_PICK_MAXDIST} is not set.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_PICK_NOSETUP}\tab Indicates that the routine should not check
 the control flags and setup the structure (internal use only).
\par

{\i ESCH_PICK_NOWALK}\tab\tab Indicates the routine should not walk the
 input list of drawables, calling collide for each (internal use only).
\par

{\i ESCH_PICK_TESTSELF}\tab Indicates the routine should test the
 current drawable for picking (internal use only).
\par

{\i ESCH_PICK_ILIST}\tab\tab Set if 'ilist' is pointing to a valid list on
 input.  Otherwise the current context list is set into 'ilist'.
\par

{\i ESCH_PICK_ARENA}\tab\tab Set if 'arena' is pointing to a valid arena on
 input.  Otherwise the system arena is set into 'arena'.
\par

{\i ESCH_PICK_MAXCOUNT}\tab Set if 'maxcount' is valid.  Otherwise 1 is
set into 'maxcount'.
\par

{\i ESCH_PICK_COARSE}\tab\tab Set if only 'coarse' hit tests should be used.
\par

{\i ESCH_PICK_APP0} -\line
{\i ESCH_PICK_APP7}\tab Reserved for use by the application.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschDrawList Structure                                                    ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_DRAWLIST}
${\footnote EschDrawList Structure}
K{\footnote EschDrawList}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschDrawList Structure}\par\pard\sb100

This support structure is used to link the results into a list for return
 from picking and collision {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
 routines.  All instances of this structure are created in an arena, so they
 do not need to be freed individually.
\par

\line{\b\fs28 Name}\par

EschDrawList - Interface linked-list container object.
\par

\line{\b\fs28 Synopsis}\par

#include "esdraw.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschPartitionList();}\par

Performs no initialization.
\par

{\b EschPartitionList(EschDrawable *_item);}\par

Initializes item pointer and clears link pointers.
\par

\line{\b\fs28 Data}\par

{\b EschDrawable *item;}\par

Points to a drawable in the result list.
\par

{\b EschDrawList *next;}\par

Points to the next draw list result structure or 0 if this is the last
 item in the list.
\par

{\b float dist;}\par

This is the picking distance of the item along the pick ray if the structure
 is created by the picking interface, which creates the result list in
 sorted order, closest to furthest.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschPartitionList Structure                                               ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PARTITIONLIST}
${\footnote EschPartitionList Structure}
K{\footnote EschPartitionList}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschPartitionList Structure}\par\pard\sb100

This support structure is used internally by
 {\uldb EschPartition}{\v PG_ESCH_PARTITION}-derived classes to
 create lists of drawables without using internal links.
\par

\line{\b\fs28 Name}\par

EschPartitionList - Partitioning internal linked-list container object.
\par

\line{\b\fs28 Synopsis}\par

#include "espartn.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschPartitionList();}\par

Performs no initialization.
\par

{\b EschPartitionList(EschDrawable *_item);}\par

Clears the link pointers and sets the item pointer.
\par

\line{\b\fs28 Data}\par

{\b EschDrawable *item;}\par

Points to a drawable in the result list.
\par

{\b EschPartitionList *prev;\line
EschPartitionList *next;}\par

Linked-list pointers.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschTraverse Structure                                                    ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_TRAVERSE}
${\footnote EschTraverse Class}
K{\footnote EschTraverse}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschTraverse Class}\par\pard\sb100

This structure is used for communicating with the
 {\uldb EschParition}{\v PG_ESCH_PARTITION} traverse() member.  All input
 parameters are conveyed via this structure.
\par

Using the traverse() member of a partitioning, the call-back routine provided
 is called for each drawable that meets the criteria given in the structure.
 Until all drawables that met the criteria have been processed or a non-zero
 value is returned from the call-back function.
\par

{\cf2
Note:  The drawables returned by this routine may lay outside the critiera
 due to partitioning parameters and may not be called in strict order.  The
 function will use the given information to guide the walk, if possible.
}\par

\line{\b\fs28 Name}\par

EschTraverse - Traversal interface communication structure.

\line{\b\fs28 Synopsis}\par

#include "espartn.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschTraverse();}\par

Clears the 'flags' member.
\par

{\b EschTraverse(EschPoint &p, EschTraverseCallback f, void *df=0);}\par

Sets the start point, call-back, and data-value for a full traverse of all
 objects in the partition.
\par

{\b EschTraverse(EschPoint &p, float d, EschTraverseCallback f,
 void *df=0);}\par

Sets the start point, cut-off distance, call-back, and data-value for a
 'circular' traverse of objects in the partition.
\par

{\b EschTraverse(EschPoint &p, EschVector &v, EschTraverseCallback f,
 void *df=0);}\par

Sets the start point, direction vector, call-back, and data-value for
 a directional traverse of the objects in the partition.
\par

{\b EschTraverse(EschPoint &p, EschVector &v, float d,
 EschTraverseCallback f, void *df=0);}\par

Sets the start point, direction vector, cut-off distance, call-back,
 and data-value for a direcitonal traverse of the objects in the partition.
\par

\line{\b\fs28 Data}\par

{\b dword flags}\par

Control flags (see Flags).
\par

{\b EschTraverseCallback func;}\par

Call-back function (required) to pass drawables (and data pointer).  If
 0 is returned from the call-back, the traverse continues.  If non-zero,
 the processing is stopped.
\par

{\b void *data;}\par

Application-specific data passed to call-back function along with
 drawable instances.
\par

{\b EschPoint pos;}\par

Starting position in world-space for traversal.
\par

{\b EschVector dir;}\par

Traversal direction vector.  This is ignored if {\i ESCH_TRAV_DIRECTION}
 is not set.
\par

{\b float dist;}\par

Traversal distance value.  This is ignored if {\i ESCH_TRAV_DIST} is not
 set.
\par

{\b IvoryArena *arena;}\par

Workspace for traverse (if needed).  This is ignored if {\i ESCH_TRAV_ARENA}
 is not set and the system arena is used.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_TRAV_DIRECTION}\tab Indicates 'dir' is valid.
\par

{\i ESCH_TRAV_DIST}\tab\tab Indicates 'dist' is valid.
\par

{\i ESCH_TRAV_ARENA}\tab\tab Indiciates 'arena' is valid.
\par

{\i ESCH_TRAV_APP0} -\line
{\i ESCH_TRAV_APP7}\tab Reserved for use by the application.
\par

\pard\page



{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°° Drawable Support Classes °°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschSphereExtents Class                                                   ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_SPHERE_EXTS}
${\footnote EschSphereExtents Class}
K{\footnote EschSphereExtents;
EschSphereExtents, draw;
EschSphereExtents, hit;
EschSphereExtents, ray}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschSphereExtents Class}\par\pard\sb100

Because geometric objects may be expensive to process, it is
 useful to be able to bound the object with a simple volume, such
 as a sphere.  This can then be used for trivial acceptance or
 rejection during visibility and collision tests.  Sphere or radial
 extents are less accurate than box extents, but they are not affected
 by rotation and are therefore less expensive for visibility checks than
 boundary boxes.  They are also less expensive to convert to other
 coordinate systems (only requires one transform) and to test against.
\par

See the {\uldb EschBoxExtents}{\v PG_ESCH_BOX_EXTS} class for details on
 the box extents class.
\par

\line{\b\fs28 Name}\par

EschSphereExtents - Spherical Extents Container Object
\par

\line{\b\fs28 Synopsis}\par

#include "esexts.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschSphereExtents();}\par

Performs no initialization.
\par

{\b EschSphereExtents(float x, float y, float z, float r);\line
EschSphereExtents(const EschPoint *p, float r);}\par

Initializes member variables.
\par

\line{\b\fs28 Member Data}\par

{\b EschPoint center;}\par

Center of radial extent sphere.
\par

{\b float radius;}\par

Radial extents of geometric object.
\par

\line{\b\fs28 Member Functions}\par

{\b void draw(const EschFrameRef *fr, dword clr) const;}\line

Displays the radial extents using the current context and in the
 given frame of reference with the given color.
\par

{\b int hit(const EschPoint *pt) const;\line
int hit(const EschPoint *pt, const float r) const;}\par

These routines perform extents intersection tests.  If the point/sphere
 given is contained within or intersects the radial extents, then 1 is
 returned, otherwise 0 is returned.  The input must be in the same
 coordinate system as the extents.
\par

{\b float ray(const EschPoint *pt, const EschVector *v) const;}\par

This routine performs a ray/sphere intersection test.  If the ray (starting
 at pt and moving along unit vector v) intersects the extents, then the
 distance along the ray is returned, otherwise 0 is returned.  The input
 ray must be in the same coordinate system as the extents.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschBoxExtents Class                                                      ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_BOX_EXTS}
${\footnote EschBoxExtents Class}
K{\footnote EschBoxExtents;
EschBoxExtents, draw;
EschBoxExtents, hit;
EschBoxExtents, ray}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschBoxExtents Class}\par\pard\sb100

Because geometric objects may be expensive to process, it is
 useful to be able to bound the object with a simple volume, such
 as a box.  The box extents are much more accurate than spherical
 extents, but they are more expensive to test (requires 8 points instead of
 one point to be transformed).  Box extents are very useful for collision
 detection as testing against an arbitrary polygonal mesh is prohibitive.
\par

See the {\uldb EschSphereExtents}{\v PG_ESCH_SPHERE_EXTS} class for details
 on the spherical extents class.
\par

\line{\b\fs28 Name}\par

EschBoxExtents - Box Extents Container Object
\par

\line{\b\fs28 Synopsis}\par

#include "esexts.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschBoxExtents();}\par

Performs no initialization.
\par

{\b EschBoxExtents(float minx, float miny, float minz,
 float maxx, float maxy, float maxz);\line
EschBoxExtents(const EschPoint *min, const EschPoint *max);}\par

Initializes member variables.
\par

\line{\b\fs28 Member Data}\par

{\b float mins[3];\line
float maxs[3];}\par

Bounding box for the geometric object (index 0 is X, 1 is Y, and 2 is Z).
\par

\line{\b\fs28 Member Functions}\par

{\b void draw(const EschFrameRef *fr, dword clr) const;}\line

Displays the box extents using the current context and in the given
 frame of reference with the given color.
\par

{\b int hit(const EschPoint *pt) const;\line
int hit(const EschPoint *pt, const float r) const;}\par

These routines perform extents intersection tests.  If the point/sphere
 given is contained within or intersects the box extents, then 1 is
 returned, otherwise 0 is returned.  The input must be in the same
 coordinate system as the extents.
\par

{\b float ray(const EschPoint *pt, const EschVector *v) const;}\par

This routine performs a ray/box intersection test.  If the ray (starting
 at pt and moving along unit vector v) intersects the extents, then the
 distance along the ray is returned, otherwise 0 is returned.  The input
 ray must be in the same coordinate system as the extents.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschFace Class                                                            ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_FACE}
${\footnote EschFace Class}
K{\footnote EschFace;
EschFace, set_flags;
EschFace, set_app_data;
EschFace, get_alpha;
EschFace, set_alpha}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschFace Class}\par\pard\sb100

The basic components used for polygonal meshes in {\i Escher} are
 triangular faces.  This class is the container for the data
 about each face.  The data in the face is relative to arrays of
 EschVertex and EschTexture class instances.
\par

\line{\b\fs28 Name}\par

EschFace - Triangular Face Support Container Object
\par

\line{\b\fs28 Synopsis}\par

#include "esgeom.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschFace();}\par

Does not initialize any data members.
\par

{\b EschFace(dword _f, word _a, word _b, word _c, word _txt, float
 _u0, float _u1, float _u2, float _v0, float _v1, float _v2,
 dword _clr, float _i, float _j, float _k,
 byte _si=0, byte _aa=255, byte _ab=255, byte _ac=255, void *_app=0);}\par

Initializes each member of the structure.
\par

\line{\b\fs28 Member Data}\par

{\b dword flags;}\par

Face control flags (see Flags below).  Temporary flags are not
 stored in the face instance itself.
\par

{\b word a;\line
word b;\line
word c;}\par

Indices into an associated EschVertex array for the three
 vertices of a face.
\par

{\b word txt;}\par

Index into an associated EschTexture array.  The actual index is
 txt-1 for the array as 0 indicates there is no associated
 texture object.  This is only used if {\i ESCH_FACE_TEXTURED} is set.
\par

{\b float u[3];\line
float v[3];}\par

Texture-map parameter coordinates for the face, if any.
\par

{\b dword color;}\par

Base color of face used for wire, solid, and flat shading.
\par

{\b EschVector normal;}\par

Normal vector orthogonal to the face.  This is used for shading
 and back-face culling.
\par

{\b byte self_illum;}\par

Self-illumination value (0 indicates no self-illumination, 255=indicates
 fully self-illuminated).
\par

{\b byte alpha_a, alpha_b, alpha_c]}\par

Alpha values for each vertex of the face which are only used if
 {\i ESCH_FACE_ALPHA} is set and matches up with the camera flags and
 drawable limitiations.  Most implementations apply the alpha_a value
 to the entire face and ignore the other values.  (0 indicates fully
 transparent, 255 is fully opaque).
\par

{\b void *app_data;}\par

Application data pointer.
\par

\line{\b\fs28 Member Functions}\par

{\scaps\cf4 NEW}\line
{\b void set_flags(const dword f);\line
void set_flags(const dword m, const int on);}\par

Sets value into flags member.
\par

{\b void set_app_data(void *p)}\par

This sets the application data pointer to the given value.
\par
{\b long get_alpha();\line
void set_alpha(long alpha);}\par

Sets the alpha_a member of the structure.  Be sure the {\i ESCH_CAM_ALPHA}
 bit is set before using these member functions.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_FACE_ONESIDED}\tab Face is visible from only one side.  Back-face
 culling is applied to the face.
\par

{\i ESCH_FACE_ALLOWPERSP}\tab Perspective output is allowed for the face.
 If this is set and the {\i ESCH_CAM_PERSPECTIVE} bit is set, then the face
 will be drawn using the perspective output routines.
\par

{\i ESCH_FACE_ALPHA}\tab\tab Face has an alpha value encoded into the flags.
\par

\line
These flags control the maximum shading level for the object.
 If the requested shading level is greater than the face's
 shading level, the face's shading level is used.  Otherwise, the
 requested shading level is used.
\par

{\i ESCH_FACE_WIRE}\tab\tab Wireframe
\par

{\i ESCH_FACE_SOLID}\tab\tab Solid
\par

{\i ESCH_FACE_FLAT}\tab\tab Flat-shaded
\par

{\i ESCH_FACE_SMOOTH}\tab\tab Smooth-shaded.
\par

{\i ESCH_FACE_SPECULAR}\tab Specularly-shaded.
\par

{\i ESCH_FACE_TEXTURED}\tab Has a texture map
\par

\line
These flags control the visibility of the given edge for
 wireframe mode.  This allows the object to appear to consist of
 rectangles instead of triangles.  If the requested shade level
 includes {\i ESCH_CAM_SHOW_ALL_LINES}, these flags have no effect.
\par

{\i ESCH_FACE_ABLINE}\tab Line from vertex A to vertex B is visible.
\par

{\i ESCH_FACE_BCLINE}\tab Line from vertex B to vertex C is visible.
\par

{\i ESCH_FACE_CALINE}\tab Line from vertex C to vertex A is visible.
\par

{\i ESCH_FACE_APP0} -\line
{\i ESCH_FACE_APP3}\tab Reserved for use by the application.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschMesh Class                                                            ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_MESH}
${\footnote EschMesh Class}
K{\footnote EschMesh;
EschMesh, operator =;
EschMesh, release;
EschMesh, set_flags;
EschMesh, load}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschMesh Class}\par\pard\sb100

This object contains the original model data for a 3D triangular
 mesh.  These class instances may be attached to multiple
 {\uldb EschMeshDraw}{\v PG_ESCH_MESHDRAW} drawables for display.  This
 allows the same model to be used in multiple locations throughout the
 world without prohibitive memory usage.
\par

Data files for mesh drawables can be created either via 3D Studio
 using the {\uldb Escher Exporter}{\v UG_ESCH_EXPORT} or via
 the {\uldb EschBuildMesh}{\v PG_ESCH_BUILDMESH} class.
\par

\line{\b\fs28 Name}\par

EschMesh - Triangular Polygonal Mesh Support Object
\par

\line{\b\fs28 Synopsis}\par

#include "esgeom.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschMesh();}\par

Initializes the data members.
\par

{\b EschMesh(const char *fname, const char *oname=0, VngoPal *pal=0,
 EschMatrix *m=0, char *pn=0, dword ctrlfl=ESCH_MSHLD_ALL);}\par

Initializes the data members and performs a load from an IFF file.
\par

{\b EschMesh(const EschMesh &msh);}\par

Initializes the data members from another mesh and clears the owns bits.
\par

\line{\b\fs28 Member Data}\par

{\b ulong ref_count;}\par

Reference count.  This counts the number of EschMeshDraw
 instances currently utilizing the model data.  This instance
 cannot be safely destroyed until all references have been
 detached.
\par

{\b dword flags;}\par

Control flags (see Flags below).  This should be set with set_flags().
\par

{\b char name[ESCH_MAX_NAME];}\par

Name of object contained.  This name is pointed to by any
 attached EschMeshDraw instances.
\par

{\b EschSphereExtents sphere;\line
EschBoxExtents box;}\par

Extents of object in local coordinates.
\par

{\b ulong nverts;\line
Ivory Handle v;}\par

Number of vertices in mesh and handle to array of vertex
 information defined in local coordinates.
\par

{\b ulong nfaces;\line
IvoryHandle f;}\par

Number of faces in mesh and handle to array of face information
 defined in local coordinates.
\par

{\b ulong tmax;\line
EschTexture **txt;}\par

Initial texture data array and count for mesh.  This may be
 overridden by settings in the EschMeshDraw instance.
\par

\line{\b\fs28 Member Functions}\par

{\b const EschMesh &operator = (const EschMesh &msh);}\par

Copies the data from another mesh and clears the owns bits of the
 target.  Any previously owned data is freed.
\par

{\b virtual esch_error_codes release();}\par

Releases the data associated with the instance.
\par

{\scaps\cf4 NEW}\line
{\b void set_flags(const dword f);\line
void set_flags(const dword m, const int on);}\par

Sets the control flags.
\par

{\b esch_error_codes load(const char *fname, const char *oname,
 VngoPal *pal=0, EschMatrix *m=0, char *pn=0,
 dword ctrlfl=ESCH_MSHLD_ALL);}\par

Loads the mesh information from an IFF file contained exported
 object information.  The object name oname is used to determine
 which object in the IFF file is loaded.  The RGB colors in the
 face are converted to palette entries if pal is set (textures
 are assumed to be correctly colored for the palette) and the
 orientation information for the object is put into m if
 provided.  If pn is provided, the object's parent's name is
 returned, if defined.  The ctrlfl flags parameter controls
 some additional behavior (see Control Flags below). Returns
 0 on success, error otherwise (see Error Codes below).
\par

{\b virtual esch_error_codes load(XFParseIFF *iff, const char
 *oname=0, VngoPal *pal=0, EschMatrix *m=0, char *pn=0,
 dword ctrlfl=ESCH_MSHLD_ALL);}\par

Will load the mesh from the given IFF file if chunk currently
 pointed to is a mesh form.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_MSH_OWNSDATA}\tab Associated data buffers should be freed by
 the destructor.
\par

{\i ESCH_MSH_OWNSTEXTURE}\tab Associated texture array should be freed
 by the destructor.
\par

{\i ESCH_MSH_APP0} -\line
{\i ESCH_MSH_APPF}\tab Reserved for use by the application.
\par

\line{\b\fs28 Control Flags}\par

{\i ESCH_MSHLD_USEMFTXT}\tab Should load animated textures as multi-frame
 textures.  Otherwise, the first frame is loaded as a static texture.
\par

{\i ESCH_MSHLD_SHARETXT}\tab Should use textures stored in cache and
 share any loaded textures.
\par

{\i ESCH_MSHLD_FILETXT}\tab Should try to find textures in registered
 texture files.
\par

{\i ESCH_MSHLD_ALL}\tab All of the above.
\par

{\scaps\cf4 NEW}\line
{\i ESCH_MSHLD_TXTTCBM}\tab Should load XFBitmap instances into texture
 app_data pointer.  See {\i ESCH_TXTXLD_TCBITMAP} for more details.
\par

\line{\b\fs28 Error Codes}\par

{\i ESCH_ERR_NONE}\tab\tab No error
\par

{\i ESCH_ERR_NOMEMORY}\tab Memory allocation failed
\par

{\i ESCH_ERR_FILEERROR}\tab File error during load.
\par

{\i ESCH_ERR_NOTFOUND}\tab Object not found.
\par

{\i ESCH_ERR_INVALIDDATA}\tab Data for object invalid.
\par

{\i ESCH_ERR_INVALIDVDATA}\tab Vertex data for object invalid.
\par

{\i ESCH_ERR_INVALIDFDATA}\tab Face data for object invalid.
\par

{\i ESCH_ERR_REFERENCED}\tab The object is still referenced, so release
 can't be performed.
\par

\line{\b\fs28 Example}\par

This example loads a mesh of 'Object01' from the 'OBJECT.IFF'
 export file, makes an instance, then draws it rotating about the
 Y axis 1 degree per frame:
\par

{\f2
EschCamera Camera;
\par
// Needed to recolor properly
\par
VngoPal Palette;
\par
EschMeshDraw  mdraw;
\par
esch_error_codes  err;
\par
if ((err = mdraw.load("OBJECT.IFF","Object01",Palette)) != 0)\line
\{
\par
    // Error, as returned by function into err.
\par
\}
\par
while (!kbhit())\line
\{
\par
    // Render object to camera
\par
    Camera.render(&mdraw);\line
    mdraw->rotatey(1);\line
\}
}
\par

\pard\page



{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°° Camera Classes °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschCamera Class                                                          ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_CAMERA}
${\footnote EschCamera Class}
K{\footnote EschCamera;
EschCamera, pre_rend;
EschCamera, rend;
EschCamera, post_rend;
EschCamera, operator =;
EschCamera, next;
EschCamera, prev;
EschCamera, attach;
EschCamera, sibling;
EschCamera, remove;
EschCamera, find;
EschCamera, reset;
EschCamera, render;
EschCamera, set_top;
EschCamera, set_dir;
EschCamera, set_vects;
EschCamera, get_position;
EschCamera, set_position;
EschCamera, set_lookat;
EschCamera, rotatex;
EschCamera, rotatey;
EschCamera, rotatez;
EschCamera, pitch;
EschCamera, roll;
EschCamera, yaw;
EschCamera, translate;
EschCamera, move;
EschCamera, orthogonalize;
EschCamera, orthogonalize_top;
EschCamera, set_factor;
EschCamera, zoom;
EschCamera, set_fov;
EschCamera, set_ortho;
EschCamera, set_hither;
EschCamera, set_yon;
EschCamera, set_bcolor;
EschCamera, set_flags;
EschCamera, set_app_data;
EschCamera, set_aspect_ratio;
EschCamera, compute_z_factor;
EschCamera, compute_scalar;
EschCamera, compute_frustrum;
EschCamera, compute_eye;
EschCamera, compute_inverse;
EschCamera, load}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschCamera Class}\par\pard\sb100

The camera define the viewing position and parameters for
 displaying 3D objects onto a {\i Van Gogh} viewport.  All drawable
 instances draw relative to the camera defined in the current
 context and use the control flags of the camera for determining
 the type of shading and other parameters required for the view.
\par

The camera has two basic modes of operation:  perspective and orthogonal.
 In perspective mode (which is the default), the projection uses the
 Z value to foreshorten lines and is the standard "pin-hole" camera model
 for realistic perspective.  The orthogonal mode uses a parallel projection
 and is useful for more abstract displays of the model where the wrapping
 due to perspective is not desired.  Drawables should support both modes
 if possible.
\par

Some operations require that the eye frame-of-references be updated to
 maintain consistency in the data structure.  The update flags
 control this behavior, which by default indicates all required changes
 should be made (see {\b Update Flags}).
\par

{\cf2
Note:  If multiple draw lists are rendered() in a single frame, care should
 be taken to ensure both the {\i ESCH_CAM_NOCLEAR} and {\i ESCH_CAM_NOFLUSH}
 bits are set correctly ({\i NOCLEAR} on all but the first and {\i NOFLUSH}
 on all but the last) to get the desired result.
}\par

The following method is used to convert a 3D point into the correct pixel
 coordiate:
\par

1) Transform the point (x,y,z) from any local coordinate system into world
 coordinates (wx, wy, wz).  This is not needed if the point is already in
 world coordinates.
\par

2) Transform the point from world coordinates into the camera's eye
 coordinates (ex, ey, ez) by transforming by the eye.iorient matrix
 (the inverse is used since the transform is from world to local).
 This step may be combined with the previous step by concat'ing the
 two matricies before the transform (faster only when transforming multiple
 points in the same coordinate system).
\par

3) The 3D point may now be clipped against the hither plane and
 yon planes (i.e., hither <= ez <= yon must be true for the point to be
 visible).
\par

4) Next the 3D point may be clipped against the four view volume planes.
 For perspective mode, the tests are as follows:  planex = xsize*ez;
 planey = ysize*ez; -planex <= ex <= planex and -planey <= ey <= planey
 must both be true for the point to be visible.  For orthogonal mode,
 the tests are as follows: -xsize <= ex <= xsize and -ysize <= ey <= ysize
 must be true for the point to be visible.
\par

5) Finally project the point to to a pixel coordinate and z-buffer
 value as follows:\par
 for perspective mode:\line
 sx = long((ex * xscalar) / ez) + (vport->vbuff.width >> 1);\line
 sy = long((ey * yscalar) / ez) + (vport->vbuff.height >> 1);\line
 sz = long(ez * z_factor);\par
 -or- for orthogonal mode (the same except for the divide by ez):\line
 sx = long(ex * xscalar) + (vport->vbuff.width >> 1);\line
 sy = long(ey * yscalar) + (vport->vbuff.height >> 1);\line
 sz = long(ez * z_factor);\line
\par

\line{\b\fs28 Name}\par

EschCamera - Viewing Parameters and Control Object
\par

\line{\b\fs28 Synopsis}\par

#include "escamera.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschCamera(VngoVport *vport=0);}\par

Initializes the viewing parameters by calling reset and attaches
 the {\i Van Gogh} viewport, if given.
\par

{\b EschCamera(const char *fname, const char *cname=0);}\par

Initializes the viewing parameters and performs a load.
\par

{\b EschCamera(const EschCamera &cam);}\par

Initializes the view parameters from another camera's settings.
\par

\line{\b\fs28 Member Data}\par

{\b protected EschCamera  *inext;\line
protected EschCamera  *iprev;}\par

Used to create linked-lists of cameras.  Use sibling() and
 remove() to affect these.
\par

{\b EschFrameRef eye;}\par

Frame-of-reference to move from eye to world coordinates (this
 means that to convert to eye, the inverse orientation matrix
 must be used).  Should be set by various member functions or
 set_dir/_vects().
\par

{\b EschVector top;}\par

Top of head vector.  Should be set by set_top().
\par

{\b dword flags;}\par

Camera control flags (see Flags below).  Should be set with set_flags().
\par

{\b VngoVport *vport;}\par

{\i Van Gogh} viewport associated with camera.  This is set by attach().
\par

{\b float xscalar;\line
float yscalar;\line
float xsize;\line
float ysize;}\par

X/Y scalar constants and projection area's 1/2 size in each dimension
 given current settings.  These are computed by compute_scalar() and are
 dependent on the aspect_ratio, viewport dimensions, and either the
 field-of-view for perpsective cameras or the width/height for orthogonal
 cameras.
\par

{\b float aspect_ratio;}\par

Aspect-ratio is the ratio of X:Y of the physical device.  For most modes,
 the pixels are square and an aspect-ratio of 1 (the default) should be used.
 Some modes, such as 320x200 mode 13h, have non-square pixels (in this
 case 4:3 sized pixels).  Therefore, an aspect-ratio of 0.833 should be
 used when using this video mode (computed from the size of the screen
 and the required aspect-ratio as ysize*xratio / xsize*yratio).  This should
 be set with set_aspect_ratio().
\par

{\cf2 Note:  The physical mode is what determines the aspect-ratio, not
 the viewport size.}\par

{\b float factor;}\par

Zoom factor for view.
\par

{\b float hither;}\par

Hither or near clipping plane.  Should be set by set_hither().
\par

{\b float yon;}\par

Yon or far clipping plane.  Should be set by set_yon().
\par

{\b float fov;}\par

Field-of-view in degrees for perspective cameras.  Should be set by set_fov().
\par

{\b float width, height;}\par

Width and height of projection area for orthogonal cameras.  Should be
 set by set_ortho().
\par

{\b dword bcolor;}\par

Background color for clearing during a render.  Should be set by
 set_bcolor().  This has no effect if {\i ESCH_CAM_NOCLEAR} is set.
\par

{\b float radius_factor;}\par

Extent radius factor based on the field-of-view and scale factor used for
 spherical extent testing.  This is set by compute_scalar().
\par

{\b float z_factor;}\par

Z-scaling factor to convert projected Z to full range of the
 Z-buffer.  This is computed by compute_z_factor() from the hither
 and yon plane values.
\par

{\b EschPlane frustrum[6];}\par

View frustrum planes ({\i ESCH_CAM_FRUSTRUM_HITHER, ESCH_CAM_FRUSTRUM_YON,
 ESCH_CAM_FRUSTRUM_LEFT, ESCH_CAM_FRUSTRUM_RIGHT, ESCH_CAM_FRUSTRUM_TOP,
 ESCH_CAM_FRUSTRUM_BOTTOM} are the indecies).  These are computed by
 compute_frustrum() and are dependent upon the results of the
 compute_scalar() routine--xsize and ysize--and the hither and yon
 clipping plane distances.
\par

{\b char name[ESCH_MAX_NAME];}\par

Camera name.  Filled with "NoName" by default.
\par

{\b void *app_data;}\par

Pointer to application data, if any.  Should be set by set_app_data().
\par

\line{\b\fs28 Member Functions}\par

{\b protected virtual int pre_rend();\line
protected virtual void rend();\line
protected virtual void post_rend();}\par

Internal render functions which assume that context has already
 been setup with the appropriate information to begin rendering
 the image.  Use the render() member.
\par

{\b EschCamera *next() const;\line
EschCamera *prev() const;}\par

Returns the value in the protected inext/iprev members for
 walking the list of cameras.
\par

{\b const EschCamera &operator = (const EschCamera &cam);}\par

Copies the data from another camera, but does not copy the linked-list
 pointers.
\par

{\b virtual void attach(VngoVport *vp);}\par

Attaches the {\i Van Gogh} viewport, setting vport and aspect_ratio
 and recomputes the viewing parameters based on the viewport size.
\par

{\b virtual void sibling(EschCamera *myprev);}\par

Makes myprev the previous sibling in the camera linked-list.
\par

{\b virtual void remove();}\par

Removes the camera from the list it is attached into, if any.
\par

{\b virtual EschCamera *find(const char *name) const;}\par

Searches the linked-list of cameras attached to the object for
 the given name.  Returns a pointer to the found camera or 0 if
 not found.
\par

{\b virtual void reset();}\par

Resets the camera to default viewing parameters, positioned at
 the origin, looking down positive Z with the top in the positive
 Y direction.
\par

{\b void render(dword ctrl=ESCH_REND_ALL);\line
void render(EschDrawable *olist, dword ctrl=ESCH_REND_ALL);\line
void render(EschLight *llist, dword ctrl=ESCH_REND_ALL);\line
void render(EschDrawable *olist, EschLight *llist, dword ctrl=ESCH_REND_ALL);}\par

Begins a render of an image using the given information to
 augment the currently active context, if any.  See {\b Render
 Control Flags} for information on the ctrl flags.
\par

{\b void set_top(const EschVector *t, dword update=ESCH_UPD_ALL);\line
void set_top(const float ii, const float ij, const float ik, dword update=ESCH_UPD_ALL);}\par

Make the vector the new top vector and recomputes.
\par

{\b void set_dir(const EschVector *d, dword update=ESCH_UPD_ALL);\line
void set_dir(const float ii, const float ij, const float ik, dword update=ESCH_UPD_ALL);}\par

Makes the vector the new dir vector in the eye and recomputes.
\par

{\b void set_vects(const EschVector *t, const EschVector *d, dword update=ESCH_UPD_ALL);\line
void set_vects(const float ti, const float tj, const float tk,
const float di, const float dj, const float dk, dword update=ESCH_UPD_ALL);}\par

Sets both the top and eye.dir vectors and recomputes.
\par

{\b void get_position(EschPoint *pt) const;}\par

Gets the position of the camera in world space.
\par

{\b void set_position(const EschPoint *pt, dword update=ESCH_UPD_ALL);\line
void set_position(const float ix, const float iy, const float iz, dword update=ESCH_UPD_ALL);}\par

Sets the position of the camera in world space.
\par

{\b void set_lookat(const EschPoint *pt, dword update=ESCH_UPD_ALL);\line
void set_lookat(const float ix, const float iy, const float iz, dword update=ESCH_UPD_ALL);}\par

Sets the direction vector based on the camera's position and a
 look-at point which becomes the center of the camera's view.
\par

{\b void rotatex(const float degrees, dword update=ESCH_UPD_ALL);\line
void rotatey(const float degrees, dword update=ESCH_UPD_ALL);\line
void rotatez(const float degrees, dword update=ESCH_UPD_ALL);}\par

Rotates the camera about the X/Y/Z-axis
\par

{\b void pitch(const float degrees, dword update=ESCH_UPD_ALL);\line
void yaw(const float degrees, dword update=ESCH_UPD_ALL);\line
void roll(const float degrees, dword update=ESCH_UPD_ALL);}\par

Rotates the view from the camera about the I/J/K-axis
\par

{\b void translate(const EschVector *v, dword update=ESCH_UPD_ALL);\line
void translate(const float ii, const float ij, const float ik, dword update=ESCH_UPD_ALL);}\par

Translates the camera in world coordinates.
\par

{\b void move(const EschVector *v, dword update=ESCH_UPD_ALL);\line
void move(const float ii, const float ij, const float ik, dword update=ESCH_UPD_ALL);}\par

Translates the camera in local coordinates along the current I,
 J, and K axis.
\par

{\b void orthogonalize(dword update=ESCH_UPD_ALL);\line
void orthogonalize_top(dword update=ESCH_UPD_ALL);}\par

Forces the orientation components of the frame-of-reference into
 an orthonormal basis to remove accumulated errors from rotations.
 The standard version uses the direction vector as the first
 basis (the first-basis is only normalized by the process), while the
 _top version uses the top vector as the first basis.
\par

{\cf2
Note:  The 'right' vector for the camera is the cross-product of the
 direction and top vectors, so it will always be orthogonal to the
 other vectors.
}\par

{\b void set_factor(const float f, dword update=ESCH_UPD_ALL);}\par

Sets the factor member and recomputes the viewing parameters.
\par

{\b void zoom(const float z, dword update=ESCH_UPD_ALL);}\par

Scales the factor member and recomputes the viewing parameters.
\par

{\b void set_fov(const float f, dword update=ESCH_UPD_ALL)}\par

Sets the field-of-view, sets the camera to perspective mode, and
 recomputes the viewing parameters.
\par

{\b void set_ortho(const float w, const float h=0, dword update=ESCH_UPD_ALL)}\par

Sets the width and height of the projection area, sets the camera to
 orthogonal mode, and recomputes the viewing parameters.  If height is
 zero, then the aspect_ratio is used to compute the height from the
 width and viewport size.
\par

{\b void set_hither(const float h, dword update=ESCH_UPD_ALL)}\par

Sets the hither clipping plane and recomputes.
\par

{\b void set_yon(const float y, dword update=ESCH_UPD_ALL)}\par

Sets the yon clipping plane and recomputes.
\par

{\b void set_bcolor(const dword c);}\par

Sets the background clear color.
\par

{\scaps\cf4 NEW}\line
{\b void set_flags(const dword f);\line
void set_flags(const dword m, const int on);}\par

Sets the control flags.
\par

{\b void set_app_data(void *p)}\par

This sets the application data pointer to the given value.
\par

{\b void set_aspect_ratio(const float ar, dword update=ESCH_UPD_ALL)}\par

Sets the aspect_ratio and recomputes.
\par

{\b void compute_z_factor();}\par

Routine used to compute z_factor.  It uses the current hither and yon values.
\par

{\b void compute_scalar();}\par

Routine used to compute scalar constants.  This uses the currently attached
 viewport's size, the aspect-ratio, and either the field-of-view for
 perspective cameras or the width/height for orthgonal cameras.
\par

{\b void compute_frustrum();}\par

Routine used to compute the view frustrum.  This uses the xsize and
 ysize values computed by compute_scalar().
\par

{\b void compute_eye(dword update=ESCH_UPD_ALL);}\par

Routine used to create eye frame-of-reference from the direction vector,
 top vector, and user scale factor.
\par

{\b void compute_inverse();}\par

This support routine updates the inverse eye matrix.
\par

{\b esch_error_codes load(const char *fname, const char *cname=0);}\par

Loads the viewing information from an IFF file contained
 exported camera information.  The camera name cname is used to
 determine which camera in the IFF file is loaded, if given.
 Returns 0 on success, error otherwise (see Error codes below).
\par

{\b esch_error_codes load(XFParseIFF *iff, const char *cname=0);}\par

Will load the camera from the given IFF file if chunk currently
 pointed to is a camera chunk.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_CAM_NOCLEAR}\tab\tab Prevents the camera from clearing the viewport
 at the beginning of a render.
\par

{\i ESCH_CAM_NOFLUSH}\tab\tab Prevents the camera from flushing the element
 list at the end of a render.  A flush()/flush_truesort() call is required
 even in Z-buffer mode since alpha-blended faces must be drawn last.  This
 should be used to chain a number of render() calls togther for a single
 frame.
\par

{\i ESCH_CAM_MODELSPACE}\tab Lighting should be computed in model space
 instead of world-space.
\par

{\i ESCH_CAM_BACKCULL}\tab Enables back-culling of faces.
\par

{\i ESCH_CAM_TEXTURED}\tab Texture maps on faces should be drawn.
\par

{\i ESCH_CAM_PERSPECTIVE}\tab Perspective output.  This will cause
 the perspective version of the output routines to be called.
\par

{\i ESCH_CAM_ALPHA}\tab\tab Enables alpha-blended output.
\par

{\i ESCH_CAM_SHOW_ALL_LINES}\tab Forces all lines to be visible in
 wire-frame mode regardless of face's visibility flags.
\par

{\i ESCH_CAM_SORT}\tab\tab Enables full element sort.  This bit is set by
 default if the attached viewport is not a Z-buffer device.
\par

{\scaps\cf4 NOT COMPLETED}\line
{\i ESCH_CAM_TRUESORT}\tab Causes the element list to be sorted using
 a more complex 'true' sort that resolves overlap cases not handled
 by a z-max implementation.  This affects the choice of flush() vs.
 flush_truesort() which is called if {\i ESCH_CAM_NOFLUSH} is not set.
\par

{\i ESCH_CAM_ORTHO}\tab Indicates the camera is in orthogonal mode.  If
 clear, then the camera is in perspective mode.  This is controlled by
 the set_fov() and set_ortho() routines.
\par

{\i ESCH_CAM_VPWASLOCKED}\tab Set/cleared by pre_rend()/post_rend() to
 handle locking of the viewport for rendering.
\par

{\i ESCH_CAM_APP0} -\line
{\i ESCH_CAM_APP7}\tab\tab Reserved for use by the application.
\par

\line
These flags control the maximum shading model to use for output.
 They act as a 'mask' against control bits in the face, so all bits
 up to the desired shading level should be set.
\par

{\i ESCH_CAM_SHADE_WIRE}\tab\tab Wireframe output.
\par

{\i ESCH_CAM_SHADE_SOLID}\tab\tab Solid color output.
\par

{\i ESCH_CAM_SHADE_FLAT}\tab\tab Flat-shading.
\par

{\i ESCH_CAM_SHADE_SMOOTH}\tab\tab Smooth-shading.
\par

{\i ESCH_CAM_SHADE_SPECULAR}\tab Specularly shaded (combined with Flat
 or Smooth shading).
\par

\line{\b\fs28 Error codes}\par

{\i ESCH_ERR_NONE}\tab\tab No error
\par

{\i ESCH_ERR_NOMEMORY}\tab Memory allocation failed
\par

{\i ESCH_ERR_FILEERROR}\tab File error during load.
\par

{\i ESCH_ERR_NOTFOUND}\tab Camera not found.
\par

{\i ESCH_ERR_INVALIDDATA}\tab Data for camera invalid.
\par

\line{\b\fs28 Update Flags}\par

{\i ESCH_UPD_INVERSE}\tab Indicates the transform routine should recompute
 the inverse matrix.
\par

{\i ESCH_UPD_ORTHO}\tab Indicates the rotate transform routine should
 call orthonormalize() if the ortho_count exceeds {\i ESCH_MAX_ORTHOCOUNT}.
\par

{\i ESCH_UPD_EYE}\tab Indicates the routine should recompute
 the eye frame-of-reference.
\par

{\i ESCH_UPD_SCALAR}\tab Indicates the routine should recompute
 the eye scalar values and/or z-factor.
\par

{\i ESCH_UPD_ALL}\tab Indicates all required updating should be performed.
\par

\line{\b\fs28 Render Control Flags}\par

{\i ESCH_REND_PRE}\tab Indicates that the pre_rend() routine should be
 called to prepare the render.  Must be set for the first render call
 for a frame.
\par

{\i ESCH_REND_DRAW}\tab Indicates that the rend() routine should be
 called to walk the list of drawables and call their draw() members.  Can
 be called a number of times in a single frame.
\par

{\i ESCH_REND_POST}\tab Indicates that the post_rend() routine should be
 called to perform the final stage of the render.  Must be set for the
 last call in a single frame.
\par

{\i ESCH_REND_ALL}\tab Indicates all three render routines should be
 executed.
\par

\line{\b\fs28 Example}\par

This example renders a drawable object as the camera rolls about
 the Z axis by 1 degree each frame:
\par

{\f2
EschDrawable Draw;
\par
EschCamera cam;
\par
// Setup for specular shading
\par
cam.set_flags(ESCH_CAM_SHADE_WIRE\line
         | ESCH_CAM_SHADE_SOLID\line
         | ESCH_CAM_SHADE_FLAT\line
         | ESCH_CAM_SHADE_SMOOTH
         | ESCH_CAM_SPECULAR, 1);\line
\par
while (!kbhit())\line
\{
\par
    // Render drawable
\par
    cam.render(&Draw);\line
    cam.roll(1);\line
\}
}
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschCameraEx Class                                                        ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_CAMERAEX}
${\footnote EschCameraEx Class}
K{\footnote EschCameraEx;
EschCameraEx, pre_rend;
EschCameraEx, post_rend;
EschCameraEx, operator =;
EschCameraEx, release;
EschCameraEx, set_bg_offset;
EschCameraEx, set_bg_bitmap;
EschCameraEx, create_bg_bitmap;
EschCameraEx, set_haze;
EschCameraEx, set_gradient}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschCameraEx Class}\par\pard\sb100

{\scaps\cf4 CHANGED}\line
The extended camera adds optional features to the rendering including
 scrolling bitmap backgrounds, gradient backgrounds, and hazing/fogging
 for distance queuing.
\par

When using gradient backgrounds, the colors are defined as being the 'top'
 color moving down towards the camera long the Y axis until the 'topy' value
 is reached.  The gradient then shifts towards the 'mid' color at the 'midy'
 Y value and then towards the 'bottom' color.  At the 'bottomy' value or
 below, the color is the 'bottom' color.
\par

{\cf2
Note:  The bitmap background cannot be used in conjunction with a gradient
 background and takes precidence over it.
}\par

\line{\b\fs28 Name}\par

EschCameraEx - Extended Viewing Parameters and Control Object
\par

\line{\b\fs28 Synopsis}\par

#include "escamera.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschCamera}{\v PG_ESCH_CAMERA}
\par

\line{\b\fs28 Constructors}\par

{\b EschCameraEx(VngoVport *vport=0);}\par

Initializes the viewing parameters by calling reset and attaches
 the {\i Van Gogh} viewport, if given.
\par

{\b EschCameraEx(const char *fname, const char *cname=0);}\par

Initializes the viewing parameters and performs a load.
\par

{\b EschCameraEx(const EschCamera &cam);\line
EschCameraEx(const EschCameraEx &cam);}\par

Initializes the view parameters from another camera's settings.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschCamera}{\v PG_ESCH_CAMERA}, plus :-
\par

{\b short bg_offx, short bg_offy;}\par

Bitmap background offset.  Positive offsets move the image to the
 left and negative values move the image to the right.  These should
 be set by set_bg_offset().
\par

{\b VngoTexture *bg_bitmap;}\par

Bitmap background to use instead of background color.  If 0,
 then background color bcolor is used.  This has no effect if
 {\i ESCH_CAM_NOCLEAR} is defined.  This should be set by
 set_bg_bitmap().
\par

{\scaps\cf4 NEW}\line
{\b dword grd_top;\line
dword grd_mid;\line
dword grd_bottom;}\par

Colors for gradient background mode.  Should be set with set_gradient().
\par

{\scaps\cf4 NEW}\line
{\b float grd_topy;\line
float grd_midy;\line
float grd_bottomy;}\par

Heights (Y values) for where the gradient background color-changes are located.
 These are relative to the camera's position unless {\i ESCH_CAM_GRADIENT_FIXED}
 is set.  Should be set with set_gradient().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschCamera}{\v PG_ESCH_CAMERA}, plus :-
\par

{\b protected virtual int pre_rend();\line
protected virtual void post_rend();}\par

Overloaded internal render functions which implement the
 extended functionality.
\par

{\b const EschCameraEx &operator = (const EschCamera &cam);\line
const EschCameraEx &operator = (const EschCameraEx &cam);}\par

Copies the data from another camera, but does not copy the linked-list
 pointers and clears the owns bits in the new camera.  Any previously
 owned data is freed by the Ex version.
\par

{\b virtual void release();}\par

Releases all data owned by the camera instance.  This is called by
 the destructor.
\par

{\b void set_bg_offset(short x, short y);}\par

Sets the bitmap offset.
\par

{\b int set_bg_bitmap(VngoTexture *tex, int owns=1);}\par

Sets the bg_bitmap member to the given image.  If owns is set,
 then {\i ESCH_CAM_OWNSBITMAP} is set into the flags.  Any previously
 owned bitmap is freed.  Returns 0 if successful, or 1 if the bitmap
 is not suitable as a bitmap background.
\par

{\b int create_bg_bitmap(XFBitmap *bm);}\par

Creates a new VngoTexture instance of the same bit-depth as the
 current vport device (8-, 15-, or 16-bit currently supported) from
 the input bitmap.  The newly created texture instance is owned
 by the camera.  Returns 0 if successful, or 1 if an error occured.
\par

{\b int set_haze(float start, float mid);\line
int set_haze(float start, float mid, VngoColor24bit tcolor);}\par

Sets the hazing information for the current vport device and
 turns on the hazing effect.  To control the hazing, you can call
 haze_on() and haze_off() for the viewport.
\par

{\scaps\cf4 CHANGED}\line
{\b void set_gradient(VngoColor24bit top, float topy, VngoColor24bit mid,
 float midy, VngoColor24bit bottom, float bottomy, int fixed=0);}\par

Sets the gradient background mode to on and sets the colors and y values. If
 'fixed' is set, the y values are in world coordinates.
\par

\line{\b\fs28 Flags}\par

Same as {\uldb EschCamera}{\v PG_ESCH_CAMERA}, plus :-
\par

{\i ESCH_CAM_OWNSBITMAP}\tab Indicates that the bg_bitmap bitmap data is
 owned by the camera and should be freed by the destructor or
 when a new bitmap is set by set_bg_bitmap.
\par

{\i ESCH_CAM_IGNORE_BMAP}\tab Bitmap background is ignored in favor of
 background color even with bg_bitmap set to non-NULL.
\par

{\i ESCH_CAM_GRADIENT}\tab Gradient background active.
\par

{\scaps\cf4 NEW}\line
{\i ESCH_CAM_GRADIENT_FIXED}\tab Gradient background height values are defined
 in world coordinates and do not move with the camera.
\par

\line{\b\fs28 Error Values}\par

{\i ESCH_ERR_INVALIDPARMS}\tab Input data was invalid.
\par

{\i ESCH_ERR_NOMEMORY}\tab Memory allocation failed.
\par

{\i ESCH_ERR_NEEDVPORT}\tab Viewport must be attached to camera previous
 to operation.
\par

\pard\page



{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°° Light Classes °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschLight Class                                                           ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_LIGHT}
${\footnote EschLight Class}
K{\footnote EschLight;
EschLight, get_type;
EschLight, operator =;
EschLight, next;
EschLight, prev;
EschLight, sibling;
EschLight, remove;
EschLight, find;
EschLight, setup;
EschLight, shine;
EschLight, hishine;
EschLight, get_intensity;
EschLight, set_intensity;
EschLight, set_flags;
EschLight, set_app_data;
EschLight, load}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschLight Class}\par\pard\sb100

Different shading computations are required for each type of
 light source within a 3D view.  This class forms a standard
 interface to perform lighting computations for future expansion
 with various lighting models.
\par

This base class acts as an ambient light source as it contains
 no positional information.
\par

\line{\b\fs28 Name}\par

EschLight - Light Source Base Object and Ambient Source
\par

\line{\b\fs28 Synopsis}\par

#include "eslight.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschLight(const char *fname=0, const char *lname=0);}\par

Initializes the object as an ambient light of low-intensity, and
 loads an ambient light from the file if fname is non-zero.
\par

{\b EschLight(const EschLight &l);}\par

Initializes the light from another light's settings, including
 the run-time type identifier, but not the link pointers.
\par

\line{\b\fs28 Member Data}\par

{\b protected EschLight  *inext;\line
protected EschLight  *iprev;}\par

Used to create linked-lists of lights.  Use sibling() and
 remove() to affect these.
\par

{\b protected float _intensity;\line
protected float _hintensity;}\par

Intensity value for the light for both normal and highlighted
 shade computation.  These values are scaled to the range for {\i Van
 Gogh}.  They are computed during setup() using the current context's
 camera and its assoicated palette.
\par

{\b protected long mp;}\par

Palette mid-point shade value read from current context camera's palette
 by setup().  Used to clamp shade value in shine().
\par

{\b protected word ltyp;}\par

Light type value for run-time identification (see Light Types).  Use
 get_type() to read this value.
\par

{\b byte intensity;}\par

Intensity of the light, ranging from 0 to 255.  This should be set
 with set_intensity and read with get_intensity.
\par

{\b byte na;}\par

Padding.
\par

{\b dword flags;}\par

Control flags (see Flags).  Should be set with set_flags.
\par

{\b char name[ESCH_MAX_NAME];}\par

Name for the light.  By default, set to "NoName".
\par

{\b void *app_data;}\par

Pointer to application data, if any.  Should be set by set_app_data().
\par

\line{\b\fs28 Member Functions}\par

{\b word get_type() const;}\par

Returns the run-time type of the light (See Light Types).
\par

{\b const EschLight &operator = (const EschLight &l);}\par

Copies the data from another light, but does not copy the linked-list
 pointers or run-time type value.
\par

{\b EschLight *next() const;\line
EschLight *prev() const;}\par

Returns the value in the protected inext/iprev members for
 walking the list of lights.
\par

{\b virtual void sibling(EschLight *myprev);}\par

Makes myprev the previous sibling in the light linked-list.
\par

{\b virtual void remove();}\par

Removes the light from the list it is attached into, if any.
\par

{\b virtual EschLight *find(const char *name) const;}\par

Searches the linked-list of lights attached to the object for
 the given name.  Returns a pointer to the found light or 0 if
 not found.
\par

{\b virtual void setup(const EschFrameRef *fr);}\par

Sets up the light list relative to the given frame-of-reference and
 the current context's camera.  The protected members _intensity and
 hintensity are set by this call.  If the {\i ESCH_CAM_MODELSPACE} bit
 is set, then the light will need to use the inverse transform in the
 fr value to setup the light in model space.
\par

{\b virtual void shine(const EschVertex *v, VngoPoint *vpt, int revnrml=0) const;\line
virtual void hishine(const EschVertex *v, VngoPoint *vpt, int revnrml=0) const;}\par

Computes the shading value for the given vertex point v, which
 will be in model-space if {\i ESCH_CAM_MODELSPACE} is set, otherwise
 in world-space.  The current color of the point should be put
 into the vpt object.  The color and shade values in vpt will be
 altered.  If revnrml is non-zero, then the reverse of the normal is
 used.  The hishine version can use the shade values greater
 than the palette's midpoint to provide highlights.
\par

{\b byte get_intensity() const;}\par

Returns the current intensity in the range 0 to 255.
\par

{\b void set_intensity(const byte i);}\par

Sets the intensity given an input in the range 0 to 255.
\par

{\scaps\cf4 NEW}\line
{\b void set_flags(const dword f);\line
void set_flags(const dword m, const int on);}\par

Sets the control flags.
\par

{\b void set_app_data(void *p)}\par

This sets the application data pointer to the given value.
\par

{\b virtual esch_error_codes load(const char *fname, const char *lname=0);}\par

Loads the viewing information from an IFF file contained
 exported light information.  The base object only reads ambient
 light information.  The light name lname is used to determine
 which light in the IFF file is loaded, if given.  Returns 0 on
 success, error otherwise (see Error codes below).
\par

{\b virtual esch_error_codes load(XFParseIFF *iff, const char *lname=0);}\par

Will load the light from the given IFF file if chunk currently
 pointed to is a light chunk.  The base object only reads ambient
 light information.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_LGT_OFF}\tab The light source is off and should be skipped.
\par

{\i ESCH_LGT_DARK}\tab The light source is a 'darklight' and subtracts
 instead of adds to the shading.
\par

{\i ESCH_LGT_ATTEN}\tab The light source should be attenuated.  This is
 only supported by some light types.
\par

{\i ESCH_LGT_APP0} -\line
{\i ESCH_LGT_APP7}\tab Reserved for use by the application.
\par

\line{\b\fs28 Light Types}\par

{\i ESCH_LGTT_AMBIENT}\tab Light is an EschLight.
\par

{\i ESCH_LGTT_VECTOR}\tab\tab Light is an
 {\uldb EschVectorLight}{\v PG_ESCH_VECTORLIGHT}.
\par

{\i ESCH_LGTT_FPOINT}\tab\tab Light is an
 {\uldb EschFastPointLight}{\v PG_ESCH_FPOINTLIGHT}.
\par

{\i ESCH_LGTT_FATTEN}\tab\tab Light is an
 {\uldb EschFastAttenLight}{\v PG_ESCH_FATTENLIGHT}.
\par

{\i ESCH_LGTT_FSPOT}\tab\tab Light is an
 {\uldb EschFastSpotLight}{\v PG_ESCH_FSPOTLIGHT}.
\par

{\i ESCH_LGTT_POINT}\tab\tab Light is an
 {\uldb EschPointLight}{\v PG_ESCH_POINTLIGHT}.
\par

{\i ESCH_LGTT_ATTEN}\tab\tab Light is an
 {\uldb EschAttenLight}{\v PG_ESCH_ATTENLIGHT}.
\par

{\i ESCH_LGTT_SPOT}\tab\tab Light is an
 {\uldb EschSpotLight}{\v PG_ESCH_SPOTLIGHT}.
\par

\line{\b\fs28 Example}\par

This example renders a drawable using ambient light that grows
 from black to full over several frames:
\par

{\f2
EschCamera Camera;
\par
EschDrawable Draw;
\par
EschLight light;
\par
light.set_intensity(0);
\par
byte intensity=0;
\par
while (!kbhit())\line
\{
\par
    // Render frame
\par
    Camera.render(&Draw,&light);
\par
    // Increase intensity
\par
    if (intensity < 255)\line
    \{\line
        intensity++;\line
        light.set_intensity(intensity);\line
    \}\line
\}
}
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschVectorLight Class                                                     ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_VECTORLIGHT}
${\footnote EschVectorLight Class}
K{\footnote EschVectorLight;
EschVectorLight, set_direction;
EschVectorLight, rotatex;
EschVectorLight, rotatey;
EschVectorLight, rotatez}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschVectorLight Class}\par\pard\sb100

Vector lights are directional lights sources which fall in
 parallel lines throughout the scene.  The cost of the lighting
 in this case is a dot product per face or vertex.
\par

\line{\b\fs28 Name}\par

EschVectorLight - Vector/direction-only Light Source
\par

\line{\b\fs28 Synopsis}\par

#include "eslight.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschLight}{\v PG_ESCH_LIGHT}
\par

\line{\b\fs28 Constructors}\par

{\b EschVectorLight(const char *fname=0, const char *lname=0);}\par

Initializes the light at full intensity and sets the vector or
 [0 0 1], and loads a directional light if fname is non-zero.
\par

{\b EschVectorLight(const EschVector *vec);\line
EschVectorLight(float ix, float iy, float iz);}\par

Initializes the light at full intensity and sets the vector.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschLight}{\v PG_ESCH_LIGHT}, plus :-
\par

{\b protected EschVector tdir;}\par

Internal direction vector set by setup.
\par

{\b EschVector dir;}\par

Direction vector for light.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschLight}{\v PG_ESCH_LIGHT}, plus :-
\par

{\b void set_direction(const EschVector *d);\line
void set_direction(float ii, float ij, float ik);}\par

Sets the direction vector dir.  The vector is normalized
 automatically.
\par

{\b void rotatex(const float degrees);\line
void rotatey(const float degrees);\line
void rotatez(const float degrees);}\par

Rotates direction vector about X/Y/Z-axis.
\par

\line{\b\fs28 Example}\par

This example renders a drawable using a vector light that
 rotates about the Y axis by 1 degree each frame:
\par

{\f2
EschCamera Camera;
\par
EschDrawable Draw;
\par
EschVectorLight light(1,1,1);
\par
while (!kbhit())\line
\{
\par
    // Render frame
\par
    Camera.render(&Draw,&light);
\par
    // Rotate light
\par
    light.rotatey(1);\line
\}
}
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschFastPointLight Class                                                  ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_FPOINTLIGHT}
${\footnote EschFastPointLight Class}
K{\footnote EschFastPointLight;
EschFastPointLight, set_position;
EschFastPointLight, translate}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschFastPointLight Class}\par\pard\sb100

A fast point light approximates an omni-directional point light source.  It
 works by computing a vector formed by the fast point's location and the
 center of the target object (as determined from the frame-of-reference
 given to setup).  If no target object is given to setup, then it forms
 a vector with (0,0,0).  The cost of lighting is the same as the vector
 light.
\par

\line{\b\fs28 Name}\par

EschFastPointLight - Approximated Point Light Source
\par

\line{\b\fs28 Synopsis}\par

#include "eslight.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschLight}{\v PG_ESCH_LIGHT}
\par

\line{\b\fs28 Constructors}\par

{\b EschFastPointLight(const char *fname=0, const char *lname=0);}\par

Initializes the light at full intensity and sets the position to
 (0,0,0) and will load a point light if fname is non-zero.
\par

{\b EschFastPointLight(const EschPoint *pnt);\line
EschFastPointLight(float ix, float iy, float iz);}\par

Initializes the light at full intensity and sets the position.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschLight}{\v PG_ESCH_LIGHT}, plus :-
\par

{\b protected EschVector tdir;}\par

Internal vector computed by setup.
\par

{\b EschPoint pos;}\par

The world-space position of the light source.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschLight}{\v PG_ESCH_LIGHT}, plus :-
\par

{\b void set_position(const EschPoint *pnt);\line
void set_position(float ix, float iy, float iz);}\par

Sets the position of the light in pos.
\par

{\b void translate(float tx, float ty, float tz);
void translate(const EschVector *v);}\par

Translates the position of the light.
\par

\line{\b\fs28 Example}\par

This example renders a drawable using a fast point light that moves
 in the positive Z direction by 1 unit each frame.
\par

{\f2
EschCamera Camera;
\par
EschDrawable Draw;
\par
EschFastPointLight light(10,10,10);
\par
while (!kbhit())\line
\{
\par
    // Render frame
\par
    Camera.render(&Draw,&light);
\par
    // Move light
\par
    light.pos.translate(0,0,1);\line
\}
}
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschFastAttenLight Class                                                  ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_FATTENLIGHT}
${\footnote EschFastAttenLight Class}
K{\footnote EschFastAttenLight;
EschFastAttenLight, set_inner;
EschFastAttenLight, set_outer}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschFastAttenLight Class}\par\pard\sb100

This class implements an approximated point light with attenuation for
 the distance to the target.  This cost is the same as a fast point light,
 plus some extra computation in the setup.
\par

If the {\i ESCH_LGT_ATTEN} flag is set, then the intensity remains constant
 for all objects within the 'inner' range and degrades to 0 between 'inner'
 and 'outer'.  All objects beyond 'outer' are not affected by the light.
 If the flag is not set, then all objects within the 'outer' range are
 at constant intensity and all objects beyond 'outer' are not affected by
 the light.  The flag is set by default.
\par

\line{\b\fs28 Name}\par

EschFastAttenLight - Approx. Attenuated Point Light Source
\par

\line{\b\fs28 Synopsis}\par

#include "eslight.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschFastPointLight}{\v PG_ESCH_FPOINTLIGHT}
\par

\line{\b\fs28 Constructors}\par

{\b EschFastAttenLight(const char *fname=0, const char *lname=0);}\par

Initializes the light at full intensity and sets the position to
 (0,0,0) and will load an attenuated light if fname is non-zero.
\par

{\b EschFastAttenLight(const EschPoint *pnt, float i, float o);\line
EschFastAttenLight(float ix, float iy, float iz, float i, float o);}\par

Initializes the light at full intensity and sets the position, as
 well as the inner and outer ranges.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschFastPointLight}{\v PG_ESCH_FPOINTLIGHT}, plus :-
\par

{\b float inner;}\par

Distance from light position to end of 'inner' range and start of 'outer'.
 Should be set by set_inner().
\par

{\b float outer;}\par

Distance from light source to end of 'outer' range.  Should be set
 by set_outer().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschFastPointLight}{\v PG_ESCH_FPOINTLIGHT}, plus :-
\par

{\b void set_inner(float i);}\par

Sets inner range value.
\par

{\b void set_outer(float i);}\par

Sets outer range value.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschFastSpotLight Class                                                   ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_FSPOTLIGHT}
${\footnote EschFastSpotLight Class}
K{\footnote EschFastSpotLight;
EschFastSpotLight, set_direction;
EschFastSpotLight, rotatex;
EschFastSpotLight, rotatey;
EschFastSpotLight, rotatez;
EschFastSpotLight, set_hotspot;
EschFastSpotLight, set_falloff}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschFastSpotLight Class}\par\pard\sb100

This extends the fast attenuated light to include a directional component for
 spot light effects with only a slight additional cost in the setup.
\par

The intensity of the light is constant within the 'hotspot' region, then
 falls off to zero within the 'falloff' region.  If the target is out of
 the falloff cone, then the light has no effect.  The intensity may also
 be attenuated by distance as per attenuated lights.
\par

\line{\b\fs28 Name}\par

EschFastSpotLight - Spot Light Source
\par

\line{\b\fs28 Synopsis}\par

#include "eslight.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschFastAttenLight}{\v PG_ESCH_FATTENLIGHT}
\par

\line{\b\fs28 Constructors}\par

{\b EschFastSpotLight(const char *fname=0, const char *lname=0);}\par

Initializes the light at full intensity and sets the position to
 (0,0,0), direction to (0,0,1), and will load a spot light
 if fname is non-zero.
\par

{\b EschFastSpotLight(const EschPoint *pnt, const EschVector *d,
 float h, float f, float i=0, float o=0x1000);\line
EschFastSpotLight(float ix, float iy, float iz,
 float ii, float ij, float ik,
 float h, float f, float i=0, float o=0x1000);}\par

Initializes the light at full intensity and sets the position, direction,
 hotspot and falloff angle, as well as the inner and outer ranges.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschFastAttenLight}{\v PG_ESCH_FATTENLIGHT}, plus :-
\par

{\b EschVector dir;}\par

Direction vector for spot light.  Should be set by set_direction.
\par

{\b float hotspot;}\par

Angle for hotspot area of light.  Should be set by set_hotspot.
\par

{\b float falloff;}\par

Angle for falloff area of light, which should be larger than
 hotspot.  Should be set by set_falloff.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschFastAttenLight}{\v PG_ESCH_FATTENLIGHT}, plus :-
\par

{\b void set_direction(const EschVector *d);\line
void set_direction(float ii, float ij, float ik);}\par

Sets the direction vector dir.  The vector is normalized
 automatically.
\par

{\b void rotatex(const float degrees);\line
void rotatey(const float degrees);\line
void rotatez(const float degrees);}\par

Rotates direction vector about X/Y/Z-axis.
\par

{\b void set_hotspot(float degrees);}\par

Sets the hotspot angle.
\par

{\b void set_falloff(float degrees);}\par

Sets the falloff angle.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschPointLight Class                                                      ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_POINTLIGHT}
${\footnote EschPointLight Class}
K{\footnote EschPointLight;
EschPointLight, set_position;
EschPointLight, translate}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschPointLight Class}\par\pard\sb100

Point lights are omni-directional light sources.  The cost of
 the lighting in this case is a vector subtraction,
 normalization, and a dot product per face or vertex.  This is
 significantly more expensive than vector or fast point light
 computations, but results in the more realistic lighting effects.
\par

\line{\b\fs28 Name}\par

EschPointLight - Point Light Source
\par

\line{\b\fs28 Synopsis}\par

#include "eslight.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschLight}{\v PG_ESCH_LIGHT}
\par

\line{\b\fs28 Constructors}\par

{\b EschPointLight(const char *fname=0, const char *lname=0);}\par

Initializes the light at full intensity and sets the position to
 (0,0,0) and will load a point light if fname is non-zero.
\par

{\b EschPointLight(const EschPoint *pnt);\line
EschPointLight(float ix, float iy, float iz);}\par

Initializes the light at full intensity and sets the position.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschLight}{\v PG_ESCH_LIGHT}, plus :-
\par

{\b protected EschPoint tpos;}\par

Internal position set by setup.
\par

{\b EschPoint pos;}\par

The world-space position of the light source.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschLight}{\v PG_ESCH_LIGHT}, plus :-
\par

{\b void set_position(const EschPoint *pnt);\line
void set_position(float ix, float iy, float iz);}\par

Sets the position of the light in pos.
\par

{\b void translate(float tx, float ty, float tz);
void translate(const EschVector *v);}\par

Translates the position of the light.
\par

\line{\b\fs28 Example}\par

This example renders a drawable using a point light that moves
 in the positive Z direction by 1 unit each frame.
\par

{\f2
EschCamera Camera;
\par
EschDrawable Draw;
\par
EschPointLight light(10,10,10);
\par
while (!kbhit())\line
\{
\par
    // Render frame
\par
    Camera.render(&Draw,&light);
\par
    // Move light
\par
    light.pos.translate(0,0,1);\line
\}
}
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschAttenLight Class                                                      ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_ATTENLIGHT}
${\footnote EschAttenLight Class}
K{\footnote EschAttenLight;
EschAttenLight, set_inner;
EschAttenLight, set_outer}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschAttenLight Class}\par\pard\sb100

This class implements a point light with attenuation for the distance
 to the target.  This cost is the same as a point light, plus
 some small additional overhead for the intensity scaling.
\par

If the {\i ESCH_LGT_ATTEN} flag is set, then the intensity remains constant
 for all points within the 'inner' range and degrades to 0 between 'inner'
 and 'outer'.  All points beyond 'outer' are not affected by the light.
 If the flag is not set, then all points within the 'outer' range are
 at constant intensity and all points beyond 'outer' are not affected by
 the light.  The flag is set by default.
\par

\line{\b\fs28 Name}\par

EschAttenLight - Attenuated Point Light Source
\par

\line{\b\fs28 Synopsis}\par

#include "eslight.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschPointLight}{\v PG_ESCH_POINTLIGHT}
\par

\line{\b\fs28 Constructors}\par

{\b EschAttenLight(const char *fname=0, const char *lname=0);}\par

Initializes the light at full intensity and sets the position to
 (0,0,0) and will load an attenuated light if fname is non-zero.
\par

{\b EschAttenLight(const EschPoint *pnt, float i, float o);\line
EschAttenLight(float ix, float iy, float iz, float i, float o);}\par

Initializes the light at full intensity and sets the position, as
 well as the inner and outer ranges.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschPointLight}{\v PG_ESCH_POINTLIGHT}, plus :-
\par

{\b protected float tinner, touter;\line
protected float arate, harate;}\par

Internal data set by setup.
\par

{\b float inner;}\par

Distance from light position to end of 'inner' range and start of 'outer'.
 Should be set by set_inner().
\par

{\b float outer;}\par

Distance from light source to end of 'outer' range.  Should be set
 by set_outer().
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschPointLight}{\v PG_ESCH_POINTLIGHT}, plus :-
\par

{\b void set_inner(float i);}\par

Sets inner range value.
\par

{\b void set_outer(float i);}\par

Sets outer range value.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschSpotLight Class                                                       ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_SPOTLIGHT}
${\footnote EschSpotLight Class}
K{\footnote EschSpotLight;
EschSpotLight, set_direction;
EschSpotLight, rotatex;
EschSpotLight, rotatey;
EschSpotLight, rotatez;
EschSpotLight, set_hotspot;
EschSpotLight, set_falloff}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschSpotLight Class}\par\pard\sb100

This extends the attenuated light to include a directional component for
 spot light effects.  This requires an additional dot product per face or
 vertex on top of the cost for attenuated lights.
\par

The intensity of the light is constant within the 'hotspot' region, then
 falls off to zero within the 'falloff' region.  If the target is out of
 the falloff cone, then the light has no effect.  The intensity may also
 be attenuated by distance as per attenuated lights.
\par

\line{\b\fs28 Name}\par

EschSpotLight - Spot Light Source
\par

\line{\b\fs28 Synopsis}\par

#include "eslight.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschAttenLight}{\v PG_ESCH_ATTENLIGHT}
\par

\line{\b\fs28 Constructors}\par

{\b EschSpotLight(const char *fname=0, const char *lname=0);}\par

Initializes the light at full intensity and sets the position to
 (0,0,0), direction to (0,0,1), and will load a spot light
 if fname is non-zero.
\par

{\b EschSpotLight(const EschPoint *pnt, const EschVector *d,
 float h, float f, float i=0, float o=0x1000);\line
EschSpotLight(float ix, float iy, float iz,
 float ii, float ij, float ik,
 float h, float f, float i=0, float o=0x1000);}\par

Initializes the light at full intensity and sets the position, direction,
 hotspot and falloff angle, as well as the inner and outer ranges.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschAttenLight}{\v PG_ESCH_ATTENLIGHT}, plus :-
\par

{\b protected EschVector tdir;\line
protected float hotcos, fallcos;\line
protected float frate, hfrate;}\par

Internal data set by setup.
\par

{\b EschVector dir;}\par

Direction vector for spot light.  Should be set by set_direction.
\par

{\b float hotspot;}\par

Angle for hotspot area of light.  Should be set by set_hotspot.
\par

{\b float falloff;}\par

Angle for falloff area of light, which should be larger than
 hotspot.  Should be set by set_falloff.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschAttenLight}{\v PG_ESCH_ATTENLIGHT}, plus :-
\par

{\b void set_direction(const EschVector *d);\line
void set_direction(float ii, float ij, float ik);}\par

Sets the direction vector dir.  The vector is normalized
 automatically.
\par

{\b void rotatex(const float degrees);\line
void rotatey(const float degrees);\line
void rotatez(const float degrees);}\par

Rotates direction vector about X/Y/Z-axis.
\par

{\b void set_hotspot(float degrees);}\par

Sets the hotspot angle.
\par

{\b void set_falloff(float degrees);}\par

Sets the falloff angle.
\par

\pard\page



{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°° Texture Classes °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschTexture Class                                                         ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_TEXTURE}
${\footnote EschTexture Class}
K{\footnote EschTexture;
EschTexture, get_type;
EschTexture, operator =;
EschTexture, release;
EschTexture, lock;
EschTexture, unlock;
EschTexture, animate;
EschTexture, cache_new;
EschTexture, cache_release;
EschTexture, cache_register;
EschTexture, file_load;
EschTexture, file_register;
EschTexture, file_unregister;
EschTexture, set_flags;
EschTexture, set_app_data;
EschTexture, load}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschTexture Class}\par\pard\sb100

{\scaps\cf4 CHANGED}\line
Texture-mapping primitives require that the bitmap defining the
 texture be available for processing at draw time.  Textures,
 however, are often one of the largest consumers of memory in 3D
 render engines.  Therefore, this class provides a standard
 interface for controlling the caching of textures as well as
 animation and other controls needed for texture-management.
\par

This base implementation provides little functionality.  Generally, the
 base class is only used as an interface level.
\par

Data files for static and multi-frame textures can be created either
 via 3D Studio using the {\uldb Escher Exporter}{\v UG_ESCH_EXPORT} or
 via the {\uldb EschBuildTexture}{\v PG_ESCH_BUILDTEXTURE} class.
\par

\line{\b\fs28 Name}\par

EschTexture - Texture Interface Class
\par

\line{\b\fs28 Synopsis}\par

#include "estxture.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschTexture();}\par

Initializes the data members to empty values.
\par

{\b EschTexture(const EschTexture &txt);}\par

Initializes the texture from another texture, clearing the owns bits.
\par

\line{\b\fs28 Member Data}\par

{\b protected word ttyp;}\par

Texture type value for run-time identification (see Texture Types).  Use
 get_type() to read this value.
\par

{\b protected word na;}\par

Reserved for future use.
\par

{\b dword flags;}\par

Texture control and status flags (see Flags).  Should be set with set_flags().
\par

{\b char *name;}\par

Pointer to texture name.  Points to "NoName" by default.
\par

{\b VngoTexture *ptr;}\par

Pointer to {\i Van Gogh} texture.  This is only guaranteed to be valid if
 {\i ESCH_TXT_LOCKED} is set.
\par

{\b void *app_data;}\par

Pointer to application data, if any.  Should be set by set_app_data().
\par

\line{\b\fs28 Member Functions}\par

{\b word get_type() const;}\par

Returns the run-time type of the texture (See Texture Types).
\par

{\b const EschTexture &operator = (const EschTexture &txt);}\par

Copies the data from another texture except the run-time type, clearing
 the owns bits of the target.  Any previously owned data is freed.
\par

{\b virtual void release();}\par

Releases all data owned by the texture instance.  This is called
 by the destructor.  In the base implementation with {\i ESCH_TXT_OWNSDATA}
 set, the 'name' and 'ptr' members are freed if non-zero.
\par

{\b virtual void lock();\line
virtual void unlock();}\par

Locks or unlocks the {\i Van Gogh} texture, setting the appropriate
 frame pointer up in ptr.  Unlock should set ptr to 0 for safety,
 if ptr isn't the only pointer to the data block.  The base implementation
 only keeps the LOCKED bit sync and performs no other actions.
\par

{\cf2 Note:  Locks on textures do not have a 'reference count' as they
 should be locked immediately before use, then unlocked immediately after
 use.}\par

{\b virtual void animate();}\par

Animation call-back for the texture.  The base implementation does
 nothing on this call.
\par

{\b static EschTexture *cache_new(const char *n);}\par

Searches the texture cache for a texture of the given name, returning
 a new instance sharing that texture data or 0 if the texture is not
 in the cache.
\par

{\b static int cache_release(IvoryHandle h);}\par

Releases a texture handle shared from the texture cache.  Returns 0
 if the texture was not found in the cache.
\par

{\b static esch_error_codes cache_register(const char *n, IvoryHandle hnd,
 word t, dword f, ushort w, ushort h, ushort m, char **name=0, int inuse=0);}\par

Adds a texture to the texture cache.  If name is given, then a pointer
 to the name within the cache is returned.  If inuse is set, then the
 initial count is set to 1, otherwise it is set to 0.
\par

{\b static EschTexture *file_load(const char *n, VngoPal *pal=0,
  dword ctrlfl=ESCH_TXTLD_ALL);}\par

Searches any registered texture files for a texture named 'n' and performs
 a load with the given 'pal' and 'ctrlfl' parameters, returning the loaded
 instance if found.
\par

{\b static esch_error_codes file_register(const char *fname);}\par

Registers a texture file for search by the file_load() routine.  A file
 handle is left open to this file so it is recommended that file_unregister()
 be called when file loading has been completed.
\par

{\b static void file_unregister(const char *fname=0);}\par

Removes a registered texture file from the search list for file_load(),
 closing the associated handle.  If 'fname' is 0, all registered files
 are cleared.
\par

{\scaps\cf4 NEW}\line
{\b void set_flags(const dword f);\line
void set_flags(const dword m, const int on);}\par

Sets the texture control and status flags.
\par

{\b void set_app_data(void *p)}\par

This sets the application data pointer to the given value.
\par

{\b virtual esch_error_codes load(const char *fname, const char *tname=0,
 dword ctrlfl=ESCH_TXTLD_ALL, VngoPal *pal=0);}\par

Loads the texture from the given file of the given name, or first texture
 encountered if tname is zero.  The base implementation calls the IFF
 version of load if an {\i Escher} materials form is encountered.
\par

{\b virtual esch_error_codes load(XFParseIFF *iff, const char *tname=0,
 dword ctrlfl=ESCH_TXTLD_ALL, VngoPal *pal=0);}\par

Will load the texture from the given IFF file if chunk currently
 pointed to is a {\i Escher} material form.  It returns an error if the
 name in the IFF form doesn't match tname, if non-zero.  The
 base implementation always returns {\i ESCH_ERR_NOTSUPPORTED}.
\par

\line{\b\fs28 Flags}\par

{\i ESCH_TXT_LOCKED}\tab\tab Texture is locked and ptr is valid.  This
 should be set by lock and cleared by unlock.
\par

{\i ESCH_TXT_SKIPANIMATE}\tab Texture should be skipped during a
 drawable's animate() cycle.
\par

{\cf2 Note:  This can be used to prevent multiple animate() calls being
 made to the same texture because of sharing between drawables.}\par

{\i ESCH_TXT_OWNSDATA}\tab Texture owns the texture data and should
free it when release is called.
\par

{\i ESCH_TXT_SHARED}\tab\tab Indicates the texture data is shared via the
 texture cache.
\par

{\scaps\cf4 NEW}\line
{\i ESCH_TXT_TRANSP}\tab\tab Indicates that the texture data is transparent.
\par

{\i ESCH_TXT_APP0} -\line
{\i ESCH_TXT_APP7}\tab\tab Reserved for use by the
application.
\par

\line{\b\fs28 Load Flags}\par

{\i ESCH_TXTLD_SHARE}\tab Should register with texture cache.
\par

{\i ESCH_TXTLD_MFRAME}\tab (file_load only) Indicates multi-frame textures
 should be loaded as such.  Otherwise, they are loaded as static textures
 using only the first frame.
\par

{\i ESCH_TXTLD_ALL}\tab All of the above.
\par

{\scaps\cf4 NEW}\line
{\i ESCH_TXTLD_TCBITMAP}\tab Should store a XFBitmap of the texture in
 app_data if the original data was in a 15-, 24-, or 32-bit format.
 The app_data member must 0 before making the load() call with this bit
 or an error will result.  You are responsible for freeing the
 XFBitmap instance pointed to by app_data manually (use delete).  If
 loading into an EschMultiFrameTexture, app_data is a pointer to
 an array of XFBitmap instances.
\par

\line{\b\fs28 Texture Types}\par

{\i ESCH_TXTT_BASE}\tab Texture is an EschTexture.
\par

{\i ESCH_TXTT_STATIC}\tab Texture is an
 {\uldb EschStaticTexture}{\v PG_ESCH_STATICTEXTURE}.
\par

{\i ESCH_TXTT_MFRAME}\tab Texture is an
 {\uldb EschMultiFrameTexture}{\v PG_ESCH_MFRAMETEXTURE}.
\par

{\i ESCH_TXTT_PRC}\tab Texture is an
 {\uldb EschProceduralTexture}{\v PG_ESCH_PROCTEXTURE}.
\par

{\i ESCH_TXTT_PRCFIRE}\tab Texture is an
 {\uldb EschFireTexture}{\v PG_ESCH_FIRETEXTURE}.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschStaticTexture Class                                                   ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_STATICTEXTURE}
${\footnote EschStaticTexture Class}
K{\footnote EschStaticTexture;
EschStaticTexture, release;
EschStaticTexture, lock;
EschStaticTexture, unlock;
EschStaticTexture, create;
EschStaticTexture, load}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschStaticTexture Class}\par\pard\sb100

The most common texture is a single bitmap frame.  This class provides
 support for these kinds of materials, with the bitmap data stored in
 {\i Ivory} handle space.
\par

\line{\b\fs28 Name}\par

EschStaticTexture - Single-frame Bitmap Texture Class
\par

\line{\b\fs28 Synopsis}\par

#include "estxture.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschTexture}{\v PG_ESCH_TEXTURE}
\par

\line{\b\fs28 Constructors}\par

{\b EschStaticTexture();}\par

Initializes the data members to empty values.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschTexture}{\v PG_ESCH_TEXTURE}, plus :-
\par

{\b IvoryHandle handle;}\par

Handle to texture data.  The data block is a VngoTexture structure
 plus the bitmap data.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschTexture}{\v PG_ESCH_TEXTURE}, plus :-
\par

{\b virtual void release();}\par

Releases all data owned by the texture instance.  This is called
 by the destructor.
\par

{\b virtual void lock();\line
virtual void unlock();}\par

Locks or unlocks the {\i Van Gogh} texture, setting the appropriate
 frame pointer up in ptr.  Unlock sets ptr to 0 for safety.
\par

{\b esch_error_codes create(XFBitmap *bm, int trans=1, VngoPal *pal=0);}\par

This creates a static texture from a bitmap.  The bitmap must be appropriate
 for a texture.  The bitmap is only used to build the texture and is
 not referenced after the routine has completed.  If trans is set, then
 the texture is created as transparent (index 255).
\par

{\b virtual esch_error_codes load(const char *fname, const char *tname=0,
 dword ctrlfl=ESCH_TXTLD_ALL, VngoPal *pal=0);\line
virtual esch_error_codes load(XFParseIFF *iff, const char *tname=0,
 dword ctrlfl=ESCH_TXTLD_ALL, VngoPal *pal=0);}\par

Will load the single-frame texture from the given IFF file if the chunk
 currently pointed to is a {\i Escher} material form.  It returns an
 error if the name in the IFF form doesn't match tname, if non-zero.
 Some textures may require a palette structure to load.  If given a
 multi-frame texture data form, this will load the first frame as a
 static texture.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschMultiFrameTexture Class                                               ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_MFRAMETEXTURE}
${\footnote EschMultiFrameTexture Class}
K{\footnote EschMultiFrameTexture;
EschMultiFrameTexture, release;
EschMultiFrameTexture, lock;
EschMultiFrameTexture, unlock;
EschMultiFrameTexture, animate;
EschMultiFrameTexture, reset;
EschMultiFrameTexture, set_interval;
EschMultiFrameTexture, set_rate;
EschMultiFrameTexture, set_size;
EschMultiFrameTexture, create;
EschMultiFrameTexture, load}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschMultiFrameTexture Class}\par\pard\sb100

This class provides support for multiple bitmaps of identical
 size as an animating texture.  All frames are kept in {\i Ivory}
 handle space.  The animation can either be frame-based or
 time-based.
\par

\line{\b\fs28 Name}\par

EschMultiFrameTexture - Multiple-frame Bitmap Texture Class
\par

\line{\b\fs28 Synopsis}\par

#include "estxture.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschTexture}{\v PG_ESCH_TEXTURE}
\par

\line{\b\fs28 Constructors}\par

{\b EschMultiFrameTexture();}\par

Initializes the data members to empty values.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschTexture}{\v PG_ESCH_TEXTURE}, plus :-
\par

{\b protected ulong base;\line
protected ulong size;}\par

Pre-computed offset and size of texture data to speed up lock().  This
 is set by set_size().
\par

{\b protected float interval;\line
protected float time;}\par

Interval values used to implement time-based animation.
\par

{\b ushort index;}\par

Current frame counter (0-based).
\par

{\b ushort max;}\par

Maximum number of frames.
\par

{\b IvoryHandle handle;}\par

Handle to texture data.  The data block is an array of VngoTexture
 structures followed by all of the bitmap data.
\par

{\cf2 Note:  Since animated frames are generally cycled often, it is best
 to lock/unlock the animated texture set as a block.  If an animated texture
 is only needed occasionally, a static texture should also be created and
 use in place of the multi-frame texture until it is required to animate.}\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschTexture}{\v PG_ESCH_TEXTURE}, plus :-
\par

{\b virtual void release();}\par

Releases all data owned by the texture instance.  This is called
 by the destructor.
\par

{\b virtual void lock();\line
virtual void unlock();}\par

Locks or unlocks the {\i Van Gogh} texture, setting the appropriate
 frame pointer up in ptr.  Unlock sets ptr to 0 for safety.
\par

{\b virtual void animate();}\par

This is used to animate the multi-frame texture.  If
 {\i ESCH_MFTXT_TIMEBASED} is set, then the rate and interval
 values are used to advance the frame count.  Otherwise, the
 index is just advanced to the next frame.
\par

{\b void reset();}\par

This resets the index to the first frame and clears the time-based
 animation accumulator.
\par

{\b void set_interval(float i);}\par

This sets the time interval used by the animate() routine with
 time-based animation.
\par

{\cf2
Note:  If time-based animation is used, it is important to set
 the interval before calling animate().
}\par

{\b void set_rate(float r);}\par

This sets the number of frames per time unit for time-based
 animation and sets the {\i ESCH_MFTXT_TIMEBASED} bit.
\par

{\b void set_size(ushort w, ushort h);}\par

This sets up the internal size and base members.
\par

{\b esch_error_codes create(ushort n, XFBitmap *bms, int trans=1,
 VngoPal *pal=0);}\par

This creates an animated texture from an array of n (where n is
 at least 2) bitmaps.  Each bitmap must be appropriate for a
 texture and of the same size.  The bitmaps are only used to build
 the texture and are not referenced after the routine has completed.  If
 trans is set, the textures are created as transparent (index 255).
\par

{\b virtual esch_error_codes load(const char *fname, const char *tname=0,
 dword ctrlfl=ESCH_TXTLD_ALL, VngoPal *pal=0);\line
virtual esch_error_codes load(XFParseIFF *iff, const char *tname=0,
 dword ctrlfl=ESCH_TXTLD_ALL, VngoPal *pal=0);}\par

Will load the multi-frame texture from the given IFF file if the chunk
 currently pointed to is a {\i Escher} material form.  It returns an
 error if the name in the IFF form doesn't match tname, if non-zero.
 Some textures may require a palette structure to load.
\par

\line{\b\fs28 Flags}\par

Same as {\uldb EschTexture}{\v PG_ESCH_TEXTURE}, plus :-
\par

{\i ESCH_MFTXT_TIMEBASED}\tab animate() should use time-based logic
 to advance the frame count.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschProceduralTexture Class                                               ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PROCTEXTURE}
${\footnote EschProceduralTexture Class}
K{\footnote EschProceduralTexture;
EschProceduralTexture, release;
EschProceduralTexture, lock;
EschProceduralTexture, unlock;
EschProceduralTexture, animate;
EschProceduralTexture, init;
EschProceduralTexture, generate}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschProceduralTexture Class}\par\pard\sb100

Bitmap-based textures require the least amount of overhead to use in
 terms of processing, but multi-frame textures can use a large amount of
 memory.  It is often much easier to generate some kinds of animating or
 'random' textures algorithmically.  This class provides a standard
 interface and framework for developing procedural textures.
\par

\line{\b\fs28 Name}\par

EschProceduralTexture - Procedural Texture Class
\par

\line{\b\fs28 Synopsis}\par

#include "estxture.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschTexture}{\v PG_ESCH_TEXTURE}
\par

\line{\b\fs28 Constructors}\par

{\b EschProceduralTexture();}\par

This clears the internal buffer pointer.
\par

{\b EschProceduralTexture(ushort w, ushort h, VngoPal *pal, int dogen=1);}\par

This clears the internal buffer pointer and calls init().
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschTexture}{\v PG_ESCH_TEXTURE}, plus :-
\par

{\b protected VngoTexture txt;}\par

This structure stores data relating to the output-buffer where the
 procedural texture should be generated.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschTexture}{\v PG_ESCH_TEXTURE}, plus :-
\par

{\b virtual void release();}\par

Releases all data owned by the instance and frees the work buffer.  This
 is called by the destructor.
\par

{\b virtual void lock();\line
virtual void unlock();}\par

Locks sets ptr to point to 'txt' and unlock sets ptr to 0.
\par

{\b virtual void animate();}\par

This calls generate().  Derived classes may want to have animate perform
 time checks or other control instead of directly calling generate().
\par

{\b virtual esch_error_codes init(ushort w, ushort h, VngoPal *pal,
 int dogen=1);}\par

This function should be called to setup the instance before calling
 any of the other functions.  If dogen is set to 1, then generate() is
 called to setup the first frame.  If the palette is changed or a new
 size is desired, the instance must be reinited with this call.
\par

{\b virtual void generate();}\par

This is the virtual function that is overloaded by deriving classes
 to implement a procedural texture.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschFireTexture Class                                                     ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_FIRETEXTURE}
${\footnote EschFireTexture Class}
K{\footnote EschFireTexture;
EschFireTexture, release;
EschFireTexture, init;
EschFireTexture, generate;
EschFireTexture, increase;
EschFireTexture, decrease;
EschFireTexture, ignite;
EschFireTexture, douse;
EschFireTexture, fireball}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschFireTexture Class}\par\pard\sb100

Fire is an extremely dynamic phenomenon and is therefore very suited to being
 generated procedurally.  This class provides this functionality.
\par

\line{\b\fs28 Name}\par

EschFireTexture - Procedural Fire Texture Class
\par

\line{\b\fs28 Synopsis}\par

#include "esmisc.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschProceduralTexture}{\v PG_ESCH_PROCTEXTURE}
\par

\line{\b\fs28 Constructors}\par

{\b EschFireTexture();}\par

Clears the internal pointers.
\par

{\b EschFireTexture(ushort w, ushort h, VngoPal *pal, int dogen=1);}\par

This clears the internal pointers and calls init().
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschProceduralTexture}{\v PG_ESCH_PROCTEXTURE}.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschProceduralTexture}{\v PG_ESCH_PROCTEXTURE}, plus :-
\par

{\b virtual void release();}\par

This releases all internal data buffers.
\par

{\b virtual esch_error_codes init(ushort w, ushort h, VngoPal *pal,
 int dogen=1);}\par

Initializes the texture.  If dogen is set, generate() is called to setup
 the first frame.
\par

{\b virtual void generate();}\par

This generates the next frame of the fire effect based on the pixels in
 the previous frame.
\par

{\b void increase(int amount=2);}\par

Increases the intensity of the fire.
\par

{\b void decrease(int amount=2);}\par

Decreases the intensity of the fire.
\par

{\b void ignite();;}\par

Ignites a new fire.
\par

{\b void douse(int smooth_it=1);}\par

Douses the fire with some 'water'.
\par

{\b void fireball(int start_fireball=1);}\par

Creates a fireball effect.
\par

\pard\page



{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°° Motion Classes °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschKeyframer Class                                                       ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_KEYFRAMER}
${\footnote EschKeyframer Class}
K{\footnote EschKeyframer}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschKeyframer Class}\par\pard\sb100

{\cf4 NOT DOCUMENTED}\line

\line{\b\fs28 Name}\par

EschKeyframer - ?
\par

\line{\b\fs28 Synopsis}\par

#include "eskeyfrm.hpp"
\par

\line{\b\fs28 Constructors}\par

\line{\b\fs28 Member Data}\par

\line{\b\fs28 Member Functions}\par

\line{\b\fs28 Flags}\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschKeyframeDraw Class                                                    ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_KFDRAW}
${\footnote EschKeyframeDraw Class}
K{\footnote EschKeyframeDraw}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschKeyframeDraw Class}\par\pard\sb100

{\cf4 NOT DOCUMENTED}\line

\line{\b\fs28 Name}\par

EschKeyframeDraw - ?
\par

\line{\b\fs28 Synopsis}\par

#include "eskeyfrm.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschDrawable}{\v PG_ESCH_DRAWABLE}
\par

\line{\b\fs28 Constructors}\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschDrawable}{\v PG_ESCH_DRAWABLE} plus :-
\par

\line{\b\fs28 Flags}\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschLimbSegment Class                                                     ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_LIMBSEG}
${\footnote EschLimbSegment Class}
K{\footnote EschLimbSegment}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschLimbSegment Class}\par\pard\sb100

{\cf4 NOT DOCUMENTED}\line

\line{\b\fs28 Name}\par

EschLimbSegment - ?
\par

\line{\b\fs28 Synopsis}\par

#include "eslimb.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschKeyframeDraw}{\v PG_ESCH_KFDRAW}
\par

\line{\b\fs28 Constructors}\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschKeyframeDraw}{\v PG_ESCH_KFDRAW} plus :-
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschKeyframeDraw}{\v PG_ESCH_KFDRAW} plus :-
\par

\line{\b\fs28 Flags}\par

\pard\page



{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°° Render Support Classes °°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschContext Class                                                         ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_CONTEXT}
${\footnote EschContext Class}
K{\footnote EschContext;
EschContext, push;
EschContext, pop}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschContext Class}\par\pard\sb100

The context class serves as the container of global status data.
 It is used to provide informational context for the various
 draw functions as well as global data for use in low-level
 drawing operations without requiring large amounts of data to be
 passed via the execution stack.
\par

{\cf3 Additional data may be added to the context, as needed.}\par

\line{\b\fs28 Name}\par

EschContext - Context Container Object
\par

\line{\b\fs28 Synopsis}\par

#include "escontxt.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschContext();}\par

Initializes the data members to empty.
\par

{\b EschContext(EschContext *ec);}\par

Copies the valid data pointers, while keeping the prev pointer NULL.
\par

\line{\b\fs28 Member Data}\par

{\b private EschContext *prev;}\par

Pointer for maintaining stack order.
\par

{\b EschCamera *camera;}\par

Points to the currently active camera.
\par

{\b EschLight *lights;}\par

Points to the currently active light.
\par

{\b EschDrawable *eschs;}\par

Points to the current list of objects to draw.
\par

{\b EschDrawable *current;}\par

Pointer to current drawable for internal draw operations.
\par

{\b EschVertex *verts;}\par

Pointer to vertex list for internal draw operations.
\par

{\b dword *vflags;}\par

Pointer to current vertex flags for internal draw operations.
\par

{\b VngoPoint *vpoints;}\par

Pointer to current vertex workspace for internal draw operations.
\par

{\b EschFace *faces;}\par

Pointer to current faces for internal draw operations.
\par

{\b dword *fflags;}\par

Pointer to current face flags for internal draw operations.
\par

{\b EschTexture **txts;}\par

Pointer to current texture objects for internal draw operations.
\par

\line{\b\fs28 Member Functions}\par

{\b void push()}\par

Places the context at the top of the stack, making it the
 current context.
\par

{\b void pop()}\par

Removes the context at the top of the stack and makes the one
 below it the current context.
\par

{\cf2
Note:  The global 'EschCurrent' points to the top of the context stack.
}\par

\line{\b\fs28 Example}\par

The following example creates a new context with a different
 light, renders it, and returns to the old context (note this can
 be done automatically with a different render() member function
 of EschCamera):
\par

{\f2
EschCamera Camera;\line
EschLight newlight;
\par
EschContext ec;\line
ec.lights = &newlight;\line
ec.push();
\par
Camera.render();
\par
ec.pop();
}
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschElement Class                                                         ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_ELEMENT}
${\footnote EschElement Class}
K{\footnote EschElement;
EschElement, insert;
EschElement, draw;
EschElement, prepare_test;
EschElement, perform_test;
EschElement, flush;
EschElement, flush_truesort;
EschPixelElement;
EschLineElement;
EschPolyElement;
EschPolyAElement;
EschPolyTxtElement;
EschPolyTxtAElement}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschElement Class}\par\pard\sb100

This class is the base class for the element sorting.  As each
 pixel, line, and face is generated by the
 {\uldb clipdraw}{\v PG_ESCH_CSTYDRAW} routines, it may be placed into
 the element sort area rather than being drawn directly.  This occurs
 if the camera is in {\i ESCH_CAM_SORT} mode or if the face has an
 alpha value.  In either case, the given element must be drawn in
 back-to-front order to ensure correct sorting/color-blending.
\par

The sort area contains a binary tree of EschElement class instances and
 any entries in the tree are drawn when the flush()/flush_truesort()
 routine is called, then the sort area is cleared.  The element list
 should be flushed after the frame is drawn.  If the gross sorting
 issues are resolved by the drawables (perhaps due to and ordered
 partitioning or specialized drawable), then the list may be flushed
 more than once per frame.
\par

{\cf3
This class and its deriviates are normally only used internally by the
 {\uldb EschCamera}{\v PG_ESCH_CAMERA} class and the
 {\uldb clipdraw}{\v PG_ESCH_CSTYDRAW} routines.  If more detailed
 information on using these classes is required, please contact
 {\uldb Charybdis Enterprises, Inc.}{\v NOTICE}
}\par

\line{\b\fs28 Name}\par

EschElement - Base element sort class
\par

\line{\b\fs28 Synopsis}\par

#include "eselemnt.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschElement(word _typ);}\par

Clears pointers and sets the type code.
\par

\line{\b\fs28 Member Data}\par

{\b float maxz;\line
float minz;\line
float maxx;\line
float minx;\line
float maxy;\line
float miny;}\par

Extent of the element for sorting.
\par

{\b word typ;}\par

Element run-time type code (see {\b Types} below).
\par

{\b ushort count;}\par

Count value used for n-sided polygons ().
\par

{\b EschElement *left;\line
EschElement *right;}\par

Binary tree pointers (left is closer).
\par

\line{\b\fs28 Member Functions}\par

{\b virtual void insert();}\par

Inserts the current instance into the binary tree.  Uses the
 {\uldb EschSystem}{\v PG_ESCH_SYSTEM} {\b sroot} member.
\par

{\b virtual void draw()=0;}\par

Draws the current instance using the {\b EschCurrent} context
 camera's viewport.
\par

{\b virtual void prepare_test(EschPoint *pt) const =0;\line
virtual BOOL perform_test(const EschPoint *pt) const =0;}\par

Used to perform point/plane tests to resolve sorting cases.
\par

{\b static void flush();}\par

Draws any pending elements in the sort area and clears it.  This also
 updates size statistics for the sort area.  The flush is O(n).
\par

{\scaps\cf4 NOT COMPLETED}\line
{\b static void flush_truesort();}\par

Operates like flush() but performs a more complex 'true' sorting
 algorithm that resolves overlapping cases not handled by z-max
 implementation.  This operation is O(n^2).
\par

\line{\b\fs28 Types}\par

{\i ESCH_ELMNT_BASE}\tab Base type.
\par

{\i ESCH_ELMNT_PIXEL}\tab Pixel ({\b EschPixelElement}).
\par

{\i ESCH_ELMNT_LINE}\tab Line ({\b EschLineElement}).
\par

\line The following are valid for {\b EschPolyElement} :-\par

{\i ESCH_ELMNT_POLY}\tab\tab\tab Polygon.
\par

{\i ESCH_ELMNT_GPOLY}\tab\tab\tab Gouraud-shaded polygon.
\par

{\i ESCH_ELMNT_GPOLY_PERSP}\tab\tab Gouraud-shaded polygon with perspective
 correction
\par

\line The following are valid for {\b EschPolyAElement} :-\par

{\i ESCH_ELMNT_POLY_A}\tab\tab Alpha-blended polygon.
\par

{\i ESCH_ELMNT_GPOLY_A}\tab\tab Gouraud-shaded alpha-blended
 polygon.
\par

{\i ESCH_ELMNT_GPOLY_PERSP_A}\tab Gouraud-shaded alpha-blended polygon
 with perspective correction.
\par

\line The following are valid for {\b EschPolyTxtElement} :-\par

{\i ESCH_ELMNT_TXTPOLY}\tab\tab Textured-mapped polygon.
\par

{\i ESCH_ELMNT_TXTPOLY_PERSP}\tab Textured-mapped polygon
 with perspective correction.
\par

{\i ESCH_ELMNT_GTXTPOLY}\tab\tab Gouraud-shaded texture-mapped polygon.
\par

{\i ESCH_ELMNT_GTXTPOLY_PERSP}\tab Gouraud-shaded texture-mapped polygon
 with perspective correction.
\par

\line The following are valid for {\b EschPolyTxtAElement} :-\par

{\i ESCH_ELMNT_TXTPOLY_A}\tab\tab Textured-mapped alpha-blended polygon.
\par

{\i ESCH_ELMNT_TXTPOLY_PERSP_A}\tab Textured-mapped alpha-blended polygon
 with perspective correction.
\par

{\i ESCH_ELMNT_GTXTPOLY_A}\tab\tab Gouraud-shaded texture-mapped alpha-blended
 polygon.
\par

{\i ESCH_ELMNT_GTXTPOLY_PERSP_A}\tab Gouraud-shaded texture-mapped
 alpha-blended polygon with perspective correction.
\par

\pard\page


{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°° Builder Classes °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschBuildTexture Class                                                    ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_BUILDTEXTURE}
${\footnote EschBuildTexture Class}
K{\footnote EschBuildTexture;
EschBuildTexture, init;
EschBuildTexture, release;
EschBuildTexture, save;
EschBuildTexture, load;
EschBuildTexture, set_texture_flags;
EschBuildTexture, add_frame;
EschBuildTexture, set_frame}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschBuildTexture Class}\par\pard\sb100

{\scaps\cf4 CHANGED}\line
Creating data files is a complex task and often requires that texture
 information be embedded for later use.  This class encapsulates the
 building of data for both static and animated textures and is used by
 other builder classes.
\par

{\cf2
Note:  This is intended for use in off-line tools to simplify generation
 of {\i Escher} compatable data files.  Therefore, direct construction of
 texture instances is not supported at this time.
}\par

{\cf2
Note:  The input bitmaps must all be of the same size.
}\par

\line{\b\fs28 Name}\par

EschBuildTexture - Texture data file builder
\par

\line{\b\fs28 Synopsis}\par

#include "esbuild.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschBuildTexture();}\par

Ensures pointer data members are cleared, but does not init the instance.
\par

{\b EschBuildTexture(ulong mf);}\par

Clears pointer data members and calls init with the given parameter.
\par

\line{\b\fs28 Member Data}\par

{\b char name[ESCH_MAX_NAME];}\par

Contains the name of the texture.  By default this is "NoName".
\par

{\b dword tflags;}\par

These texture flags are included in the data file and should be used
 for storing {\i ESCH_TXT_APP} bits with the data.  Setting other control
 bits may cause problems when the data is loaded into an active texture
 instance.  This should be set with set_texture_flags().
\par

{\b ulong nframes;}\par

Contains the number of current frames of texture bitmaps.  This should
 be treated as read-only.
\par

{\b ulong maxframes;}\par

Contains the maximum number of frames of texture bitmaps and is set
 by init().  This should be treated as read-only.
\par

{\b XFBitmap **bms;}\par

This array points to the bitmap instances added to the texture.  This
 array is allocated by init() and freed by release().  The instances of
 bitmaps are only freed if TRUE is passed to release().
\par

\line{\b\fs28 Member Functions}\par

{\b esch_error_codes init(ulong mf=1);}\par

Initializes the instance, allocating the bitmap pointer array and reseting
 the various counts, with 'mf' maximum frames.  This should be
 called before any other operation.
\par

{\b void release(int freebms=0);}\par

This releases allocated data space, freeing the individual bitmap references
 if 'freebms' is set.  init() must be called to use the builder after
 release has been used.
\par

{\b esch_error_codes save(const char *fname, dword ctrlfl=ESCH_TBLD_8BIT, VngoPal *pal=0);\line
esch_error_codes save(XFParseIFF *iff, dword ctrlfl=ESCH_TBLD_8BIT, VngoPal *pal=0);}\par

This saves the current texture data into a data file, either creating a
 new file or inserting the data into an active IFF stream.  The 'ctrlfl'
 includes control bits for how the data should be written and some options
 may require the optional 'pal' palette pointer.  See {\b Control Flags}
 below.
\par

{\b esch_error_codes load(const char *fname, const char *tname=0, VngoPal *pal=0);\line
esch_error_codes load(XFParseIFF *iff, const char *tname=0, VngoPal *pal=0);}\par

This loads texture data from an IFF data file keeping the texture data
 as {\i XFile} bitmaps rather than converting them to 8-bit {\i Van Gogh}
 textures.  The 'pal' pointer is required to load 8-bit texture data.  The
 filename version will search an entire IFF file while the other version
 checks to see if the currently pointed to chunk is the correct form
 which matches the given texture name if 'tname' is non-zero.  The memory
 is owned by the builder and should be released with 'freebms' set.
\par

{\b void set_texture_flags(dword f);}\par

This should be used to set the tflags member and clears known problematic
 control bits before setting them into tflags.
\par

{\b esch_error_codes add_frame(XFBitmap *bm);}\par

Adds a new frame to the texture.  The pointer to bm is only freed if
 release() is called with TRUE.
\par

{\b esch_error_codes set_frame(ulong i, XFBitmap *bm, int freeold=0);}\par

Overwrites an existing frame in the texture.  The pointer to the original
 bitmap is not freed unless 'freeold' is set.
\par

\line{\b\fs28 Control Flags}\par

{\i ESCH_TBLD_8BIT}\tab Writes the texture data as an 8-bit texture.
\par

{\scaps\cf4 NEW}\line
{\i ESCH_TBLD_15BIT}\tab Writes the texture data as a 15-bit texture (2 bytes/
 pixel).
\par

{\scaps\cf4 CHANGED}\line
{\i ESCH_TBLD_TC}\tab Writes the texture data as true-color.  If
 {\i ESCH_TBLD_TRANSP} is set, then 4 bytes/pixel will be used.  Otherwise
 the format will be 3 bytes/pixel.
\par

{\i ESCH_TBLD_COMPRESS}\tab Compresses the texture data using RLE.
\par

{\i ESCH_TBLD_TRANSP}\tab\tab Indicates that index 255 and/or RGB(255,0,255)
 should be treated as transparent.
\par

\line{\b\fs28 Error Codes}\par

{\i ESCH_ERR_INVALIDPARMS}\tab Input parameters or data is invalid.
\par

{\i ESCH_ERR_NOMEMORY}\tab A memory allocation failed.
\par

{\i ESCH_ERR_INVALIDSIZE}\tab A bitmap was given that was not the correct
 size for a texture.
\par

{\i ESCH_ERR_NOMORE}\tab\tab More frames were added than were allocated for
 by init().
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschBuildMesh Class                                                       ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_BUILDMESH}
${\footnote EschBuildMesh Class}
K{\footnote EschBuildMesh;
EschBuildMesh, init;
EschBuildMesh, release;
EschBuildMesh, save;
EschBuildMesh, set_mesh_flags;
EschBuildMesh, set_face_flags;
EschBuildMesh, set_self_illum;
EschBuildMesh, set_alpha;
EschBuildMesh, set_extents;
EschBuildMesh, add_vertex;
EschBuildMesh, set_vertex;
EschBuildMesh, add_face;
EschBuildMesh, set_face;
EschBuildMesh, add_texture;
EschBuildMesh, set_texture;
EschBuildMesh, compute_extents;
EschBuildMesh, compute_normals}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschBuildMesh Class}\par\pard\sb100

Creating all of the data needed for {\uldb EschMeshDraw}{\v PG_ESCH_MESHDRAW}
 objects is a complex task normally performed by the
 {\uldb Escher Exporter}{\v UG_ESCH_EXPORT} program or similiar utility.
 In some instances, however, it is necessary to create meshes directly
 via an algorithm or to implement support for some new data format.  This
 class encapsulates the building of data for for mesh drawables.
\par

{\cf2
Note:  This is intended for use in off-line tools to simplify generation
 of {\i Escher} compatable data files.  Therefore, direct construction of
 drawable instances is not supported at this time.
}\par

\line{\b\fs28 Name}\par

EschBuildMesh - Mesh data file builder
\par

\line{\b\fs28 Synopsis}\par

#include "esbuild.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschBuildMesh();}\par

Ensures pointer data members are cleared, but does not init the instance.
\par

{\b EschBuildMesh(ulong mv, ulong mf, ulong mt=256);}\par

Clears pointer data members and calls init with the given parameters.
\par

\line{\b\fs28 Member Data}\par

{\b char name[ESCH_MAX_NAME];}\par

Contains the name of the mesh.  By default this is "NoName".
\par

{\b dword mflags;}\par

{\i ESCH_MSH_} flags to save into data file.  Should be set by
 set_mesh_flags().  Setting control bits could cause problems.
\par

{\b dword fflags;}\par

Base face flags to use for add/set_face routines that don't take a full
 EschFace instance.
\par

{\b byte selfi;}\par

Self-illumination value to use for add/set_face routines that don't take
 a full EschFace instance.
\par

{\b byte alpha_a, alpha_b, alpha_c;}\par

Alpha values to use for add/set_face routines that don't take a
 full EschFace instance.
\par

{\b EschFrameRef orient;}\par

Contains the orientation matrix that is written into the data file
 if {\i ESCH_MBLD_MATRIX} is set in the save control flags.
\par

{\b ulong nverts;\line
ulong maxverts;\line
EschVertex *v;}\par

Vertex data members which should be treated as read-only.
\par

{\b ulong nfaces;\line
ulong maxfaces;\line
EschFace *f;}\par

Face data members which should be treated as read-only.
\par

{\b ulong ntxts;\line
ulong maxtxts;\line
EschBuildTexture **txt;}\par

Texture data members which should be treated as read-only.
\par

{\b EschSphereExtents sphere;}\par

Spherical extents for the mesh, which should be set by set_extents()
 or compute_extents().
\par

{\b EschBoxExtents box;}\par

Box extents for the mesh, which should be set by set_extents()
 or compute_extents().
\par

\line{\b\fs28 Member Functions}\par

{\b esch_error_codes init(ulong mv, ulong mf, ulong mt=256);}\par

Initializes the instance, creating the needed working arrays.  This
 should be called before any other routine.
\par

{\b void release(int freetxts=0);}\par

Releases memory used by the instance.  init() should be callaed
 before using another routine after a release().   If freetxts is
 set, then the EschBuildTexture instances are freed.
\par

{\b esch_error_codes save(const char *fname, dword ctrlfl=ESCH_MBLD_ALL,
 dword tcfl=ESCH_TBLD_8BIT, VngoPal *pal=0);\line
esch_error_codes save(XFParseIFF *iff, dword ctrlfl=ESCH_MBLD_ALL,
 dword tcfl=ESCH_TBLD_8BIT, VngoPal *pal=0);}\par

Saves the data contained within the instance to a data file for later
 use.  The tcfl and pal members are passed to the save member of
 any EschBuildTexture instances.
\par

{\b void set_mesh_flags(dword f);}\par

Sets the mesh flags, clearing any known problem control bits.
\par

{\b void set_face_flags(dword f);}\par

Sets the face flags, clearing any known problem bits.
\par

{\b void set_self_illum(byte s);}\par

Sets selfi value.
\par

{\b void set_alpha(byte a);}\par

Sets alpha_a, alpha_b, and alpha_c values.
\par

{\b void set_extents(const EschSphereExtents *s);\line
void set_extents(const EschBoxExtents *b);}\par

These routines set the extents of the mesh manullay.
\par

{\b esch_error_codes add_vertex(const EschVertex *vtx);\line
esch_error_codes add_vertex(const EschPoint *pnt);\line
esch_error_codes add_vertex(float ix, float iy, float iz);}\par

These routines add a new vertex.
\par

{\b esch_error_codes set_vertex(ulong i, const EschVertex *vtx);\line
esch_error_codes set_vertex(ulong i, const EschPoint *pnt);\line
esch_error_codes set_vertex(ulong i, float ix, float iy, float iz);}\par

These routines overwrite an existing vertex.
\par

{\b esch_error_codes add_face(const EschFace *face);\line
esch_error_codes add_face(word a, word b, word c, dword color);\line
esch_error_codes add_face(word a, word b, word c, dword color,
 word txt, float u[], float v[]);}\par

These routines add a new face.
\par

{\b esch_error_codes set_face(ulong i, const EschFace *face);\line
esch_error_codes set_face(ulong i, word a, word b, word c, dword color);\line
esch_error_codes set_face(ulong i, word a, word b, word c, dword color,
 word txt, float u[], float v[]);}\par

These routines overwrite an existing face.
\par

{\b esch_error_codes add_texture(EschBuildTexture *t);}\par

This routine adds a new texture.
\par

{\b esch_error_codes set_texture(ulong i, EschBuildTexture *t,
 int freeold=0);}\par

This routine overwrites an existing texture, releasing the old one if
 freeold is set.
\par

{\b esch_error_codes compute_extents(int optimal=1, int sph_only=0);}\par

This routine computes the spherical extents and the box extents (if
 sph_only is not set).  If optimal is set, then the optimal spherical
 extents are computed (which is O(N^2)) instead of the quick spherical
 extents (O(N)).
\par

{\b esch_error_codes compute_normals(int vtx_only=0);}\par

This routine computes the vertex normals and then computes the
 face normals from these (if vtx_only is not set).
\par

\line{\b\fs28 Control Flags}\par

{\i ESCH_MBLD_MATRIX}\tab Orientation matrix should be written.
\par

{\i ESCH_MBLD_EXTENTS}\tab Spherical and box extents should be written.
\par

{\i ESCH_MBLD_HEIR}\tab Reserved for future use.
\par

{\i ESCH_MBLD_MTLS}\tab Textures should be embedded into data file.
\par

{\i ESCH_MBLD_ALL}\tab All of the above.
\par

{\i ESCH_MBLD_INSCENE}\tab Output should be wrapped into a scene form.
\par

{\i ESCH_MBLD_FIXED}\tab Output should use fixed-point instead of
 floating-point format.
\par

{\i ESCH_MBLD_OLDFLOAT}\tab Output should use older floating-point
 format for the faces which had limited self-illumination and alpha
 range.
\par

\line{\b\fs28 Error Codes}\par

{\i ESCH_ERR_INVALIDPARMS}\tab Input parameters or data is invalid.
\par

{\i ESCH_ERR_NOMEMORY}\tab A memory allocation failed.
\par

{\i ESCH_ERR_NOMORE}\tab More faces, verticies, or textures were added
 than were allocated for by init().
\par

\line{\b\fs28 Example}\par

See the {\uldb Escher Lightwave Converter}{\v UG_ESCH_LW} utility
 for a complete example of using this class to generate data files.
\par

\pard\page



{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°° Math Support Classes °°°°°°°°°°°°°°°°°°°°°°°°°
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschPoint Class                                                           ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_POINT}
${\footnote EschPoint Class}
K{\footnote EschPoint;
EschPoint, operator +;
EschPoint, operator +=;
EschPoint, operator -;
EschPoint, operator -=;
EschPoint, distance;
EschPoint, transform;
EschPoint, rotatex;
EschPoint, rotatey;
EschPoint, rotatez}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschPoint Class}\par\pard\sb100

Points are positions in 3-space.  They can be operated upon by
 various arithmetic operations, transformed by a matrix or
 frame-of-reference, or rotated about an axis.
\par

{\cf2
Note:  EschPoints are setup such that VngoPoints may be cast to the EschPoint
 type and operated upon with EschPoint member functions.  The components x,
 y, and z match up with {\i Van Gogh}'s wx, wy, and wz components.  The 'na'
 component is never affected by the EschPoint routines to ensure data in
 a VngoPoint cast to an EschPoint will not be overwritten.
}\par

\line{\b\fs28 Name}\par

EschPoint - Arithmetic 3D Point
\par

\line{\b\fs28 Synopsis}\par

#include "esmath.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschPoint();}\par

Does not initialize any data.
\par

{\b EschPoint(float ix, float iy, float iz);}\par

Assigns the ix, iy, and iz parameters as the values of the x, y,
 and z data members.
\par

\line{\b\fs28 Member Data}\par

{\b float x;}\par

X-position in 3-space.
\par

{\b float y;}\par

Y-position in 3-space.
\par

{\b float z;}\par

Z-position in 3-space.
\par

{\b dword na;}\par

Reserved for padding.
\par

\line{\b\fs28 Member Functions}\par

{\b EschPoint operator + (const EschVector &v) const;\line
EschPoint operator += (const EschVector &v);}\par

Addition of a vector to a point.
\par

{\b EschPoint operator + (const EschPoint &b) const;\line
EschPoint operator += (const EschPoint &b);}\par

Component-wise addition of points.
\par

{\b EschPoint operator - (const EschVector &v) const;\line
EschPoint operator -= (const EschVector &v);}\par

Subtraction of a vector from a point.
\par

{\b EschPoint operator - (const EschPoint &b) const;\line
EschPoint operator -= (const EschPoint &b);}\par

Component-wise subtraction of points.
\par

{\b EschPoint operator - () const}\par

Component-wise negation of a point.
\par

{\b float distance(const EschPoint *p) const;}\par

Returns the distance between this point and another point.
\par

{\b void transform(EschMatrix *m);\line
void transform(EschFrameRef *m);}\par

Transforms the point by the given matrix or frame-of-reference,
 storing the result back into the point.
\par

{\b void transform(const EschMatrix *m, EschPoint *result) const;\line
void transform(const EschFrameRef *m, EschPoint *result) const;}\par

Transforms the point by the given matrix or frame-of-reference,
 storing the result into another point.
\par

{\b void rotatex(const float degrees);\line
void rotatex(const float degrees, EschPoint *result) const;}\par

Rotates the point about the X-axis, storing result back into
 another point.
\par

{\b void rotatey(const float degrees);\line
void rotatey(const float degrees, EschPoint *result) const;}\par

Rotates the point about the Y-axis, storing result back into
 another point.
\par

{\b void rotatez(const float degrees);\line
void rotatez(const float degrees, EschPoint *result) const;}\par

Rotates the point about the Z-axis, storing result back into
 another point.
\par

\line{\b\fs28 Example}\par

The following example performs some simple operations on points:
\par

{\f2
EschPoint a(1,1,1);
\par
EschPoint b(32,-3,2);
\par
EschPoint c;
\par
c = a+b;
\par
b.rotatey(89);
\par
c.rotatex(23);
\par
a = b-c;
}
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschVector Class                                                          ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_VECTOR}
${\footnote EschVector Class}
K{\footnote EschVector;
EschVector, operator +;
EschVector, operator +=;
EschVector, operator -;
EschVector, operator -=;
EschVector, operator *;
EschVector, operator *=;
EschVector, operator /;
EschVector, operator /=;
EschVector, operator CROSS;
EschVector, operator DOT;
EschVector, magnitude;
EschVector, normalize;
EschVector, scale;
EschVector, translate;
EschVector, transform;
EschVector, rotatex;
EschVector, rotatey;
EschVector, rotatez}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschVector Class}\par\pard\sb100

Vectors are directions in 3-space.  They can be operated upon by
 various arithmetic operations, transformed by a matrix or
 frame-of-reference, or rotated about an axis similarly to
 points.  In addition, they are subject to vector products and
 other vector operations.
\par

\line{\b\fs28 Name}\par

EschVector - Arithmetic 3D Vector
\par

\line{\b\fs28 Synopsis}\par

#include "esmath.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschVector();}\par

Does not initialize any data.
\par

{\b EschVector(float ii, float ij, float ik);}\par

Assigns the ii, ij, and ik parameters as the values of the i, j,
 and k data members.
\par

{\b EschVector(const EschPoint &p1, const EschPoint &p2);}\par

Creates a vector from two points, starting at p1 and headed to p2.
\par

\line{\b\fs28 Member Data}\par

{\b float i;}\par

I-component of vector.
\par

{\b float j;}\par

J-component of vector.
\par

{\b float k;}\par

K-component of vector.
\par

{\b dword na;}\par

Reserved for padding.
\par

\line{\b\fs28 Member Functions}\par

{\b EschVector operator + (const EschVector &b) const;\line
EschVector operator += (const EschVector &b);}\par

Component-wise addition of vectors.
\par

{\b EschVector operator - (const EschVector &b) const;\line
EschVector operator -= (const EschVector &b);}\par

Component-wise subtraction of vectors.
\par

{\b EschVector operator - () const;}\par

Component-wise negation of a vector.
\par

{\b EschVector operator + (const float scalar) const;\line
EschVector operator += (const float scalar);}\par

Addition of a scalar to each component of a vector.
\par

{\b EschVector operator - (const float scalar) const;\line
EschVector operator -= (const float scalar);}\par

Subtraction of a scalar from each component of a vector.
\par

{\b EschVector operator * (const float scalar) const;\line
EschVector operator *= (const float scalar);}\par

Multiplication of the vector's components by a scalar.
\par

{\b EschVector operator / (const float scalar) const;\line
EschVector operator /= (const float scalar);}\par

Division of the vector's components by a scalar.
\par

{\b EschVector operator CROSS (const EschVector &v) const;}\par

Forms a cross-product between two vectors.
\par

{\cf2
Note:  CROSS is actually a define for &.  This means that the
 precedence of the operation is lower than one would expect, so
 be sure to use parenthesis to force the proper precedence.
}\par

{\b float operator DOT (const EschVector &v) const;}\par

Forms a dot-product between two vectors.
\par

{\cf2
Note:  DOT is actually a define for |.  This means that the
 precedence of the operation is lower than one would expect, so
 be sure to use parenthesis to force the proper precedence.
}\par

{\b float magnitude();}\par

Computes the magnitude of the vector.
\par

{\b void normalize();}\par

Normalizes the vector, resulting in unit length.
\par

{\b void scale(float scale);}\par

Multiplies each component by the scale factor.
\par

{\b void translate(float ix, float iy, float iz);
void translate(const EschVector *v);}\par

Translates the vector by the given inputs.
\par

{\b void transform(const EschMatrix *m);\line
void transform(const EschFrameRef *m);}\par

Transforms the vector by the given matrix or frame-of-reference,
 storing the result back into the vector.
\par

{\b void transform(const EschMatrix *m, EschVector *result) const;\line
void transform(const EschFrameRef *m, EschVector *result) const;}\par

Transforms the vector by the given matrix or frame-of-reference,
 storing the result into another vector.
\par

{\b void rotatex(const float degrees);\line
void rotatex(const float degrees, EschVector *result) const;}\par

Rotates the vector about the X-axis, storing result back into
 another vector.
\par

{\b void rotatey(const float degrees);\line
void rotatey(const float degrees, EschVector *result) const;}\par

Rotates the vector about the Y-axis, storing result back into
 another vector.
\par

{\b void rotatez(const float degrees);\line
void rotatez(const float degrees, EschVector *result) const;}\par

Rotates the vector about the Z-axis, storing result back into
 another vector.
\par

\line{\b\fs28 Example}\par

This example performs various operations with vector objects:
\par

{\f2
EschVector v1(3,-2,3);
\par
EschVector v2(-2,1,6);
\par
EschVector v3;
\par
v3 = v1 CROSS v2;
\par
v3.normalize();
}
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschPlane Class                                                           ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_PLANE}
${\footnote EschPlane Class}
K{\footnote EschPlane;
EschPlane, normalize;
EschPlane, nearest;
EschPlane, distance;
EschPlane, project;
EschPlane, ray;
EschPlane, transform}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschPlane Class}\par\pard\sb100

{\scaps\cf4 CHANGED}\line
A plane is an infinite area located in 3-space.  This representation uses
 the normal and distance used in the implicit formulation:
\par

{\f2 Ax + By + Cz + D = 0}\par
\par

If the plane is normalized, then (A,B,C) form the normal of the plane and
 D is the distance from the origin to the plane.  For this class, the
 plane is assumed to be normalized.
\par

\line{\b\fs28 Name}\par

EschPlane - Arithmetic Infinite Plane
\par

\line{\b\fs28 Synopsis}\par

#include "esmath.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschPlane();}\par

Does not initialize any data.
\par

{\b EschPlane(float ia, float ib, float ic, float id);}\par

Assigns the parameters into the data members (assumes ia,ib,ic are
 normalized).
\par

{\scaps\cf4 NEW}\line
{\b EschPlane(float ia, float ib, float ic, float ix, float iy, float iz);}\par

Assigns the parameters into the data members (assumes ia,ib,ic are
 normalized) computing dist from a point on the plane (ix,iy,iz).
\par

{\b EschPlane(const EschVector &in, float id);}\par

Assigns the parameters into the data members.
\par

\line{\b\fs28 Member Data}\par

{\b EschVector normal;}\par

Normal vector (A B C).
\par

{\b float dist;}\par

Distance (D).
\par

\line{\b\fs28 Member Functions}\par

{\b void normalize();}\par

This normalizes the plane equation by making A,B,C a unit vector, adjusting
 D accordingly.
\par

{\b void nearest(const EschPoint *p, EschPoint *result) const;}\par

Computes the point on the plane nearest point 'p'.  This assumes that
 'normal' is a unit vector.
\par

{\b float distance(const EschPoint *p) const;}\par

Returns the signed distance from point p to plane.  It is positive if the
 point is on the same side as the normal, negative if behind, zero if on
 the plane.  This assumes that 'normal' is a unit vector.
\par

{\b void project(EschVector *v, EschVector *result) const;}\par

Computes the projection of a vector 'v' onto the plane.
\par

{\scaps\cf4 CHANGED}\line
{\b float ray(const EschPoint *pt, const EschVector *v) const;}\par

Computes the ray-plane intersection and returns the distance or -1 if no
 hit.
\par

{\scaps\cf4 CHANGED}\line
{\b void transform(const EschMatrix *m, const EschMatrix *im);\line
void transform(const EschFrameRef *m);\line
void transform(const EschMatrix *m, const EschMatrix *im, EschPlane *result) const;\line
void transform(const EschFrameRef *m, EschPlane *result) const;}\par

Transforms the plane by a given matrix/frame-of-reference.  Unlike other
 transform by matrix calls, however, this requires the {\i inverse} of
 the transformation matrix (which is already part of an {\b EschFrameRef}) as
 well as the forward transform matrix.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschVertex Class                                                          ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_VERTEX}
${\footnote EschVertex Class}
K{\footnote EschVertex}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschVertex Class}\par\pard\sb100

A vertex is a 3-space location with an associated normal vector.
 It inherits the operations available to a point, as well as
 including a vector instance.
\par

\line{\b\fs28 Name}\par

EschVertex - Arithmetic 3D Point with Normal.
\par

\line{\b\fs28 Synopsis}\par

#include "esmath.hpp"
\par

\line{\b\fs28 Base Classes}\par

{\uldb EschPoint}{\v PG_ESCH_POINT}
\par

\line{\b\fs28 Constructors}\par

{\b EschVertex();}\par

Does not initialize any data.
\par

{\b EschVertex(float ix, iy, iz, ii, ij, ik);\line
EschVertex(float ix, float iy, float iz, const EschVector *n);\line
EschVertex(const EschPoint *p, const EschVector *n);\line
EschVertex(const EschPoint *p, float ii, float ij, float ik);}\par

Assigns the parameters into the data members.
\par

\line{\b\fs28 Member Data}\par

Same as {\uldb EschPoint}{\v PG_ESCH_POINT}, plus :-
\par

{\b EschVector normal;}\par

Normal vector for vertex.
\par

\line{\b\fs28 Member Functions}\par

Same as {\uldb EschPoint}{\v PG_ESCH_POINT}.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschMatrix Class                                                          ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_MATRIX}
${\footnote EschMatrix Class}
K{\footnote EschMatrix;
EschMatrix, operator *;
EschMatrix, operator *=;
EschMatrix, concat;
EschMatrix, det;
EschMatrix, inverse;
EschMatrix, reset}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschMatrix Class}\par\pard\sb100

This class is used to contain the matrix data which forms the
 basic component of the transformation system.  A matrix is a 4x4
 homogenous matrix where the final column vector is always
 assumed to be [0 0 0 1].
\par

\line{\b\fs28 Name}\par

EschMatrix - Transformation Matrix Container Object.
\par

\line{\b\fs28 Synopsis}\par

#include "esmath.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschMatrix();}\par

Performs a reset of the matrix to the identity.
\par

{\b EschMatrix(int dummy);}\par

Leaves the matrix completely uninitialized.
\par

{\b EschMatrix(float a, b, c, d, e, f, g, h, i, j, k, l);}\par

Initializes the matrix with the given values.
\par

\line{\b\fs28 Member Data}\par

{\b float mtx[3*4];}\par

This contains the matrix data.  The following is a diagram of
 the layout of the matrix:
\par

mtx[ESCH_MTX_A]\tab mtx[ESCH_MTX_B]\tab mtx[ESCH_MTX_C]\tab 0\line
mtx[ESCH_MTX_D]\tab mtx[ESCH_MTX_E]\tab mtx[ESCH_MTX_F]\tab 0\line
mtx[ESCH_MTX_G]\tab mtx[ESCH_MTX_H]\tab mtx[ESCH_MTX_I]\tab 0\line
mtx[ESCH_MTX_J]\tab mtx[ESCH_MTX_K]\tab mtx[ESCH_MTX_L]\tab 1\line
\par

\line{\b\fs28 Member Functions}\par

{\b EschMatrix operator * (const EschMatrix &b) const;\line
EschMatrix operator *= (const EschMatrix &b);}\par

Multiplication of two matricies.
\par

{\b void concat(const EschMatrix *m);\line
void concat(const EschMatrix *m, EschMatrix *result) const;}\par

Concatenates via a matrix multiply another matrix with the
 current matrix, storing the result in the current matrix or in
 another matrix.
\par

{\b float det();}\par

Computes the determinant of the matrix.
\par

{\b void inverse();\line
void inverse(EschMatrix *result) const;}\par

Computes the inverse of the matrix, storing the result in the
 current matrix or in another matrix.  The computation of the
 inverse takes a relatively large number of operations, so this
 should be used only sparingly.
\par

{\b void reset();}\par

Resets the matrix to the identity.
\par

\line{\b\fs28 Example}\par

This example performs some operations on a matrix object:
\par

{\f2
EschMatrix m1;\line
EschMatrix m2;
\par
m1.mtx[ESCH_MTX_A] = 3.35;\line
m1.mtx[ESCH_MTX_B] = -8.20;\line
m1.mtx[ESCH_MTX_C] = 1.0;\line
m1.mtx[ESCH_MTX_D] = 7.44;\line
m1.mtx[ESCH_MTX_E] = -2.53;\line
m1.mtx[ESCH_MTX_F] = 9.3;\line
m1.mtx[ESCH_MTX_G] = 0.0;\line
m1.mtx[ESCH_MTX_H] = 2.0;\line
m1.mtx[ESCH_MTX_I] = -8.8;\line
m1.mtx[ESCH_MTX_J] = 4.2;\line
m1.mtx[ESCH_MTX_K] = 0.23;\line
m1.mtx[ESCH_MTX_L] = -2.3;
\par
m1.inverse(&m2);
\par
// Inverse of m1 now in m2
\par
m1.concat(&m2);
\par
// Resulting matrix in m1 is identity since\line
// m1 * m1-1 = I
}
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
EschFrameRef Class                                                        ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote PG_ESCH_FRAMEREF}
${\footnote EschFrameRef Class}
K{\footnote EschFrameRef;
EschFrameRef, get_position;
EschFrameRef, set_position;
EschFrameRef, set_top;
EschFrameRef, set_direction;
EschFrameRef, rotatex;
EschFrameRef, rotatey;
EschFrameRef, rotatez;
EschFrameRef, rotate;
EschFrameRef, pitch;
EschFrameRef, yaw;
EschFrameRef, roll;
EschFrameRef, translate;
EschFrameRef, move;
EschFrameRef, scale;
EschFrameRef, orthogonalize;
EschFrameRef, orthogonalize_top;
EschFrameRef, orthogonalize_right;
EschFrameRef, concat;
EschFrameRef, reset;
EschFrameRef, compute_inverse}
+{\footnote BW_PG_A}
{\b\f0{\cf2\scaps Programmer's Guide: Escher}\line\fs32 EschFrameRef Class}\par\pard\sb100

Frames-of-reference encapsulate the orientation and position
 information for an object, camera, or other item in 3-space.
 The direction vector is the direction of the local coordinate's
 positive Z in the parent coordinate system.
\par

When the frame-of-reference is altered by a transform routine, the
 inverse matrix needs to be updated to ensure the iorient matrix is
 correct.  In addition, rotated matricies need to be orthonormalized
 to remove shears and scaling introduced by errors in the rotation
 math.  By default, all of the routines properly update the inverse
 and the rotates will orthonormalize every {\i ESCH_MAX_ORTHOCOUNT}
 rotations.
\par

When multiple transformations are applied to a frame-of-reference
 in sequence, it may be desirable to only update the inverse and
 possibly orthonormalize at the end of the sequence.  To prevent
 a routine from performing these automatic functions, the 'update'
 flag may be set to 0 (or only include the desired {\i ESCH_UPD_}
 bits).  If values other than the default are used, care must be take
 to ensure that the correct compute() routine is called before using
 the frame-of-reference.  For a list of recognized flags, see {\b Update
 Flags} below.
\par

{\cf3
The use of scale factors has not been throughly tested.
}\par

\line{\b\fs28 Name}\par

EschFrameRef - Frame-of-reference Container Object.
\par

\line{\b\fs28 Synopsis}\par

#include "esmath.hpp"
\par

\line{\b\fs28 Constructors}\par

{\b EschFrameRef();}\par

Initializes the frame-of-reference to the identity.
\par

{\b EschFrameRef(int dummy);}\par

Leaves the frame-of-reference completely uninitalized.
\par

{\b EschFrameRef(float a, b, c, d, e, f, g, h, i, j, k, l, ii, ij, ik, s=1);}\par

Initializes the orientation matrix, direction vector, and scale factor with
 the given parameters.
\par

{\b EschFrameRef(EschMatrix *m, float s=1);}\par

Initializes the orientation matrix and direction vector with
 data contained within a matrix and sets the scale factor.
\par

\line{\b\fs28 Member Data}\par

{\b EschMatrix orient;}\par

Orientation/position matrix for frame-of-reference.
\par

{\b EschVector dir;}\par

Direction vector for frame-of-reference.
\par

{\b EschMatrix iorient;}\par

Inverse transformation matrix.
\par

{\b float scalef;}\par

The scale factor for the matrix.  This is needed so that
 orthogonalize can restore the scale factor.
\par

{\b dword ortho_count;}\par

Count for automatic orthogonalization due to accumulated
 rotates.  When this number reaches {\i ESCH_MAX_ORTHOCOUNT}, then the
 rotate functions will call orthogonalize and reset this member
 to 0.
\par

\line{\b\fs28 Member Functions}\par

{\b void get_position(EschPoint *pt) const;\line
void get_position(float *ix, float *iy, float *iz) const;}\par

Returns the position implicit in the orientation matrix.
\par

{\b void set_position(const EschPoint *pt, dword update=ESCH_UPD_ALL);\line
void set_position(const float ix, const float iy, const float iz, dword update=ESCH_UPD_ALL);}\par

Sets the position implicit in the orientation matrix from the
 point or parameters given and updates the inverse.
\par

{\b void set_top(const EschVector *v, dword update=ESCH_UPD_ALL);\line
void set_top(float ii, float ij, float ik, dword update=ESCH_UPD_ALL);}\par

Sets the top vector implicit in the frame of reference and updates the
 inverse information.
\par

{\b void set_direction(const EschVector *v, dword update=ESCH_UPD_ALL);\line
void set_direction(float ii, float ij, float ik, dword update=ESCH_UPD_ALL);}\par

Sets the direction vector of the frame of reference and updates the inverse
 information.
\par

{\b void rotatex(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about the X-axis to the orientation matrix
 and updates the direction vector and inverse information.
 Orthonormalization is performed, if needed.
\par

{\b void rotatey(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about the Y-axis to the orientation matrix
 and updates the direction vector and inverse information.
 Orthonormalization is performed, if needed.
\par

{\b void rotatez(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about the Z-axis to the orientation matrix
 and updates the direction vector and inverse information.
 Orthonormalization is performed, if needed.
\par

{\b void rotate(const EschVector *v, const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about an arbitrary axis to the orientation
 matrix and updates the direction vector and inverse information.
 Orthonormalization is performed, if needed.
\par

{\b void pitch(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about the frame's current X axis and updates
 the direction vector and inverse information.
 Orthonormalization is performed, if needed.
\par

{\b void yaw(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about the frame's current Y axis and updates
 the direction vector and inverse information.
 Orthonormalization is performed, if needed.
\par

{\b void roll(const float degrees, dword update=ESCH_UPD_ALL);}\par

Appends a rotation about the frame's current Z axis and updates
 the direction vector and inverse information.
 Orthonormalization is performed, if needed.
\par

{\b void translate(const float idx, const float idy, const float idz, dword update=ESCH_UPD_ALL);\line
void translate(const EschVector *v, dword update=ESCH_UPD_ALL);}\par

Appends a translation to the orientation matrix and updates the
 inverse.
\par

{\b void move(const float idx, const float idy, const float idz, dword update=ESCH_UPD_ALL);\line
void move(const EschVector *v, dword update=ESCH_UPD_ALL);}\par

Appends a translation given in local coordinates to the
 orientation matrix and updates the inverse.
\par

{\b void scale(const float is, dword update=ESCH_UPD_ALL);}\par

Appends a scale to the orientation matrix and updates the
 inverse.
\par

{\b void orthogonalize(dword update=ESCH_UPD_ALL);\line
void orthogonalize_top(dword update=ESCH_UPD_ALL);\line
void orthogonalize_right(dword update=ESCH_UPD_ALL);}\par

Forces the orientation components of the frame-of-reference into
 an orthonormal basis to remove accumulated errors from rotations.  It
 will then update the inverse.  The standard version uses the
 direction vector as the first basis (the first basis is only normalized
 by the process), then the 'top' vector, and finally the 'right'.  The _top
 version uses the 'top' vector as the first basis, then the direction
 vector, and finally the 'right' vector.  The _right version uses the
 'right' vector as the first basis, then the direction vector, and finally
 the 'top' vector.
\par

{\b void concat(const EschFrameRef *m);\line
void concat(const EschFrameRef *m, EschFrameRef *result) const;}\par

Concatenates via a matrix multiply another frame-of-reference
 with the current frame-of-reference, storing the result in the
 current frame-of-reference or in another frame-of-reference,
 including the inverse.
\par

{\b void reset();}\par

Resets the frame-of-reference, including the inverse, to the
 identity.
\par

{\b void compute_inverse();}\par

This support routine will compute the inverse information from
 the current orientation matrix and direction vector.  This uses
 the inverse function, so it requires a relatively large number
 of operations.
\par

\line{\b\fs28 Update Flags}\par

{\i ESCH_UPD_INVERSE}\tab Indicates the transform routine should recompute
 the inverse matrix.
\par

{\i ESCH_UPD_ORTHO}\tab Indicates the rotate transform routine should
 call orthonormalize() if the ortho_count exceeds {\i ESCH_MAX_ORTHOCOUNT}.
\par

{\i ESCH_UPD_ALL}\tab Indicates all required updating should be performed.
\par

\line{\b\fs28 Example}\par

Creates a frame of reference with a few operations and performs
 a transform of a point:
\par

{\f2
EschPoint p(1,1,1);
\par
EschFrameRef fr;
\par
fr.rotatex(32);
\par
fr.rotatey(-93);
\par
fr.translate(-2,4,2);
\par
p.transform(&fr);
}
\par

\pard\page


{\comment
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°

                               User's Guide

°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
}

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
Overview                                                                  ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote UG_ESCH_OVERVIEW}
${\footnote Overview}
+{\footnote BW_UG_5}
{\b\f0{\cf2\scaps User's Guide: Escher}\line\fs32 Overview}\par\pard\sb100

This document describes the use of the utilities supplied with
 the {\i Escher} library.  Since creating and editing 3D data is best
 done with dedicated applications, such as 3D Studio or VistaPro,
 {\i Escher} does not include a geometry modeller.  These utilities
 provide data capture and conversion to move information between supported
 data editors and programs that utilize the {\i Escher} library.  A few
 interactive editors are also provided for working with terrain data sets
 and viewing of exported models.
\par

\line{\b\fs28 Features}\par

File directory utility to view contents of exported files.
\par

3D Studio Object and Data Exporter for easy creation and reuse
 of models.
\par

Simple converter utility for Lightwave data files.
\par

Texture librarian tool for creating and manipulating the texture data
 contained within exported files.
\par

Data file viewer and editing tool for viewing and touch-up of
 exported models.
\par

Terrain data editor utility for creating terrain data sets.
\par

\line{\b\fs28 Future Work}\par

As the need arises, other data conversion utilities may be added
 to support other editors and exploit available datasets.
\par

\pard\page

{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
Escher Directory                                                          ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote UG_ESCH_DIR}
${\footnote Escher Directory}
K{\footnote ESHDIR}
+{\footnote BW_UG_5}
{\b\f0{\cf2\scaps User's Guide: Escher}\line\fs32 Escher Directory}\par\pard\sb100

IFF files are used to store object data and other information
 for later loading by the {\i Escher} library.  This utility displays
 {\i Escher} related information contained within the given IFF file.
\par

\line{\b\fs28 Usage}\par

eshdir [ -p ] <filename.iff>
\par

\line{\b\fs28 Options}\par

{\b -p}\par

By default, the display scrolls without pausing.  Using this
 option causes the display to pause at the end of each screen.
\par

\line{\b\fs28 Example}\par

To display the contents of the file EXPORT.IFF while pausing
 after each screen, type the following:
\par

{\f2
eshdir -p export.iff
\par
}

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
Escher Exporter                                                           ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote UG_ESCH_EXPORT}
${\footnote Escher Exporter}
K{\footnote ESPORT - IPAS}
+{\footnote BW_UG_5}
{\b\f0{\cf2\scaps User's Guide: Escher}\line\fs32 Escher Exporter}\par\pard\sb100

{\scaps\cf4 CHANGED}\line
The {\i Escher} Exporter is an IPAS module for outputting data
 directly from 3D Studio Release 4 into a loadable data form
 understood by the {\i Escher} library.  The exporter creates IFF
 files containing mesh data, camera parameters, and lights
 directly from the currently loaded 3D Studio data.
\par

\line{\b\fs28 Installation}\par

To install the exporter, copy ESPORT_I.PXP into the PROCESS
 subdirectory of 3D Studio.  Then edit the 3DS.SET file and
 add/edit one of the USER-PROG variables.  For example, if
 USER-PROG5 is free, then the add the following:
\par

{\f2
USER-PROG5 = "PROCESS\\ESPORT_I.PXP,"ESCHER"
}\par

Then run 3D Studio as normal.
\par

\line{\b\fs28 Usage}\par

To use the exporter, load or create the desired mesh data.  Then
 from the 3D Editor, select the Programs menu and select {\i Escher}
 from the menu (note that there should be a hot-key associated
 with the entry which may be used to directly run the exporter).
\par

If the exporter program loads correctly, then the dialog shown
 in the figure will be displayed on the screen:
\par

\{bmc esport.bmp\}\par

Once the desired source, options, and filename have been
 specified, clicking OK, or hitting the Enter key will continue
 the exporting process.  Errors with the selected options will be
 displayed at this time and allow the user to alter them by
 returning back to the dialog.  If Cancel is clicked, or the ESC
 key is pressed, then the exporting process is aborted.   A
 Yes/No dialog will verify either choice before committing to
 export or exiting back to 3D Studio.
\par

During the exporting of the data, the name of the currently
 outputting data object will be displayed on the screen.  When
 complete, control will return to 3D Studio.
\par

If Complete is selected for the materials, then the following
 dialog will appear:
\par

\{bmc esmtl.bmp\}\par

This dialog controls the exporting of the complete material's
 data.  Once the desired settings are made, clicking on OK or
 pressing the Enter key will return to the original dialog.
\par

If Light(s) is selected, then the following dialog will appear:
\par

\{bmc eslight.bmp\}\par

This dialog controls the exporting of the light sources.  Once the desired
 settings are made, clicking on OK or pressing the Enter key will
 return to the original dialog.
\par

The startup defaults for these dialogs can be controlled by
 editing the ESPORT.INI file which should be located in the 3D
 Studio process directory.
\par

\line{\b\fs28 Options}\par

{\b M A I N   D I A L O G}\par

{\b Source: All vs. Selected vs. Keyframes Only}\par
{\scaps Short-cut keys:  A for All, S for Selected, K for Keyframes Only}\par

This option determines which objects, if any, are exported to
 the file.  All, the default, will cause all objects currently
 loaded in 3D Studio to be included in the export process.
 Selected will only include those objects which are currently
 'selected' (displayed in red wireframe).  Hidden objects are
 always skipped.  For more information on selection, see the 3D
 Studio documentation.
\par

{\b Target}\par
{\scaps Short-cut key:  T}\par

Clicking on the target filename selection will bring up a
 standard 3D Studio file selector box, allowing the user to
 select the destination file.  If the file selected already
 exists, a overwrite Yes/No dialog box is displayed.  Only the
 filename is displayed within the target box, although the drive
 and path specified are used during export.  The default is taken
 from the 3DS mesh filename, if any.  Otherwise it is
 C:\\EXPORT.IFF.
\par

{\b Scene Name}\par

This edit field is used as the name for the scene exported into
 the file.  This name can be used later to load the entire scene
 including all exported data.  The default is the root of the 3D
 Studio mesh filename, otherwise EXPORT.
\par

{\b Object Local Coordinates:  Local vs. World}\par
{\scaps Short-cut key:  L for Local, W for World}\par

This option determines how the object data is saved into the
 file.  Local, the default, stores all object coordinates
 relative to the position of the object, thus making the origin
 of the object's coordinate system the object's pivot or center
 point.  World outputs the data using the coordinates within the
 scene.
\par

{\cf2 Note:  This is subject to the current scaling factor.}\par

{\b Object Extents:  Quick vs. Optimal.}\par
{\scaps Short-cut keys:  Q for Quick, O for Optimal}\par

This option controls how the object extents are computed.
 Quick, the default, simply uses the bounding box of the object
 in 3D Studio and then sets the radial extents to the furthest of
 these.  Optimal computes the minimum radial extent that encloses
 the object.  Note: The extent information is subject to the
 scaling factor.
\par

{\b Object Hierarchy:  None vs. Links}\par
{\scaps Short-cut keys: N for None, I for Links}\par

This option controls whether or not object hierarchy information
 is included in the export file.  None, the default, does not
 include this information.  Links will use the link information
 established in the Keyframer for all objects involved in the
 export to determine the relationship of the objects.  This
 information is placed into the file for later rebuilding by
 {\i Escher}.
\par

{\b Object Orientation:  Default vs. Matrix}\par
{\scaps Short-cut keys: D for Default, M for Matrix}\par

This option controls whether or not object orientation
 information is included in the export file.  Default does not
 include this information.  Matrix will include the orientation
 matrix associated with each object.  This information can be
 loaded by {\i Escher} to reconstruct the position and orientation of
 the objects.
\par

{\scaps\cf4 NEW}\line
{\b Vertex Mode: Normal vs. Merge}\par
{\scaps Short-cut keys: R for Normal, G for Merge}\par

This option controls whether or not the exporter will merge identical
 verticies within a single object.  This is useful for when you must
 use elements to assign textures but want all verticies to be shared
 for smoothing and performance reasons.
\par

{\b Data Format:  Float vs. Fixed}\par
{\scaps Short-cut keys: F for Float, X for Fixed}\par

This option controls which data format is used for numeric values.  The
 newest version of {\i Escher} can load both formats, but older versions
 can only load Fixed format data.
\par

{\b Scale Factor}\par

In order to allow easy conversion of data from 3D Studio to
 {\i Escher}, a scaling parameter is included to convert 3D Studio
 units into {\i Escher} units (which are application defined).  The
 two edit fields may contain any non-zero, positive number.  The
 ratio between them is used as the scaling factor.  The default
 is 1.0 3D Studio units to every 1.0 {\i Escher} units.
\par

{\b Object Flags: 0-F}\par
{\scaps Short-cut keys: 0 to 9 (no short cuts for A-F)}\par

Objects in {\i Escher} have associated flags, the lower word of which
 are completely undefined and for use by the application.
 Setting these toggles cause the output objects to have the
 associated flag set.
\par

{\b Material Data:  Partial vs. Complete}\par
{\scaps Short-cut keys: P for Partial, C for Complete}\par

The name of the materials information associated with the faces
 of each objects is always included in the data file, but the
 full material information in not always included.  If materials
 are shared between files, it is likely the data will be
 identical, so the materials data should be stored once and only
 partial information (i.e., the name of the material and the
 basic color of the face) should be stored in the object files.
 Partial, the default, only includes this basic information.
 Complete includes the data records for all materials used by the
 exported objects.
\par

{\b Include:  Camera(s) Light(s)}\par
{\scaps Short-cut keys: Ctrl-C for Camera(s), Ctrl-L for Light(s)}\par

{\i Escher} can load camera and light position information as well as
 mesh data from exporter files, with these options specifying if
 the information is to be included in the output file.  The
 default is for both options to be turned off.  When Light(s) is
 selected, the Light control dialog is displayed.
\par

{\cf2 Note:  The position information exported is subject to
 the scaling factor.}\par

{\b Include: Keyframes}\par
{\scaps Short-cut key: Ctrl-K}\par

{\cf4 NOT DOCUMENTED}\par

{\b !}\par
{\scaps Short-cut key: !}\par

This displays information about the exporter program, including
 the release date.
\par

\line{\b M A T E R I A L S   C O N T R O L   D I A L O G}\par

{\b Palette}\par
{\scaps Short-cut key: P}\par

All material bitmaps are exported as 8-bit images resized to a
 specific range of sizes.  They are automatically recolored to
 use the {\i Van Gogh} palette specified in this field.
\par

Clicking on the palette filename selection will bring up a
 standard 3D Studio file selector box, allowing the user to
 select a {\i Van Gogh} palette file.
\par

If the file doesn't exist, an error will be displayed.  Only the
 filename is displayed within the palette box, although the drive
 and path specified are used during export.  The default is taken
 from the 3DS process path with ESPORT.VGP appended to the end.
\par

{\b Bitmap Size: Power of 2 vs. Set vs. Query}\par
{\scaps Short-cut keys:  2 for Power of 2, S for Set, Q for Query}\par

This option determines the size of any exported material
 bitmaps.  Power of 2 will resize the bitmap to the nearest power
 of 2 to the actual bitmap size, choosing from 16, 32, 64, 128,
 or 256.  Set will force the resize to be the size of the X and Y
 fields.  Query will ask the user before exporting each texture for
 the desired size.
\par

{\b Format: 8-bit vs. Truecolor}\par
{\scaps Short-cut keys:  8 for 8-bit, T for Truecolor}\par

This option determines the format of the texture data.  The 8-bit mode
 will recolor all textures to the given palette and save the data
 as 1 byte per pixel, with 255 as the transparent color for opacity
 maps.  The Truecolor mode will store the RGBs as 24-bits for opaque
 textures and 32-bits for transparent textures.
\par

{\b Compressed}\par

This option controls whether or not the texture data is compressed using
 an RLE compression technique.
\par

{\cf2 Note:  Texture data stored as 8-bit uncompressed is the fastest
 to load.  If using Truecolor 24-bit/32-bit data, the compressed
 mode is faster since there are fewer color lookups to perform at
 load time.}\par

{\b Perspective Correction:  Never vs. ^ in Name vs. Always}\par
{\scaps Short-cut keys: N for Never, ^ for ^ in Name, A for Always}\par

These options control the setting of the Allow Perspective Correction
 bit for each face using the material.  Never leaves this bit off for
 all faces exported and Always sets this bit on for all faces.  The
 ^ in Name option will set this bit on if the first character in
 the texture's name is a ^.
\par

{\cf2 Note:  Textures used on small objects shouldn't need perspective
 correction active which will save rendering time.  Large objects or
 long objects will probably need perspective correction.}\par

{\b Animated Textures: 1st Frame Only vs. Multiframe}\par
{\scaps Short-cut keys: 1 for 1st Frame Only, M for Multiframe}\par

This controls the output of FLC/FLI animated textures.  When set to
 1st Frame Only, any animated texture will be exported as a static texture
 of the first frame of the animation.  Multiframe will export the texture
 as a multiframe animated texture.
\par

{\cf2 Note:  Multiframe texture data can be loaded at run-time as either
 true multi-frame textures or as static textures with the 1st frame only.}\par

{\b !}\par
{\scaps Short-cut key: !}\par

This displays information about the exporter program, including
 the release date.
\par

\line{\b L I G H T S   C O N T R O L   D I A L O G}\par

{\b Export: Yes vs. No}\par
{\scaps Short-cut keys: Y for Yes, N for No}\par

If this is set to Yes, then lights will be exported.  Otherwise,
 no lights will be output.
\par

{\b Omni Lights: Fast vs. Point}\par
{\scaps Short-cut keys: F for Fast, P for point}\par

This controls the export of Omni lights.  When set to Fast, Omni lights
 will be exported as 'fast point lights' and if set to Point, they
 are exported as true 'point lights'.  The default is 'Fast'.
\par

{\b Spot Lights: Fast vs. Spot vs. Vector}\par
{\scaps Short-cut keys: Ctrl-F for Fast, S for Spot, V for Vector}\par

This controls the export of Spot lights.  If set to Fast, Spot lights
 will be exported as 'fast spot lights' and if set to Spot, they
 are exported as true 'spot lights'.  If set to 'Vector', a vector
 light is created from the starting and target points.  The default
 is 'Fast'.
\par

{\b Ambient}\par
{\scaps Short-cut key: A}\par

This controls the export of the Ambient light.  If set, then it is
 exported.  Otherwise, it will not be output.  The default has it
 set.
\par

{\b Attenuated}\par
{\scaps Short-cut key: T}\par

This controls the exporter's use of attenuated lights.  If set, then
 attenuated versions of the lights are output, if possible.  If not
 set, then attenuation is ignored.  The default has it set.
\par

{\b !}\par
{\scaps Short-cut key: !}\par

This displays information about the exporter program, including
 the release date.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
Escher Lightwave Converter                                                ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote UG_ESCH_LW}
${\footnote Escher Lightwave Converter}
K{\footnote ESHLW}
+{\footnote BW_UG_5}
{\b\f0{\cf2\scaps User's Guide: Escher}\line\fs32 Escher Lightwave Converter}\par\pard\sb100

This utility provides a simple conversion utility of geometry created with
 NewTek's {\i Lightwave 3D} program.  The convertor doesn't support
 conversion of texture information, but does provide an example of
 converting data files to mesh drawables.
\par

\line{\b\fs28 Usage}\par

eshlw [-q] [-i] [-d] <filename.lw>\line
\tab [-s] [-1 | -2] [-k] [-f] [-n "name" ] [-o <filename.iff>]
\par

\line{\b\fs28 Options}\par

{\b -q}\par

Directs the utility to operate quietly.
\par

{\b -i}\par

Directs the utility to print detailed information, such as the
 verticies, surface list, and polygons in the data file.
\par

{\b -d}\par

Lightwave models can include detail polygons, which are normally
 skipped since they can cause sorting errors and can greatly
 increase the face count.  This directs the utility to include
 detail polygons.
\par

\line The following options are only valid when generating output:
\par

{\b -s}\par

Wraps the exported object in a scene, which is required to load the
 object into the current {\i Escher} Tool.
\par

{\b -1}\par

Forces all polygons to be converted as one-sided faces reguardless of
 the settings in the Lightwave data file.
\par

{\b -2}\par

Forces all polygons to be converted as two-sided faces reguardless of
 the settings in the Lightwave data file.
\par

{\b -k}\par

When computing the spherical extents, the optimal method is usually
 used, which is an O(N^2) operation.  This directs the utility to
 use the quick method, which is O(N).
\par

{\b -f}\par

Normally the data is output using the floating-point data format.  This
 directs the utility to use the fixed-point data format for compatability
 with older {\i Escher} libraries and tools.
\par

{\b -n}\par

The name of the object is normally the base input filename.  This option
 provides a new string to use as the object name.
\par

{\b -o}\par

This directs the utility to generate output and to place the result in
 the given filename.  An extention of IFF is forced onto the filename.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
Escher Texture Librarian                                                  ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote UG_ESCH_TLIB}
${\footnote Escher Texture Librarian}
K{\footnote ESHTLIB}
+{\footnote BW_UG_5}
{\b\f0{\cf2\scaps User's Guide: Escher}\line\fs32 Escher Texture Librarian}\par\pard\sb100

{\scaps\cf4 CHANGED}\line
Exported data files for {\i Escher} usually include all texture information
 needed for the mesh object or terrain.  Since textures are often shared
 between meshes, they are cached in memory to prevent multiple copies of
 the same texture from being loaded.  This does not address the problem
 of multiple copies of the texture data on disk.
\par

The {\i Escher} texture librarian addresses the problem of duplicated
 data on disk by providing a method for extracting a single copy of
 each texture within one or more exported data files to generate a
 shared texture file for use with the {\b EschTexture::file_register()}
 routine.  The utility can optionally generate a remainder or
 'residual' file which contains all the data files appended together with
 their texture data removed.  Therefore, a series of exported data files
 (with full texture information) can be converted into 2 data files, one
 with texture information and one with the rest of the data.
\par

{\cf2
Note:  This can also be used to create alternate sets of texture data
 by creating several texture files using the same names and only one
 set of shared mesh/terrain data.  The selection of which texture
 file to register chooses a texture set.
}\par

In addition to this functionality, texture file entries can be created
 directly from bitmaps by this utility or bitmaps can be created from
 texture data within IFF files.  The input bitmaps must be already
 converted to the correct size and palette and be either in 8-bit,
 3 bytes/pixel, or 4 bytes/pixel mode.
\par

The input file(s) can be IFF data files for dumping to bitmaps or
 extracting texture information with an optional residual file -or-
 a CTF control file which can be used to extract from IFF data files
 or to create new texture entries directly from bitmaps.  For the
 format of a CTF file, see the {\b Language} section.
\par

\line{\b\fs28 Usage}\par

eshtlib [-q] [-d] [-u] [-x] [-f]\line
\tab <filename.iff/.ctf> [ ... <filename.iff/.ctf> ]\line
\tab [-t <filename.pal/.vgp>]\line
\tab [-o <filename.iff/.ctf>] [-r <filename.iff>]
\par

\line{\b\fs28 Options}\par

{\b -q}\par

Directs the utility to operate quietly.
\par

{\b -d}\par

Causes the utility to use the Dump Mode operation which takes the texture
 data from one or more input IFF files and creates a CTF file and a number
 of bitmaps for the textures within the input files.
\par

{\b -u}\par

When creating a new texture from a bitmap (or bitmaps), the default is to
 store the data compressed.  This changes the default to uncompressed storage.
\par

{\b -x}\par

When creating a new texture from a bitmap (or bitmaps), the default is to
 assume the 8-bit textures are opaque.  This changes the default to
 assume the 8-bit textures are transparent (color 255 is transparent).
\par

{\b -f}\par

Normal operation prompts before overwriting files.  This flag causes the
 utility to not prompt and force an overwrite.
\par

{\b -t}\par

This provides a {\i Van Gogh} palette needed for dump mode.
\par

{\b -o}\par

This provides an output filename for the texture file or for the CTF file
 for a dump operation (see {\b -d} above).  If not provided, the first
 input file is used as the basis of a new output filename with either
 .IFF (for extraction/compilation) or .CTF (for dump mode) appended.
\par

{\b -r}\par

This provides the residual output filename for extraction operations.  Any
 data in processed IFFs that is not an Escher Texture FORM is copied to
 this output file.  If this file is not provided, the residual content
 is ignored.
\par

\line{\b\fs28 Language}\par

The Charybdis Texture File source language is a simple grammer for providing
 extraction data files and creating texture entries directly from bitmap
 files.  CTF files are free-form text files which may contain assembly-style
 ';' to end-of-line comments.
\par

\line {\b extract}\par

The extract statement processes an IFF file, placing any new texture data
 contained within the data file into the texture output file and all other
 data into the optional residual output file.  The syntax of an
 extract statement is:
\par

{\f2 extract "<filename.iff>"}\par
\par

\line {\b texture}\par

The texture statement defines a new texture entry in the texture file.  This
 creates a named texture as either a single-frame static texture or as a
 multi-frame texture depending on the number of bitmaps provided.  If
 the input bitmap(s) are 8-bit, it is stored as paletted data as either
 transparent or opaque.  If the input bitmap(s) are 24-bit, it is stored
 as true-color opaque.  If the input bitmaps(s) are 32-bit, it is stored
 as true-color with alpha transparency.  The syntax of the texture
 statement is:
\par

{\f2 texture "<name string>" [ <options> ]\line
\{\line
   "<bitmap filename>" [, ... "<bitmap filename>" ]\line
\}}\par

\line The options are as follows:\par

\line {\f2 uncompressed <or> rle}\par

This indicates if the texture data should be stored compressed using
 run-length encoding or as uncompressed data.
\par

\line {\f2 flags=<number>}\par

This provides the 32-bit flags value which is stored with the texture
 data.  Only the bits {\i ESCH_TXT_APP0} (0x1000000) to {\i ESCH_TXT_APP7}
 (0x80000000) are guaranteed to be ignored by the {\i Escher} library.
\par

\line {\f2 notransparent <or> transparent}\par

This indicates that 8-bit bitmaps are either opaque or transparent (index
 255 should be skipped).
\par

\line {\f2 bpp=<number>}\par

This indicates that the texture should be stored as 1 bpp, 2 bpp (15-bit),
 3 bpp (24-bit), or 4 bpp (32-bit).
\par

\line {\b description}\par

The description statement outputs a string as the standard 'DESC' chunk in
 the output texture file.  The syntax of a description statement is:
\par

{\f2 description "<string>"}\par
\par

\line {\b copyright}\par

The copyright statement outputs a string as the standard '(C) ' chunk in
 the output texture file.  The syntax of a copyright statement is:
\par

{\f2 copyright "<string>"}\par
\par

\line {\b author}\par

The author statement outputs a string as the standard 'AUTH' chunk in
 the output texture file.  The syntax of an author statement is:
\par

{\f2 author "<string>"}\par
\par

\line {\b include}\par

An include section inserts another Charybdis Texture File source file
 into the current file and continues to generate the data file(s)
 from the data contained in it followed by the rest of the
 current CTF source file.  The syntax of an include section is:
\par

{\f2 include "<filename.ctf>"}
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
Escher Tool                                                               ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote UG_ESCH_TOOL}
${\footnote Escher Tool}
K{\footnote ESHTOOL}
+{\footnote BW_UG_5}
{\b\f0{\cf2\scaps User's Guide: Escher}\line\fs32 Escher Tool}\par\pard\sb100

{\scaps\cf4 CHANGED}\line
The purpose of the {\i Escher} Tool is to allow the interactive viewing and
 editing of data files exported by the
 {\uldb {\i Escher} Exporter}{\v UG_ESCH_EXPORT}.  It is not intended to
 replace 3D Studio as a modelling tool, but rather should be used
 as a supplimental editor and as an object viewer.
\par

{\cf3 Importing of items is not available.  Additional editing options
 and/or support for other drawable types may be added to this tool in the
 future.  Support for multiple scenes in a single file will also be added
 in the future.}\par

\line{\b\fs28 Usage}\par

The {\i Escher} Tool is a Windows 95 MFC application that
 operates using standard Windows user interface components.  The display
 consists of the following two child windows:
\par

\line{\b Tree View}\par
This window displays the meshes, lights, and cameras present within the
 scene and allows editing of individual item properties using a standard
 Windows 95 tree control.  The root item in the tree view is the scene
 name itself, with three brances underneath for meshes, lights, and cameras
 within the scene.  Within the meshes subtree, the meshes are arranged based
 upon their heirarchy, if any is present.
\par

Property sheets are accessible from the tree view for the scene itself,
 mesh objects, lights, and cameras.  New lights and cameras may also be
 created and added into the scene.  The movement options for adjusting
 mesh objects and lights require that the target item be selected within
 the tree view.  This is done with a double left click.
\par

A right mouse menu is provided that allows access to basic editing and
 viewing options directly related to individual scene items.
\par

\line{\b Viewport}\par
This window displays the current scene from a single camera using the
 {\i Escher} render engine.  The view may be moved, mesh objects moved,
 and the light source(s) adjusted to examine the render results.
 The camera attached to the viewport may be changed at any time during
 the execution of the tool.
\par

Clicking and holding down the left mouse button within the render view
 will allow mouse-controled movement, rotation, or adjustment (depending
 upon the current movement mode).
\par

A right mouse menu is provided that allows access to the render
 and movement modes.
\par

The following movement modes are provided for controlling the view:
\par

\line{\b Rotate X/Y}\par
While in this movement mode, the horizontal scroll bar will rotate the
 viewport's camera about the local Y (J) axis and the vertical scroll bar
 will rotate the view about the local X (I) axis.
\par
Holding down the left mouse button while within the render view will cause
 the viewport's camera to rotate by moving the mouse.
\par

\line{\b Move X/Y}\par
While in this movement mode, the horizontal scroll bar will move the
 viewport's camera along the local X (I) axis and the vertical scroll bar
 will move the view along the local Y (J) axis.
\par
Holding down the left mouse button while within the render view will cause
 the viewport's camera to move by moving the mouse.
\par

\line{\b Rotate Z/Move Z}\par
While in this movement mode, the horizontal scroll bar will rotate the
 viewport's camera about the local Z (K) axis and the vertical scroll bar
 will move the view along the local Z (K) axis.
\par
Holding down the left mouse button while within the render view will cause
 the viewport's camera to either rotate about Z (K) if the Shift key is held
 down, otherwise it will move along the Z (K) axis.
\par

\line{\b Rotate I/J}\par
While in this movement mode, the horizontal scroll bar will rotate a
 mesh object about the local Y (J) axis and the vertical scroll bar
 will rotate the view about the local X (I) axis.  The mesh object to be
 rotated must be highlighted in the Tree View when this option is selected.
\par
Holding down the left mouse button while within the render view will cause
 a mesh object to rotate by moving the mouse.
\par

\line{\b Move I/J}\par
While in this movement mode, the horizontal scroll bar will move a
 mesh object along the local X (I) axis and the vertical scroll bar
 will move the view along the local Y (J) axis.  The mesh object to be
 moved must be highlighted in the Tree View when this option is selected.
\par
Holding down the left mouse button while within the render view will cause
a mesh object to move by moving the mouse.
\par

\line{\b Rotate K/Move K}\par
While in this movement mode, the horizontal scroll bar will rotate the
 mesh object about the local Z (K) axis and the vertical scroll bar
 will move the view along the local Z (K) axis.  The mesh object to be
 adjusted must be highlighted in the Tree View when this option is
 selected.
\par
Holding down the left mouse button while within the render view will cause
 a mesh object to either rotate about Z (K) if the Shift key is held
 down, otherwise it will move along the Z (K) axis.
\par

\line{\b Light X/Y}\par
While in this movement mode, the horizontal scroll bar will rotate a
 vector light source about the world X axis and the vertical scroll bar
 will rotate the light about the world Y axis.  If the light is a point
 light, the horizontal bar moves in X and the vertical bar moves in Y.
 The light to be adjusted must be highlighted in the Tree View when this
 option is selected.
\par
Holding down the left mouse button while within the render view will cause
 a vector light to be rotated or a point light to be moved.  Additionally,
 if the light is a point light source, then holding down Shift will move
 the light along the Z axis.
\par

\line{\b Adjust Intensity}\par
While in this movement mode, the horizontal and vertical scroll bars are
 locked together and adjust a light source's intensity by moving the mouse.
 The light to be adjusted must be highlighted in the Tree View when this
 option is selected.
\par

\line{\b\fs28 Options}\par

Most of the options are available from the menu bar, with the
 right mouse menus and accelerator keys providing shortcut access.  Some
 options are also available via the toolbar.  The application will display
 a short description string in the status bar for each item.  The following
 options are available:
\par

\line{\b File/New}\par

Creates a new empty scene.
\par

\line{\b File/Open}\par

Loads a scene from an {\i Escher} IFF data file.
\par

\line{\b File/Save\line
File/Save As}\par

Saves the current scene to an {\i Escher} IFF data file.
\par

{\cf2 Note: All other data in the IFF not related to the loaded scene will
 be lost on a save.}\par

\line{\b File/Import}\par

{\cf3 This is not available.}\par

\line{\b File/Palette}\par

This option allows the selection of a {\i Van Gogh} palette used to
 display the colors and texture bitmaps.  The palette must match that used
 to export any textures within the scene.
\par

{\cf2 Note: The palette should be selected before loading the scene.  If
 a palette file of the same name as the scene file name exists in the
 scene file's directory, it will be loaded automatically before the scene
 data is loaded.}
\par

\line{\b File/Send}\par

This option will send the current scene via the Microsoft Mail API.
\par

{\scaps\cf4 NEW}\line
\line{\b File/Use compression\line
File/Use truecolor\line
File/Use 15-bit}\par

These options control the format of texture data when saved or sent.
\par

\line
{\b File/Use floating-point}\par

This option controls the data format for floating-point vs. fixed-point when
saved or sent.
\par

\line{\b File/Exit}\par

This option will exit the tool.
\par

\line{\b Edit/Cut}
\line{\b Edit/Copy}
\line{\b Edit/Paste}\par

{\cf3 This is not available.}\par

\line{\b Edit/Delete}\par

This option will delete an item from the scene.  The item to be deleted
 must be highlighted in the Tree View.
\par

\line{\b Edit/New}\par

This option will create a new camera or light in the scene.  The camera/light
 property sheet is displayed to allow initial editing of the data.  Clicking
 OK will create the new item, Cancel will abort the operation.
\par

\line{\b Edit/Properties}\par

This option will display the current item's property sheet, allowing the
 parameters to be edited.  The item to edit must be highlighted in the Tree
View.
\par

\line{\b View/Toolbar}\par

This will show or hide the toolbar.
\par

\line{\b View/Status Bar}\par

This will show or hide the status bar.
\par

\line{\b View/Refresh}\par

This redraws all of the windows.
\par

\line{\b View/Render}\par

This controls the render view render mode.  The display can be set to:
 Wireframe, Solid, Flat, Smooth, or Specular mode.  Display of hidden
 lines, backface culling, texture mapping, sorting and other
 camera controls may also be affected by this popup menu.
\par

{\b View/Show}\par

This controls the display of additional information such as the
 spherical and box extents of the objects in the viewport.
\par

\line{\b View/Attach Camera}\par

This attaches the a camera to the display viewport.  The camera to attach
 must be highlighted in the Tree View.
\par

\line{\b View/Rotate X/Y}\line
{\b View/Move X/Y}\line
{\b View/Rotate Z/Move Z}\par

These set the current render view movement mode (see Usage/Viewport for
 more information).
\par

\line{\b View/Auto-Rotate}\par

This controls the automatic rotation of all base meshes in the scene.  If
 active, the mesh(es) will be rotated about the selected axis every
 frame.
\par

{\cf2 Note: If the ESHTOOL is run with the -demo command-line switch,
Auto-Rotate Y will be active on startup.}\par

\line{\b Meshes/Rotate I/J}\line
{\b Meshes/Move I/J}\line
{\b Meshes/Rotate K/Move K}\par

These set the current render view movement mode (see Usage/Viewport for
 more information).
\par

\line{\b Lighting/Adjust X/Y}\line
{\b Lighting/Adjust Intensity}\par

These set the current render view movement mode (see Usage/Viewport for
 more information).
\par

\line{\b Help/Help}\par

Displays this topic.
\par

\line{\b Help/About}\par

Displays the version and copyright information for the utility.
\par

\pard\page


{\comment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
Escher Terrain Editor                                                     ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}
\keepn
#{\footnote UG_ESCH_TERR}
${\footnote Escher Terrain Editor}
K{\footnote ESHTEDIT}
+{\footnote BW_UG_5}
{\b\f0{\cf2\scaps User's Guide: Escher}\line\fs32 Escher Terrain Editor}\par\pard\sb100

The purpose of the {\i Escher} Terrain Editor is to generate data files
 needed by the {\uldb EschTerrain}{\v PG_ESCH_TERRAIN} class.  The data
 files for terrain contain the following information:  height-field
 altitudes, surface color, flags, and texture information, and lighting
 normals.  The height-field terrain data may be imported from VistaPro
 or USGS DEM files or from PCX files, and surface information may be
 edited with this utility.
\par

\line{\b\fs28 Usage}\par

The {\i Escher} Terrain Editor is a Windows 95 MFC application that
 operates using standard Windows user interface components.  The display
 consists of the following four child windows:
\par

\line{\b Surface Information Grid}\par
This window displays the surface colors as mapped into the current {\i Van
 Gogh} palette file.  It can be zoomed for a closer view--and easier selection
 of individual points--as well as scrolled.  The status bar will display
 the width,depth index into the surface information table for the grid
 position currently under the mouse pointer, as well as the X/Z world
 coordinate range based on the current settings.
\par

Clicking the left mouse button while pointing at a grid point will display
 the Surface Information Properties dialog.  This dialog allows the setting
 of the surface flags and texture information and includes a subdialog for
 setting the surface color.  If the initial click was done while holding
 down the control key, the surface color subdialog is displayed directly.
 If the initial click was done while holding down the shift key, the currently
 selected texture is assigned to the surface grid location (or a
 rectangle).
\par

{\cf2 Note:  The surface color can only be set for a point without a texture
 assigned to it.  The surface color displayed for textured points is
 determined by the texture's definition, which may be altered with
 the texture properties dialog.}
\par

A right mouse menu is provided that allows access to the zoom levels, show
 modes and the Terrain Properites dialog.  The Terrain Properties dialog
 allows the setting of the current width/depth and height scale factors,
 as well as the description, author, and copyright strings for the export
 file.
\par

\line{\b Texture Definitions}\par
This window displays the current texture definitions.  A texture
 definition consists of a unique name, bitmap file (which must be sized
 to a power of two up to 512 and be readable by the importer), and a color
 (which is used when not displaying texture maps).  The default tile factor
 and control bits may also be set in the texture definition.  These values
 are used when the texture is assigned.
\par

{\cf2 Note:  Texture bitmap file formats must be supported for reading
 by {\i XFile}.}
\par

Clicking the left mouse button will select a texture definition, while
 double-clicking will edit the selected texture's properties (if no
 definition was selected, then a new texture definition dialog will
 occurr).  If the double-click is done while holding down the control
 key, the new texture definition dialog is displayed.
\par

A right mouse menu is provided that allows access to the texture definition,
 editing, deletion, and i/o options.
\par

\line{\b Color Definitions}\par
This window displays the current color definitions.  A color definition
 consists of a unique name, color value, and surface flags.  These values
 are used when the color definition is assigned.
\par

Mouse controls as the same as the {\b Texture Definitions} window.
\par

\line{\b Render View}\par
This window displays the current terrain data set using the {\i Escher}
 render engine.  The view may be moved and the light source adjusted
 to examine the terrain render results.
\par

Clicking and holding down the left mouse button within the render view
 will allow mouse-controled movement, rotation, or adjustment (depending
 upon the current movement mode).
\par

A right mouse menu is provided that allows access to the render modes,
 movement modes, Light Properties and View Properties dialogs.  The View
 Properities dialog allows direct setting of the world X/Y/Z location of
 the camera, orientation vectors, field-of-view, and level-of-detail
 cutoffs, as well as the hither/yon clipping planes, camera scale
 factor, and background color.  The 'Hover' mode height offset may
 be adjusted with this dialog.  The Light Properties dialog controls the
 light source type and control information.
\par

The following movement modes are provided for controlling the view:
\par

\line{\b Hover}\par
While in this movement mode, the horizontal scroll bar will move the
 camera along the local X (I) axis and the vertical scroll bar will
 move in the local Z (K) axis.  The camera's Y (J) position will be
 set to a fixed height above the terrain data.
\par

\line{\b Rotate X/Y}\par
While in this movement mode, the horizontal scroll bar will rotate the
 camera about the local Y (J) axis and the vertical scroll bar will rotate the
 view about the local X (I) axis.
\par
Holding down the left mouse button while within the render view will cause
 the camera to rotate by moving the mouse.
\par

\line{\b Move X/Y}\par
While in this movement mode, the horizontal scroll bar will move the
 camera along the local X (I) axis and the vertical scroll bar will move the
 view along the local Y (J) axis.
\par
Holding down the left mouse button while within the render view will cause
 the camera to move by moving the mouse.
\par

\line{\b Rotate Z/Move Z}\par
While in this movement mode, the horizontal scroll bar will rotate the
 camera about the local Z (K) axis and the vertical scroll bar will move the
 view along the local Z (K) axis.
\par
Holding down the left mouse button while within the render view will cause
 the camera to either rotate about Z (K) if the Shift key is held down,
 otherwise it will move along the Z (K) axis.
\par

\line{\b Light X/Y}\par
While in this movement mode, the horizontal scroll bar will rotate or
 translate the light source about/in the world X axis and the vertical
 scroll bar will rotate about/translate in the world Y axis.
\par
Holding down the left mouse button while within the render view will cause
 the light to be rotated/translated by moving the mouse.  For point lights,
 shift-clicking will adjust the Z position.
\par

\line{\b Adjust Intensity}\par
While in this movement mode, the horizontal and vertical scroll bars are
 locked together and adjust the light source intensity.
\par
Holding down the left mouse button while within the render view will cause
 the light to change intensity by moving the mouse.
\par

\line{\b\fs28 Options}\par

Most of the editing options are available from the menu bar, with the
 right mouse menus and accelerator keys providing shortcut access.  Some
 options are also available from the tool bar.  The application will display
 a short description string in the status bar for each item.  The following
 options are available:
\par

\line{\b File/New}\par
This option clears all of the terrain data set information, and begins
 in the Terrain Properties dialog.
\par

{\cf2 Note:  This is the only time that the size of the terrain data
 set and height-to-surface grid ratio may be set.  The width, depth, and
 surface ratio fields will be disabled when the dialog is activated from
 the Terrain/Properites option.}\par

\line{\b File/Open}\par

This will open a saved CST file containing the height field, surface
 colors, texture definitions, and other surface information.  The actual
 texture data files and {\i Van Gogh} palette file are assumed to exist on
 the system.
\par

{\cf2 Note: Exported IFF files containing terrain data sets may not
 be loaded into the editor.  The texture definitions and true RGB surface
 colors are not stored in an exported IFF file.}\par

\line{\b File/Save\line
File/Save As}\par

Saves the current height field, surface colors, texture definitions, and
 other surface information to a CST file for use in future editing sessions.
 The actual palette data and texture bitmaps are NOT saved into the CST file.
\par

\line{\b File/Export}\par

This option will generate an {\i Escher} Terrain IFF file which may be
 loaded into an {\uldb EschTerrain}{\v PG_ESCH_TERRAIN} object instance.
\par

\line{\b File/Exit}\par

This option will exit the terrain editor.
\par

\line{\b Edit/Undo}\par

This will undo the last change to the surface information structure (colors,
 attributes, or texture assignment).  This is currently only a one-level
 undo.
\par

\line{\b Edit/Flip Horizontal\line
Flip Vertical}\par

Flips the terrain heights, normals, surface information, and surface colors
 horizontally/vertically.
\par

\line{\b Edit/Rotate 90\line
Edit/Rotate -90}\par

Rotates the terrain heights, normals, surface information, and surface colors
 by 90 degrees to the right/left.
\par

\line{\b Edit/Assign by Height\line
Edit/Assign by Random Roll\line
Edit/Assign by Angle}\par

These tools provide a number of options for automatically assigning texture
 and color definitions based on either the terrain properties or based on
 a random roll.  These may be applied to the entire map or to a region, which
 is selected immediately after the tool dialog by left-clicking and then
 holding down the left mouse button while dragging out a region.
\par

If the 'Preserve texture assignments' option is selected in a tool, then
 any point with a texture currently assigned to it in the affected area
 will be left intact.  This is useful to composite a number of tool
 texture assignments onto the same terrain area.
\par

{\cf2 Note:  The 'Assign by Angle' tool uses the surface normals which
 are computed by averaging the surface angles around a given point.  This
 means they are not accurate surface angles in some cases, but are
 indicative of the surface angle at that point.}
\par

\line{\b View/Toolbar}\par

This will show or hide the toolbar.
\par

\line{\b View/Status Bar}\par

This will show or hide the status bar.
\par

\line{\b View/Render View}\par

This will show or hide the render view.
\par

\line{\b View/Zoom}\par

This popup menu will allow the selection of a zoom factor for the surface
 information grid display (Zoom x 1, x 2, x 4, x 8, or x 16).
\par

\line{\b View/Show}\par

This popup will allow the selection of the surface information display
 mode: displaying basic surface colors, shaded colors, shaded height-based
 coloring, only those surface grid locations with assigned textures,
 or shaded coloring based on application bits.  There are four application
 bits which results in 16 colorings:
\par

\tab No bits\tab\tab Dark Grey\line
\tab A0\tab\tab Red\line
\tab A1\tab\tab Green\line
\tab A1 A0\tab\tab Yellow\line
\tab A2\tab\tab Blue\line
\tab A2 A0\tab\tab Magenta\line
\tab A2 A1\tab\tab Cyan\line
\tab A2 A1 A0\tab Medium Yellow\line
\tab A3\tab\tab Medimum Gray\line
\tab A3 A0\tab\tab Dark Red\line
\tab A3 A1\tab\tab Dark Green\line
\tab A3 A1 A0\tab Dark Yellow\line
\tab A3 A2\tab\tab Dark Blue\line
\tab A3 A2 A0\tab Dark Magenta\line
\tab A3 A2 A1\tab Dark Cyan\line
\tab A3 A2 A1 A0\tab White\line
\par

\line{\b View/Refresh}\par
This redraws all of the windows.
\par

\line{\b View/Render}\par

This controls the render view render mode.  The display can be set to:
 Dots, Wireframe, Solid, Flat, Smooth, or Specular mode.  Backface culling
 and texture mapping may also be controlled by this popup menu.
\par

\line{\b View/Hover}\line
{\b View/Rotate X/Y}\line
{\b View/Move X/Y}\line
{\b View/Rotate Z/Move Z}\par

These set the current render view movement mode (see Usage/Render View for
 more information).
\par

\line{\b View/Properties}\par

This displays the View Properties dialog (see Usage/Render View for more
 information).
\par

\line{\b Terrain/Import}\par

This option will import the height-field altitudes from a DEM file
 or a PCX file.\par

A number of methods are available for creating the 256-entry height table
 associated with the height field for importing from DEM files.  The
 'standard' method truncates the 16-bit data which results in 16 meter
 resolution.  The 'uniform' method creates a height-table which linearly
 ramps from the minimum height to the maximum height in the terrain set.
 The 'averaged' method creates a height-table from all used heights in the
 imported data compressed to a 256-entry table by averaging the least-used
 values (given a maximum threshold of distance between two values).
\par

{\cf2
Note:  If a given 'average' threshold is not attainable, a warning message
 will be displayed and the 'uniform' method will be exectued on the data.
 You should try to reimport the data with a larger threshold.
}\par

\line{\b Terrain/Set Base Elevation}\par

This sets the 'base' elevation for the map, adjusting all height values
 relative to the given base height.  This adjusts the terrain's
 height-table values, but preserves all other settings.
\par

\line{\b Terrain/Properties}\par

This displays the Terrain Properities dialog (see Usage/Surface Information
 Grid for more information).
\par

\line{\b Surface/Import}\par

This option will import surface colors from a PCX file.  The data is cropped
 or zero-extended to fit the current width, depth, and surface ratio.
\par

\line{\b Surface/Define Texture}\par

This option allows the definition of a new texture.
\par

\line{\b Surface/Edit Texture}\par

This option allows the editing of the currently selected texture
 definition's properties.
\par

\line{\b Surface/Delete Texture}\par

This option will delete the currently selected texture definition from
 the system, revert all surface grid points using the texture to the last
 surface color for that point, and renumber all higher textures to fill the
 gap.
\par

\line{\b Surface/Remove Unused Definitions}\par

This option will delete the texture definition for any texture that hasn't
 been applied to any point on the terrain surface.  This should be
 performed before the data is exported to prevent excees memory
 consumption.
\par

\line{\b Surface/Load Textures\line
Surface/Save Textures}\par

These options allow the current texture definitions to be written to an
 external ASCII file (.TS) and then loaded into another terrain set.
 This is useful when a standard set of basic textures is reused in a
 number of terrains.  When loading textures, you will be prompted
 if there is a name conflict to either overwrite the current definition
 with the file's contents or to skip that definition and continue the load.
\par

\line{\b Surface/Define Color\line
Surface/Edit Color\line
Surface/Delete Color}\par

These options define, edit, and delete color definitions similiarly to
 the texture options above.
\par

\line{\b Surface/Load Colors\line
Surface/Save Colors}\par

These options allow the current color defintions to be written to an
 external ASCII file (.CS) and then loaded into another terrain set
 similiarly to the texture options above.
\par

\line{\b Surface/Palette}\par

This option allows the selection of a {\i Van Gogh} palette used to color
 all surface colors and textures.  The proper palette must be used when
 loading an exported file to ensure correct coloring.
\par

\line{\b Lighting/Adjust X/Y}\line
{\b Lighting/Adjust Intensity}\par

These set the current render view movement mode (see Usage/Render View for
 more information).
\par

\line{\b Lighting/Properties}\par

This displays the Lights Properties dialog (see Usage/Render View for more
 information).
\par

\line{\b Help/Help}\par

Displays this topic.
\par

\line{\b Help/About}\par

Displays the version and copyright information for the utility.
\par

\pard\page

{\comment °±² eof - escher.rtf ²±° }
}
